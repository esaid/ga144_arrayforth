{block 0}
[0x74eb] [0x250] [0x0] [0x0] [0x0] < oootoro > [0x37363534] [0x42413938] [0x46454443] [0x0] [0x0] [0x0] [0x0] [0xf000ffff] [0x9300] [0xffff] [0x9320] [0x0] [0x0] [0x0] [0x0] [0xb90660] [0x83f78b02] [0xc03324c6] [0x87b4c08e] [0xc03315cd] [0x3e4581] [0x40451002] [0xbb6107] [0x46ebc3fe] [0x56515006] [0x8eb800b8] [0x4b9c0] [0x458ac033] [0xd1e8d111] [0xd1e8d1e8] [0x3f08be8] [0x14448af7] [0x2612758b] [0x45830488] [0x65810212] [0xd107ff12] [0x65d11065] [0x1065d110] [0xe21065d1] [0x124583cf] [0x58595e02] [0xff2bc307] [0xc78edf8e] [0xfb7c00bf] [0xe8105589] [0x5508ffaa] [0xa558a0a] [0xcd5708b4] [0x55895f13] [0xff98e810] [0x7588c6fe] [0x10558908] [0x89ff8de8] [0x87e8104d] [0xe4d89ff] [0x883fe180] [0x4d89024d] < ?wm0r > [0x8bfe00bb] [0x558b0c4d] [0x4758b0a] [0x8e0f00b8] < e13/s > [0xfe0f7502] [0x8753ac6] [0xf6320575] [0x8001c580] [0x8141c0e1] [0xb80200c3] [0x13cd0201] [0x48104589] [0x3fe80374] [0xff18e8ff] [0x33d3754e] < wastof > [0x83b003fb] [0x8003b0ee] [0x33ee03ea] < fr6etd > [0x2c28003] [0x80c033ee] [0xb0ee02ea] [0x3c28003] [0x21ebee] [0x7d700017] [0x0] [0x0] [0x0] [0xffff] [0xcf9a00] [0xffff] [0xcf9200] [0xbb4f02b8] [0x10cd4118] [0xc03366fa] [0x8cd88b66] [0x8edb8ecb] < @eafnd > [0x8ef08b66] [0x16010fd8] [0x1b07d68] [0xeac0220f] [0x87db4] [0x525014eb] [0x824548b] [0xf8ba028a] [0xee000003] [0x4ff585a] [0x10b0c324] [0xc08ed88e] [0xbcd08e] [0x33000a00] [0xe6d1b0c9] [0x2464e464] [0xb0fa7502] [0xbe60e64b] [0x9f400] [0xffffc5e8] [0xbf41ff] [0xff002002] [0xe7] < gege > [0x525057eb] [0x3fdba] [0x20a8ec00] [0xea80fb74] [0x24448b05] [0xee008a08] [0x4ff585a] [0x5052c324] [0x3fdba] [0x20a8ec00] [0xea80fb74] [0x5aee5805] [0x8b960c3] < mn > [0x4c2c1d0] [0xf25c28b] < me > [0x7c1480] < ?kol > [0xe9e2ffff] [0xffffade8] [0xad6120ff] [0xe86debc3] [0xffffffa2] [0xff9ce80d] [0xc30affff] [0xe9c1c88b] [0xf88bad02] [0xc2f6d233] [0xe819750f] [0xffffffdf] [0xc203c78b] [0x89fc768d] [0xffa7e806] [0x73e8ffff] [0x20ffffff] [0x8d17048b] [0x689fc76] [0xffff94e8] [0x4c283ff] [0xb4e8d0e2] [0xadffffff] [0x7c8b60c3] [0x768d2024] [0x8b0689fc] [0xfc768d07] [0x478b0689] [0xffa6e804] [0x8361ffff] [0xc3082404] [0xffff8ee8] [0xfc768dff] [0x78b80689] [0xe8123456] [0xffffff55] [0xffff7ae8] [0x11ae9ff]

{block 1}
[0x1b5ae9] [0x0] [0x1b4de9] [0x0] [0x66636d63] < ott9lt > [0x64702d63] [0x89fc768d] [0xa15606] [0x89002028] [0x4c08320] [0x8b58e0ff] [0x2800a320] [0xad5e0020] [0xdde857c3] [0x5fffffff] [0xffe8e8c3] [0xfff8ffff] [0xdfe80009] [0xf8ffffff] [0xe80009db] [0xffffffd6] [0x9b7f8] [0xfcbae3eb] [0x890009cf] [0xdbfcb90a] [0x18f0009] [0x89fc498d] [0x4f0d8911] [0xc3002004] [0x9abfcba] < wtrart > [0x9b7fc] [0x498d018f] [0x891189fc] [0x2004580d] < m@ovs > [0x20280405] < ?8ol > [0x15ffffff] [0x20280c] [0x280415ff] [0x15ff0020] [0x202810] [0xdce8eceb] [0xc3ffffff] [0x2804058f] [0x9be80020] [0xffffffff] [0x20280415] < m?m3 > [0x20280805] < ?0we > [0x5ee8ffff] [0xffffffff] [0x20280815] < kiy.s > [0xffffffe3] [0xf404bec3] [0x8bc30009] [0x2027bc0d] [0x980d8900] [0x8b002027] [0x2027b80d] < ysonte > [0x8b002027] [0x2027a40d] [0xa00d8900] [0xc3002027] [0x27a00d8b] [0xd890020] [0x2027a4] [0x279c0d8b] [0xd890020] [0x2027b8] [0x27980d8b] [0xd890020] [0x2027bc] [0x27ac05c7] [0x20] < misd > [0x2027bc0d] < ohngi > [0x20283c8d] < mnr6f > [0x2027b80d] < ohngi > [0x4cfffc8d] < g?t,s > [0xffc35ffc] [0x20275825] < lsantd > [0x89002027] [0x2027b015] [0xad02c600] [0x27a405ff] [0x8bc30020] [0x2027a415] < raoccs > [0x2027b0] [0x3a800c75] [0x890775ad] [0x2027a415] < ramisd > [0x2027a4] [0x768d02c7] [0x42c689fc] [0x5830604] [0x2027a4] [0x768dc305] [0xc30689fc] [0x27cc058f] [0xe8c30020] [0xfffffff4] < wsont2 > [0xff002027] [0x2027bc05] < mlotoe > [0x202840] [0x218b8] [0xe81eeb00] [0xffffffd4] [0xb80d8b50] [0xff002027] [0x2027b805] < mlotoe > [0x4d0000] [0x2800b8] < wlattd > [0xfffffffc] [0x89f0e283] [0xa4158b11] [0x89002027] [0x148d0114] [0x2eac101] [0x27a81589] [0x89580020] [0x2027b025] < csrird > [0xb6002027] [0xf7002005] [0x2027ac05] < ???8 > [0xff0674ff] [0x2027ac25] [0x768dc300] [0x8b0689fc] [0x48d04] [0xe8c3004d] < ???' > [0x280081c7] [0x6460000] [0x5ff0020] [0x2027b8] [0x47047989] [0x9405c7c3] [0xb6002027] [0xe8002005] [0xffffff07] [0x27b0158b] [0x15890020] [0x2027b4] [0x27a4158b] [0x15890020] [0x2027b0] [0x89b802c6] [0x5830142] [0x2027a4] [0x15ffc305] [0x202794] [0xbd048b] < ei > [0x15ff10eb] [0x202794] [0xfcbd048b] [0xc1ffffff] [0xb0e805f8] [0xadffffff] [0xffff33c3] [0x2027880d] < glir0 > [0x5c7f5eb] [0x202794] [0x20066d] [0x89fc768d] [0xbd048b06] [0xfffffffc] [0xe8f0e083] [0xfffffe5f] [0xfe6d850f] [0xffadffff] [0x28008d24] [0x15ff004d] [0x202794] [0xfcbd048b] [0x83ffffff] < tqeis8 > [0x75fffffe] [0x24ffad08] [0x202a588d] < ?rn! > [0x48bffff] [0x4d28008d] < oeslod > [0x8bfffffe] [0x2027a415] [0xb0158900] [0xc6002027] [0xc283e802] [0x89c22b05] [0x1589fc42] [0x2027a4] [0x15ffc3ad] [0x202794] [0xfcbd048b] [0x83ffffff] < 6ieis8 > [0x8bfffffd] [0x2a588d04] [0xbdeb0020] [0x279405c7] [0x66d0020] [0x768d0020] [0x8b0689fc] [0xfffcbd04] [0xf8c1ffff] [0x5c7c305] [0x202794] [0x20066d] [0x89fc768d] [0xbd048b06] [0x0] [0x4b9c347] < mn > [0x2027a415] [0x8b028900] [0x11148d06] [0x8904768d] [0x2027a415] [0x1b9c300] < .s > [0x2b9e2] < 5!d > [0x3b9] < migogs > [0x2027a415] [0x5ea8300] [0x27b01539] [0x8750020] < iakr2 > [0xc302fe03] [0xc30542c6] [0x27a405ff] [0x89c30020] [0x2027b025] < lsantd >

{block 2}
[0x2b002027] [0xff5088d0] [0x2589c3ad] [0x2027b0] [0x89fc768d] [0x27a4a106] [0x8bc30020] [0x2027a415] < *gtml > [0x27b01539] [0x33750020] [0x75b83a80] [0xfc768d2e] [0xb4a10689] [0xa3002027] [0x2027b0] [0x8101428b] [0x768dfb7a] [0xb7489fc] [0x27a41589] [0x16e90020] [0x83fffffd] [0x2027a405] < oov*s > [0x639c3d2] [0xc9330278] [0xbd04f7c3] [0xfffffffc] < ???? > [0x5f5f0275] [0xd0035ac3] [0x582548d] [0xadfc5203] [0x503e2ff] [0x202748] [0x5708e0c1] [0x8badf88b] [0xbd14] < snmd > [0x14ff0fe2] [0x2027c095] [0xeceb00] [0x28180d8b] [0xe1c10020] [0x3c18310] [0x28140d89] [0xd890020] [0x202820] [0xd8b66c3] [0x202816] [0x1c0d3b66] [0x78002028] [0x180d8b19] [0xc1002028] [0x8b6610e1] [0x2028140d] [0x1ec18300] [0x28140d89] [0x8dc30020] [0x689fc76] [0xffffffb8] < tsncms > [0xc3ad0020] [0xcf8ba] < atmwws > [0x8dc3ed04] [0x689fc76] [0x80008b8] [0xfeb980] < inml > [0xe80689fc] [0xffffffdc] [0x25] [0x44633ff] [0x2d0874ad] [0x800] [0x8de37549] [0x408d0476] [0xb8c3f8] [0xe8030000] [0xffffffc3] [0xb110408d] [0xfc768d06] [0xa9e80689] [0x24ffffff] [0x740834fb] [0x408dad16] [0xe9754904] [0x8de8408d] [0x689fc76] [0xffff8fe8] [0xa3f024ff] [0x202830] [0xc3adc3ad] [0x2c358b56] [0x57002028] [0x28303d8b] [0xb90020] [0xf3000c00] [0xc35e5fa5] [0xffffe3e8] [0xfa9fe9ff] [0x3d8bffff] [0x202814] [0x8566cf8b] [0x330279c9] [0xffe181c9] [0x890000ff] [0x20283c0d] [0xc96900] [0xc1000010] [0x27910ff] [0x3d89ff33] [0x202838] [0x3b93c8d] [0x2028283d] < ggynrs > [0x10b9c486] < nn > [0x273e0d1] [0xc7831789] [0xf3754904] [0x86ad66c3] [0x10b9c4] < 8nm > [0x17891173] [0x89045789] [0x100097] [0x4978900] [0x83000010] [0x754908c7] [0xaee8c3e5] [0x56fffffe] [0xc06b5257] [0xb08d30] [0xe8002030] [0xffffff76] [0x2834158b] [0x18b90020] < ar > [0xffff9de8] [0xc0c781ff] [0x5900000f] [0x5af07549] [0x81ad5e5f] [0x20281405] < rn aianvs > [0x30c06b52] [0x3000b08d] [0x3be80020] [0x8bffffff] [0x20283415] [0x18b900] < ktm > [0xffffff79] [0x1f80c781] < ecfe > [0x5f5af075] [0x1405815e] [0x2028] [0xad002c00] [0xfe5de8c3] [0x5c7ffff] [0x202818] [0x3] [0x281c05c7] [0x3f40020] [0x1e90000] [0xe8fffffe] [0xfffffeee] [0xe1d10e8b] [0xf92be1d1] [0x34a1c88b] [0xf3002028] [0x1405ffab] [0xad002028] [0xcfe8c3ad] [0x3dfffffe] [0x301] [0xb80578] [0x8b000003] [0x3c0d2bc8] [0x7e002028] [0x13e8131] [0x78000004] [0x6c706] [0xa1000004] [0x202838] [0x1a7e0629] [0x400ba] < dmntf > [0x34a102e2] [0x51002028] [0xabf30e8b] [0x4959fa03] [0xadadf575] [0xfc768dc3] [0xffb80689] [0xe90000ff] [0xfffffdd1] [0x89fc768d] [0xffb806] [0xc2e900ff] [0x8dfffffd] [0x689fc76] [0xc0c0c0b8] < ,4*t > [0x768dffff] [0xb80689fc] [0x4040ff] [0xfffda4e9] [0xfc768dff] [0xb80689] [0xe900ff00] [0xfffffd95] [0x89fc768d] [0xff00b806] < s6y > [0xfffffd] [0x0] [0x0] < wtgs > [0xa] [0xb6f3d8d] [0x778d0020] [0x5ea4f301] [0x200b79a2] [0x8dc3ad00] [0x689fc76] [0xbb9] < n'zoe > [0x3300200b] < gfgiyd > [0xfc768dc3] [0xd2330689] [0x1eb9] < mi9+s > [0xe5c281c2] [0x8900037f] [0x20281415] < wrstre > [0x0] [0xc3400175] [0x89fc768d] [0xa3c03306] [0x202814] [0xfffd14e8] [0xfc768dff] [0xb80689] [0x8d000004] [0x689fc76] [0x300b8] < ?nnies > [0x18a3ffff] [0xad002028]

{block 3}
[0x281ca3c3] [0xc3ad0020] [0x2814a366] [0x66ad0020] [0x202816a3] < nnv3e > [0x28140501] [0x66ad0020] [0x28160501] [0xc3ad0020] [0x89fc768d] [0x43b806] < anmn > [0x79d28504] [0x89daf707] [0x1340456] [0x279163b] [0x18c30434] [0x1c1b1a19] [0x201f1e1d] [0xa130521] [0x8d0e0410] [0x689fc76] [0x47808a51] [0xe800200c] [0xfffffda6] [0xc0c1c359] [0xfc768d04] [0xe0830689] [0xd08bc30f] [0xc8dd8f7] [0x2085] < dnygl > [0x5ebca8b] [0x8b9] < ?zol > [0xc5e8ffff] [0x49ffffff] [0xc3adf375] [0x7b9] < ?9ol > [0x1975ffff] [0xf57549ad] [0xffb8e841] [0xa5e8ffff] [0x49ffffff] [0x84e8f375] [0xadfffffd] [0xeeeb41c3] [0x27703d83] [0x750a0020] [0x85d08bcf] [0xf71179d2] [0xfc768dda] [0x23b80689] < k > [0xfffffd2a] [0x8b9] < ooveas > [0x8d34f7d2] [0x202700] [0x1075c085] [0xebee7949] [0x33c28b13] [0x8d34f7d2] [0x202700] [0xffff4ae8] [0xed7949ff] [0x40e8c28b] [0xe8ffffff] [0xfffffd27] [0xc783c3ad] [0x8e80c] < rm0 > [0x83fffffd] [0x4b910ef] < ar > [0x89fc768d] [0x8ac03306] [0xe8470447] [0xfffffcca] [0xeb754959] [0xf3fcbfc3] [0x158b0009] [0x200446] [0x11733a39] [0x89fc768d] [0x83078b06] [0x5de804ef] [0xebffffff] [0xd49c3e5] [0xf4000020] [0x4460009] [0x4920020] [0xae80020] [0x8bfffffd] [0x2027683d] < ,ofml > [0x78a10689] [0xe8002027] [0xfffffb61] [0x202760a1] [0xc08300] [0x202818a3] < solttd > [0xc6c2] < rdgmt > [0xc1002028] [0x50310e0] [0x202764] [0x202814a3] < ?gqe > [0x57e8ffff] [0xe8ffffff] [0xffffff52] [0xfffb00e8] [0x140581ff] [0x2028] [0x8b005800] [0x20276c3d] [0xcc78300] [0x3b9] < ?lak > [0x8366ffff] [0x2028142d] < bfnr8 > [0x20281605] [0x8d023500] [0x200b6b3d] [0xbb900] < tek > [0x66ffffff] [0x281805c7] [0x30020] [0x1605c766] [0x3002028] < inra?s > [0x8d00200d] [0x689fc76] [0xffff00b8] < *a?l > [0x8366ffff] [0x20281405] [0x5c71e00] [0x202818] [0x3] [0x1605c766] [0x3002028] < nlew, > [0xd00200d] [0x140c010a] [0x13080602] [0x12110f09] [0x5070e0b] [0x17160403] [0x19101524] [0x1c001b1a] [0x1f181e1d] < tcajrt > [0x262c2a28] [0x2d2e2522] [0x19232b27] [0x1c001b1a] [0x1f181e1d] [0x2120] [0x0] [0x0] < rc > [0x1c001b1a] [0x1f181e1d] [0x2120] [0xa1305] [0xe0410] < od > [0x8b097804] [0x20276815] [0x10048a00] [0x121110c3] [0x4000013] [0x70605] < re > [0x171615] [0xa090800] [0xb] < rloto > [0xc01001b] [0xf0e0d] [0x8d020300] [0x689fc76] [0x3ee8c033] [0xe4fffff5] [0x7401a864] [0xa860e4fa] < oqlie; > [0x8af0733a] [0x200eb580] [0x90c300] [0x1902180b] [0x1b041a03] [0x1d061c05] [0x1f081e07] [0x210a2009] [0x1330051e] [0x10200a2e] [0xe210412] [0x14230d22] [0x22240717] [0xc262425] [0x6310932] [0x12190318] [0x1131710] [0x214081f] [0x112f1616] [0x152d0f11] [0x262c0b15] [0x2534230c] [0x28272735] [0x2a822928] [0x2c832b8d] [0x2e332d89] [0x80392fb5] [0x820e811c] [0x843b8301] [0x768d3029] [0x330689fc] < !ai!o > [0x64e4ffff] [0xfa7401a8] [0xc88b60e4] [0x807fe180] [0x5742af9] < iaon@d > [0x3480240b] < timcmd > [0xdeeb0020] [0xda78c00a] [0x50b7f24] [0x20278c] [0x200f14ba] [0x35b900] [0x2380000] [0xc2830874] [0x33f7e202] < etmas; > [0x14ea8101] [0xd100200f] [0x901589ea] [0xa9002027] [0x80] [0x20121fc3] [0x20121f00] [0x20121f00] [0x20127100] [0x5000000] [0x20112c00] [0x2010c400]

{block 4}
[0x20106a00] [0x20129600] [0x5251500] [0x20121f00] [0x20121f00] [0x20115d00] [0x20128300] [0x2d210000] [0x20112c00] [0x2010c400] [0x20106a00] [0x2012a800] < t1tma > [0x20121f00] [0x20115300] [0x20127000] [0x2011fb00] [0xe052300] [0x20115a00] [0x20121700] [0x2011b000] [0x20115a00] [0x251500] [0xd8a1c00] [0x20105d] < 1sedd > [0xefe8c326] [0xadffffff] [0xffe8e8c3] [0x5ffffff] [0x202788] [0x105d05c6] [0x281c0020] [0x20105d2d] [0x8dc28b00] [0x689fc76] [0x50c083c3] [0xdeb07b1] [0xf573103c] [0x8a804b1] [0x34410374] [0x8ad08b18] [0x5d0d38e9] [0x73002010] [0x72e8d008] [0xebc9febc] < ortn1@ > [0x5d0d2806] [0xc3002010] [0xfffacae8] [0x2788a1ff] [0x348d0020] [0x25ffad86] [0x202750] [0xfffab6e8] [0x8805c7ff] [0x1002027] < bs > [0x20277c05] [0x100] < ,ofml > [0x6c70689] [0x0] [0x105d05c6] [0xe81c0020] [0xfffffdaf] [0x158b0979] [0x20276c] [0x848224ff] < mlaa1s > [0x689fc76] [0xfffa59e8] [0xff72e8ff] [0x5ffffff] [0x20277c] [0xfdbde8ad] [0xcfebffff] [0xa0e] [0xc0000] [0xf0000] [0xb00000d] [0x0] [0x3020100] [0x7060504] [0xa2000908] [0x201152] [0xebad49eb] [0x7415ff0f] [0xc6002027] [0x20115205] < dry > [0xfffd7ee8] [0xfd41e8ff] [0x979ffff] [0x276c158b] [0x24ff0020] [0x74c08482] [0x30808ad5] [0xf6002011] [0x20115205] [0x2741f00] [0x168bd8f7] [0x7015af0f] [0x3002027] < glalek > [0x276c05c7] [0x10490020] [0xbceb0020] [0x8415ffad] [0xff002027] [0x20275025] [0x7005c700] [0xa002027] < bs > [0x20276c05] [0x20103500] [0x6805c700] [0x83002027] [0xc300200e] [0x277005c7] [0x100020] [0x5c70000] [0x20276c] [0x201035] [0x276805c7] [0xe9b0020] [0x81c30020] [0x20277435] [0x6100] < eioas > [0x2f002010] [0x277415ff] [0x43e90020] [0xadffffff] [0x5025ffad] [0xad002027] [0x5c716eb] [0x20276c] [0x20100d] [0xe533d8d] [0x3d890020] [0x202768] [0x275405f7] [0xffff0020] [0x674ffff] [0x275425ff] [0xa0e80020] [0x3cfffffc] [0x8b097904] [0x20276c15] < seey, > [0x276c0583] [0xe8140020] < ???q > [0x278015ff] [0xb2eb0020] [0x6c05c7ad] [0xd002027] [0x8d002010] [0x200e533d] [0xc710eb00] [0x20276c05] [0x200fe500] < nfifoe > [0xad00200e] [0x5c79ceb] [0x20276c] [0x201021] [0xe533d8d] [0x10eb0020] [0x276c05c7] [0xff90020] [0x3d8d0020] [0x200e6b] [0x27683d89] [0x69e90020] [0x8dfffffe] [0x689fc76] [0xa78c085] [0xc10426c1] < 8ersed > [0xe0d1c307] [0x26c10c78] [0x4c0c105] [0x3407e083] [0x26c1c308] [0x6c0c107] [0x2c3fe083] [0x768dc310] [0xff0689fc] [0x343d3906] [0x75002027] [0x2734a305] [0x53b0020] [0x202734] [0xc791074] [0x273c3d89] [0x3d890020] [0x202738] [0x3d89c3ad] [0x202738] [0x28142d81] [0x20] [0x768d0016] [0xb80689fc] [0xe04000] [0xfff5b8e8] [0x30b8ff] < mnu > [0x2028160d] [0xd3b6600] [0x20281c] [0xb7e81078] [0x81fffff6] [0x2028142d] < rn l,ysd > [0xe8fffff6] [0xfffff57f] [0x89fc768d] [0xbd048b06] [0xfffffffc] [0xe8f0e083] [0xffffff43] [0x87e80774] [0xebfffff6] [0xf6b5e8f2] [0xadadffff] [0xd8b66c3] [0x202816] [0x180d3b66] [0x74002028] [0xf52be805] [0xa6e8ffff] [0xebfffff7] [0xf7aee8bf] [0xb8ebffff] [0xfff75ce8] [0x8db1ebff] [0x689fc76] [0xffff00b8] < !cw0 > [0xa0ebffff] [0xfff51ae8] [0xfc768dff] [0x48b0689] [0xfffffcbd] [0xf0e083ff] [0xfffedee8] [0xe83004ff] [0xfffff622] [0xf8e88deb] [0x8dfffff4] [0x689fc76] [0xfcbd048b] [0x83ffffff]

{block 5}
< wylis8 > [0x74fffffe] [0xe8300480] [0xfffff5fe] [0x2d81f0eb] [0x202814] [0x160000] [0xfcbd04f7] [0xf0ffffff] [0xfffffff] [0xffff3f85] [0x3d894fff] [0x202740] [0xfff60ae8] [0xfeb4e8ff] [0xad5affff] [0xbd148bc3] [0xfffffffc] [0xeb05fac1] [0x2405c71c] [0xcd002027] [0xe800200c] [0xfffff6c8] [0xffff0be8] [0xbd148bff] [0x0] [0xfc768d47] [0xb80689] [0x810000f8] [0x2027243d] [0x200ccd00] [0xb8367400] [0xc000] [0x148b2feb] [0xfffffcbd] [0x5fac1ff] [0x148b08eb] [0xbd] < inmgrd > [0xb80689fc] [0xffff00] [0x27243d81] [0xccd0020] [0x5740020] [0xc0c000b8] < !r7l > [0x768dffff] [0x8b0689fc] [0x2425ffc2] [0x8b002027] [0xfffcbd14] [0xfac1ffff] [0xfc768d05] [0xffb80689] [0x8100ffff] [0x2027243d] [0x200ccd00] [0xb8057400] [0xc0c0c0] [0xc7eb] [0x201412] [0x2013bb] [0x201492] [0x201391] [0x2013ad] [0x201461] [0x201441] [0x2013b4] [0x201486] [0x201367] [0x2013cc] [0x2013ee] [0x20144d] [0x200492] [0x200492] [0x2014c7] [0xfff554e8] [0xfc768dff] [0xc0330689] [0x27283d8b] [0x3d030020] [0x202748] [0x8908e7c1] [0x20273c3d] < osifte > [0xf7002027] [0xbd04] [0xf0000] [0x5740000] [0xfffd89e8] [0xbd148bff] [0x0] [0x2405c747] [0xcd002027] [0xf600200c] [0xa7410c2] [0x272405c7] [0xc9c0020] [0xe2830020] [0x9514ff0f] [0x2014f0] [0xf8e8c1eb] [0xe8ffffee] < ??,b > [0xffff8be8] [0xf7d0e9ff] [0xffff] [0xffff00] [0x0] [0xff0000] [0xc000] [0x0] [0x0] [0xffff] [0x0] [0xffffff] [0xffffff] [0xffffff] [0x8080ff] [0xc0c0c0] [0xff] [0x0] [0x0] [0x340dff01] [0x79002027] [0x3405ff06] [0xc3002027] [0x27342d83] [0x79080020] [0x3405c70a] [0x2027] < vs > [0x27340583] [0xc3080020] [0x27280583] [0xc3020020] [0x27283d83] [0x78140020] [0x282d8307] [0x2002027] [0x280d8bc3] [0x87002027] [0x20272c0d] < tsrfte > [0xc3002027] [0x27283583] [0xc3010020] [0x27400d8b] [0xd030020] [0x202788] [0x27400d33] [0xe1810020] < ???8 > [0xd8b0b74] [0x202788] [0xfc7549ad] [0x358b56c3] [0x202740] [0x8b4ece8b] [0x883d03fe] [0xc1002027] [0xd2b02e7] [0x202738] [0xe6c10778] [0xa5f3fd02] [0xefc15efc] [0x3d894702] [0x202734] [0x27880d8b] [0x894f0020] [0xbd04] < eyal > [0xe8c3f475] [0xffffff94] [0x15ec0d8a] [0xc300020] [0xbd] [0x3f98000] [0x5c61175] [0x2015ec] [0x7805c704] [0x2027] [0xc30000c0] [0x2780058f] [0x5c70020] [0x202780] [0x2006c9] [0x8005c7c3] [0xdc002027] [0xe9002016] [0xfffffb26] [0x89fc768d] [0x1b806] < o4 > [0x2015ec] [0xb0027404] [0x703d8303] [0xa002027] [0x10340274] [0x5c70687] [0x202788] [0x2] [0x5f689eb] [0x2015ec] [0x8b3c750a] [0xe281d0] < ie, > [0xfa8108] < ia, > [0x5e0c1b7] [0x3d800234] [0x2015ec] [0x34027404] [0x703d830b] [0xa002027] [0x10340274] [0x278805c7] [0x10020] < eeks > [0x80ffffff] [0x2015ec3d] [0xc750900] [0xe2c1d08b] [0x5fac105] [0x274d03b] [0xe0c1c3ad] [0xeb063405] [0xfc768dc8] [0x38a10689] [0x2b002027] [0x20273c05] < mne/e > [0x8b5692c8] [0x20273835] < fl1rl > [0xfffffffc] [0x27443d8b] [0xadfd0020] [0x7549abfc] [0x89ab92f9] [0x2027443d] < v3ais > [0xffffc0e8] [0x3c3d8bff] [0x8b002027] [0x2027400d] < d-xn > [0x8b5602e7] [0x20273835] [0x2e6c100] [0xe95ea5f3] [0xfffffdfd] [0xffff98e8] [0xfdf3e9ff] [0x1b0ffff] [0x3b01eeb]

{block 6}
[0x4b01aeb] [0x9b016eb] [0xab012eb] [0xbb00eeb] [0xdb00aeb] [0xeb006eb] [0x7b002eb] [0x2015eca2] [0x8005c700] [0xb3002027] [0x8b002016] [0x15a88504] [0x78a30020] [0x58002027] [0xf9e4e9ad] [0x768dffff] [0x330689fc] [0x8805ffc0] [0xe9002027] [0xfffffe63] [0x15ec05c6] [0xb80c0020] [0xff00ff] [0x278005c7] [0x183e0020] [0xcaeb0020] [0x5c7ad58] [0x202780] [0x2006c9] [0x278405c7] [0x4920020] [0x5c60020] [0x20101d] [0x3005c700] [0x2027] < bs > [0x20101105] [0x20121f00] [0x7805c700] [0x2027] [0xe900ffff] [0xfffff97a] [0x2744158b] [0xfa810020] [0x94c00] [0x83c30175] [0x4a8b08ea] [0x880d8904] [0x8d002027] [0x689fc76] [0xea83028b] [0xf3754904] [0x8904c283] [0x20274415] < ,f/es > [0xffff] [0x200492] [0x2017c8] [0x201868] [0x2018a8] [0x2017fa] [0x2017fe] [0x201802] [0x201644] [0x2015ed] [0x2015fc] [0x201610] [0x2015f5] [0x201620] [0x201850] [0x20181a] [0x201618] [0x200492] [0x20180e] [0x20180a] [0x201806] [0x200492] [0x200492] [0x200492] [0x201631] [0x201812] [0x201816] [0x200492] [0x2017f0] [0x72515] [0x2d0d010b] [0x110160c] [0x2b0a0923] [0x23a3800] [0x220e1000] [0x24001305] [0x201c91] [0x8b42ebad] [0x2027280d] < tdnpe > [0xa3002027] [0x202728] [0xfc0ce8ad] [0x15ffffff] [0x20196c] [0x278405c7] [0x172a0020] [0x5c70020] [0x202730] [0x1] [0x101d05c6] [0xc7250020] [0x20101105] [0x20197000] < ndt9d > [0x40002027] [0xc7002019] [0x20276805] [0x20195000] [0x7805c700] [0x2027] [0xe800ffff] [0xfffff517] [0xe08514ff] [0xad002018] [0x895af1eb] [0x2015e815] [0x8cc28100] < mt > [0x20276815] [0x10ea8300] [0x276c1589] [0xece80020] [0x8bfffff4] [0x2015e815] [0x8dd00300] [0x3058254] [0xffadfc52] [0xe7ebd2] [0x0] [0x0] < ri > [0x1040f] [0x0] < sn > [0x20277435] [0x35806100] [0x201041] [0x7415ff2f] [0xc7002027] [0x201a1705] [0x0] [0x703d8300] [0x10002027] [0x5c70a75] [0x201a17] [0x150414] [0x276805c7] [0x1a130020] [0x5c70020] [0x20276c] [0x201a17] [0xffb5e8c3] [0x79ebffff] [0x2011b0] [0x2011b0] [0x201217] [0x201af5] [0x201a75] [0xfff0fee8] [0x1b05c7ff] [0x600201a] [0xe8000916] [0xffffff99] [0x115205c6] [0xa1000020] [0x202790] [0xfff4c9e8] [0xff0774ff] [0x187c8524] [0xc0850020] [0x233c337e] [0x90a12774] [0x3b002027] [0x20277005] [0xf6187900] [0x20115205] [0x274ff00] [0x168bd8f7] [0x7015af0f] [0x3002027] < .mnmol > [0x52053108] [0xf7002011] [0xb8ebad1e] [0x20106a] [0x20106a] [0x2010c4] [0x1a1b05c7] [0x4020020] [0x80e80215] < b??? > [0x20278805] [0x100] < idt9d > [0x1002027] < ml > [0x689fc76] [0x6c7] [0x5c60000] [0x20105d] [0x3d0e741c] [0x83] [0x24ff0779] [0x2018f885] [0x7ec08500] [0x303d1c] < raic > [0x89fc768d] [0xf01ce806] [0x35e8ffff] [0xfffffff5] [0x20277c05] [0xfe8ad00] [0xebfffff4] [0xfeb9e8c8] [0xa4e9ffff] [0xfffffff6] [0x20101125] [0x20121f00] [0x20121f00] [0x20121f00] [0x201b7b00] [0x201b7100] [0x1b05c700] [0x201a] < bs > [0x20276c05] [0x201a1700] [0x6805c700] [0x13002027] [0xe800201a] [0xfffff3c6] [0x24ff0774] [0x20198185] [0x75303c00] [0x1b05c70d] [0x200201a] [0xad021504] [0xc085e1eb] [0x5f7307e] [0x201a1b] [0xffffffff] [0x3d800d75] [0x202790] [0xa1880f0a] [0x3dfffffe] [0x30] [0x9e81079] [0xffffffff] [0x20278015]

{block 7}
< ,ofml > [0xe9ad0689] [0xfffff616] [0x275405c7] [0x1b950020] [0x81c30020] [0x81200ef] < statj > [0x1200c7] < tabpd > [0xff] [0x8108efc1] [0x5a0ff] < lntt- > [0x202734] [0x27283d89] [0x15ff0020] [0x20275c] [0xa0000bc] [0xfe8100] [0x720009f4] [0xf400be05] [0x5c70009] [0x2027cc] [0x2005e8] [0x27d005c7] [0x7020020] [0x5c70020] [0x2027d4] [0x2006a2] [0x27d805c7] [0x6b20020] [0x2fb80020] < k > [0xffffeeee] [0xfff591e9] [0xbc59ff] [0xff000a00] [0xfc768de1] [0xb80689] [0x2b000a00] [0xd1e8d1c4] [0xfeb0c3e8] [0xfeeb64e6] [0xe1c1c88b] [0x8b57ad08] [0xae7c1f8] [0xabf3c033] [0x83c3ad5f] [0x820f0cf8] [0xffffe89b] [0xc1f88b57] [0x8b560ae7] [0x20272835] [0xae6c100] [0x200b9] < a.t@d > [0x2728a35f] [0xc3ad0020] [0x281405c7] [0x2b50020] [0x768d0003] [0xa10689fc] [0x200446] [0x95e830ff] [0x8dffffef] [0x689fc76] [0xef8ae858] [0x768dffff] [0xa10689fc] [0x20044f] [0xffef7be8] [0xfc768dff] [0xc68b0689] [0xffef6fe9] [0x880dffff] [0x74002027] [0xf5ebad03] [0xf9afe8c3] [0xeae8ffff] [0xe8ffffff] [0xffffe80b] [0xe819850f] [0x48bffff] [0x4d28008d] < ;rt8d > [0xe8ffffff] [0xffffe7f3] [0x8d048b] [0xc3004d28] [0x89fc768d] [0xb806] [0xc00b0000] [0xc3] [0x1] [0x2010000] [0xff1b12] [0x3f4ba66] [0xd0e1e6ec] < et@wo8 > [0x8dc3c084] [0x201d7a15] [0x56028800] [0xe1e8f28b] [0x79ffffff] [0xe1e6ec05] [0xb4acf4eb] [0xe1e6ee1e] [0xfa75ccfe] [0xc35ee8e2] [0x1b108b0] [0xffffd2e8] [0xffbee8ff] [0xe6ecffff] [0xc3803ce1] [0xe5e80be6] [0x75ffffff] [0xb10fb0f9] [0xffb5e803] [0xd5e8ffff] [0x74ffffff] [0x5c7c3f9] [0x202744] [0x94c00] [0xba660cb0] [0xfb403f2] [0xfee1e6ee] [0xc3fa75cc] [0xebe81cb0] [0xb9ffffff] [0x47868c0] [0x7b0fee2] [0xc5eb02b1] [0xc48a05e6] [0xb805e6] [0xe600094c] [0xe6c48a04] [0x10e8c104] [0xbb081e6] [0xc7660fe6] [0x201d7b05] [0xb002a100] [0xe803b103] [0xffffff53] [0x7b05c766] [0x201d] [0x7805c600] [0x201d] [0xe809b1c3] [0xffffff3b] [0x1d7c05fe] [0x21e80020] [0x79ffffff] [0x16b0c3f9] [0xffff5fe8] [0xe8e6b0ff] [0xffffffdd] [0x4c00be56] [0xb90009] [0xf3000012] [0xbfc35ea5] [0x94c00] [0x1200b9] < frewu > [0xff36e81a] [0xc5b0ffff] [0x7ca2b7eb] [0x8d00201d] [0x689fc76] [0x3f2ba66] [0xa8e1e6ec] < ksaiar > [0xffffff4c] [0xf6c933c3] [0x201d7805] [0x1074ff00] [0x89fc768d] [0x47ffb806] < eak > [0xadffffff] [0xffdfe8c3] [0xbfe8ffff] [0x57ffffff] [0xc1047e8b] [0x7fe802e7] [0x5fffffff] [0x68140ad] [0x1200] [0xffbfe8c3] [0x9fe8ffff] [0x56ffffff] [0xc104768b] [0x7ce802e6] [0x5effffff] [0x768ddeeb] [0xe80689fc] [0xfffffed2] [0x1ab0c3ad] [0xfffeafe8] [0xb1d68bff] [0xfe75e806] [0x59e8ffff] [0x79fffffe] [0xb850c3f9] [0x47] [0xd9e8c933] [0x58fffffe] [0xffff59e8] [0x768b56ff] [0x2e6c104] [0xffffc9e8] [0xffb85eff] [0xe8000047] [0xfffffebc] [0x768dc3ad] [0xe80689fc] [0xffffe9d6] [0xffe549e8] [0xe575e8ff] [0x97e8ffff] [0xc6ffffff] [0x201d7805] [0x5c70100] [0x2027b8] [0x63] [0x27bc05c7] [0x60020] [0x5c70000] [0x202744] [0x94c00] [0x70358d56] [0xbf00202c] [0x4d0000] [0x27b80d8b] [0xa5f30020] [0x2dfc358d] [0xbf0020] [0x8b004d28] [0x2027b80d] < a.t@d > [0x27a405c7] [0x50000020] [0x5c7004d] [0x20275c] [0x200492] [0x275405c7] [0x20] [0x5c70000] [0x202748] [0x800] [0x12b8] < kelk > [0x2be9ffff] [0xfffff2]

{block 8}
[0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x89fc768d] [0x9d3b806] [0x8dc30008] [0x689fc76] [0x80a05b8] [0x768dc300] [0xb80689fc] [0x80a09] [0xfc768dc3] [0xf0b80689] [0xc3000809] [0x89fc768d] [0x9eab806] [0x8dc30008] [0x689fc76] [0x809cab8] [0x768dc300] [0xb80689fc] [0x809cd] [0xfc768dc3] [0x38b80689] [0xc3000806] [0x89fc768d] [0x9d7b806] [0x8dc30008] [0x689fc76] [0x809e2b8] [0x768dc300] [0xb80689fc] [0x809e4] [0xfc768dc3] [0x6bb80689] [0xc3000805] [0x89fc768d] [0x9e9b806] [0x8dc30008] [0x689fc76] [0x809d2b8] [0x768dc300] [0xb80689fc] [0x80a0b] [0xfc768dc3] [0x63b80689] [0xc3000800] [0x89fc768d] [0x9d1b806] [0x8dc30008] [0x689fc76] [0x25300b8] [0x768dc300] [0xb80689fc] [0x809ce] [0xfc768dc3] [0xcfb80689] [0xc3000809] [0x89fc768d] [0x7feb806] [0x8dc30008] [0x689fc76] [0x8053cb8] [0x768dc300] [0xb80689fc] [0x809ee] [0xfc768dc3] [0xefb80689] [0xc3000809] [0x89fc768d] [0x35ab806] [0x8dc30008] [0x689fc76] [0x8035db8] [0xc300]

{block 9}
[0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0xa] [0x64] [0x3e8] [0x2710] [0x186a0] [0xf4240] [0x989680] [0x5f5e100] < owoacs > [0x200ccd] [0x12] [0x288] [0x0] [0x0] [0x0] [0x0] [0x0] [0x94c00] [0x0] [0x50] [0x201222] [0x0] [0x201c17] [0x0] [0x33d] [0x28b] [0x200e53] [0x20100d] [0xa] [0x2011bd] [0xffff00] [0x1] [0x2006c9] [0x200492] [0x1] [0x0] [0x0] [0x2005b6] [0x6] [0x63] [0x100000] [0x100000] [0x0] [0x0] [0x0] [0x0] [0x63] [0x6] [0x200869] [0x2006d6] [0x20078a] [0x2005e8] [0x200702] [0x2006a2] [0x2006b2] [0x200752] [0x200770] [0x200492] [0x200492] [0x200492] [0x200653] [0x200492] [0x200492] [0x200492]

{block 10}
[0x200446] [0x200492] [0x200492] [0x200977] [0x200990] [0x30003] [0x3] [0x3f4] [0x0] [0x4b00] [0x1f00000] [0x1f00000] [0x0] [0xf7de] [0x0] [0x0] < ; dup ?dup drop then begin > [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x2007d3] [0x20059e] [0x200583] [0x20056d] [0x2007f7] [0x20080a]

{block 11}
[0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] < forths macros boot warm pause macro forth c stop read write nc format show serve load here ?lit 3, 2, 1, , less jump pci devic accept pad erase copy mark empt emit digit 2emit . h. h.n cr space down edit e lm rm graph switch freeze text top keybo debu at +at xy fov fifo box line color octant sp last unpac blk curs word ekt abort h buffe offset tic winver aper vesa trash hsvv tsim cpoint words qkey digin qwert no-ret r? nul cad pcad displ actc +list itick lis +e 'stk 'msg ?. > [0x0] [0x202116] [0x202121] [0x201caa] [0x201f5a] [0x200439] [0x2005c3] [0x2005e3] [0x2004e9] [0x201f0a] [0x201ed1] [0x201ef1] [0x202024] [0x201f2e] [0x200493] [0x2004cb] [0x200886] [0x200810] [0x20081b] [0x2007cc] [0x2007c5] [0x2007be] [0x2007a2] [0x200862] [0x200879] [0x2008fc] [0x200907] [0x201222] [0x2019e2] [0x201cb0] [0x201cc3] [0x2004ef] [0x200514] [0x200a0e] [0x200c5c] [0x200a4e] [0x200ccd] [0x200c88] [0x200c76] [0x2008d1] [0x200a43] [0x200ba9] [0x201973] [0x201985] [0x200bfa] [0x200c01] [0x200977] [0x200978] [0x2004b8] [0x200a89] [0x2008a8] [0x200d7a] [0x201cec] [0x200c08] [0x200c17] [0x20202f] [0x20203a] [0x200976] [0x200ac6] [0x200aa7] [0x2008f5] [0x200c28] [0x202045] [0x202050] [0x2012c3] [0x20205b] [0x202066] [0x2016ed] [0x202071] [0x200567] [0x2020a8] [0x2020df] [0x2020b3] [0x201d39] [0x201d68] [0x2020be] [0x2020c9] [0x2020d4] [0x202100] [0x202024] [0x20207c] [0x202087] [0x200f7e] [0x202092] [0x201c0c] [0x201c91] [0x201c99] [0x200492] [0x2020ea] [0x2020f5] [0x20210b] [0x20209d] [0x201530] [0x201d56] [0x201596] [0x20198a] [0x20212c] [0x202137] [0x200cc4]

{block 12}
[0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] < @irs > [0xfffffef7] [0x1f807fc] [0xf000f0] [0xf000f0] [0xf000f0] [0xf000f0] [0xf0] [0x0] [0x0] [0x80030000] [0xc003c003] [0xfc3fc003] [0xfc3ffc3f] [0xc003c003] [0xc003c003] [0xc003c003] [0xc003c003] [0xc003c003] [0xc003] [0x0] [0x0] [0x0] [0x0] [0xf81f0000] [0xfe7ffe7f] [0xff01ff8] [0xff00ff0] [0xff00ff0] < r?do, > [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0x0] [0x0] [0xf81f0000] [0xff7ffe7f] [0xff00ff0] < ?i@i, > [0xf0fcff] [0xf800f0] [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0x0] [0x0] [0xf81f0000] [0xfe7ffe7f] [0xf001f00] < ?y;is > [0xff8ff7f] [0x1ff00ff0] [0xff7fff7f] [0xf71f] [0x0] [0x0] [0x0] [0x0] < @irs > [0xfefffef7] [0xff81ffc] [0xff00ff0] [0xff00ff0] [0xff00ff0] [0xff00ff0] [0xff0] [0x0] [0x0] [0xc003c003] [0xc003] [0x0] [0xc003c003] [0xc003c003] [0xc003c003] [0xc003c003] [0xc003c003] [0xc003c003] [0xc003] [0x0] [0x0] [0x0] [0x0] [0xf81f0000] [0xfe7ffe7f] [0xf002f8] [0xfc7f00f0] [0xf00fe3f] [0x1f400f00] [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0x0] [0x0] < ou8 > [0xffff7efe] [0xcff3ffff] [0x7e087e1] [0x7e007e0] [0x7e007e0] [0x7e007e0] [0x7e0] [0x0] [0x0] [0x0] [0x0] [0xf81f0000] [0xfe7ffe7f] [0x1f00ff8] [0xf000f0] [0xf000f0] [0xff801f0] [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0x0] [0x0] [0xff00000] [0xff00ff0] [0xff00ff0] [0xff00ff0] < r?do, > [0xff7f3f7c] [0xef07ff1f] [0xf000f00] < ?o@i4 > [0xf83ffe7f] [0x8007000f] [0x80078007] [0x80078007] [0x80078007] [0x80078007] [0x80078007] [0x80078007] [0x80078007] [0xc007c007] [0xe003] [0x0] [0x0] [0x0] [0x0] < -m; > [0xff7ff77f] [0xff01ff8] [0xff00ff0] [0xff00ff0] [0xff7f1ff8] [0xff1fff7f] [0xf000f00] < ?o@i4 > [0xf81ffe7f] [0xfc03f801] [0x80078c07] [0xf03f8007] [0xf03ff03f] [0x80078007] [0x80078007] [0x80078007] [0x80078007] [0x80078007] [0x8007] [0x0] [0x0] [0x0] [0x0] [0x3c00000] [0x7e007e0] [0x8ff107e0] [0x8e718e71] [0xdc3bde7b] [0x781efc3f] [0x300c781e] [0x300c] [0x0] [0x0] [0xf000f00] [0xf000f00] < /m;is > [0xff7fff7f] [0xff01ff8] [0xff00ff0] [0xff00ff0] < r?do, > [0xff7fff7f] [0xef1f] [0x0] [0x0] [0x0] [0x0] [0x7e00000] [0xff007e0] < r-doys > [0x3c3c1c38] [0x781e381c] [0xf00f700e] [0xc003e007] [0x8001] [0x0] [0x0] [0x0] [0x0] < @ios > [0xfefffeff] [0xff01ff8] [0xff00ff0] [0xff00ff0] < r?do, > [0xfefffeff] [0xf0f8f7] [0xf000f0] [0xf000f0] [0xf000f0] [0xf000f0] [0xf8f700f0] [0xfefffeff] [0xff01ff8] [0xff00ff0] [0xff00ff0] < r?do, > [0xfeeffeff] [0xf8e7] [0x0] [0x0] [0xf000f0] [0xf000f0] [0xf8f700f0] [0xfefffeff] [0xff01ff8] [0xff00ff0] [0xff00ff0] [0xff00ff0] [0xff00ff0] [0xff0] [0x0] [0x0] [0x0] [0x0] [0xff00000] [0x3e7c1ff8]

{block 13}
[0xf81f7c3e] [0xe007f00f] [0xf00fe007] [0x7c3ef81f] [0x1ff83e7c] [0xff0] [0x0] [0x0] [0x0] [0x0] [0xff00000] [0xff00ff0] [0xff00ff0] [0xff00ff0] [0xff00ff0] < r?do, > [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0x0] [0x0] < -m; > [0xff7ff77f] [0xff01ff8] [0xff00ff0] [0xff00ff0] < r?do, > [0xff7fff7f] [0xf00ef1f] [0xf000f00] [0xe000f00] [0xfe7ff81f] [0x1ff8fe7f] [0xff00ff0] [0xff00ff0] [0xff00ff0] [0xff00ff0] [0xff00ff0] < r?do, > [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0xe003e001] [0xe00fe007] [0xe00de00f] [0xe001e009] [0xe001e001] [0xe001e001] [0xe001e001] [0xe001e001] [0xe001e001] [0xe001] [0x0] [0x0] [0xfe7ff81f] [0x1ff0fe7f] [0xf000f00] [0x1f000f00] [0xfe7ffe1f] [0xf8f87f] [0xf000f0] [0xf000f0] [0xffffffff] [0xffff] [0x0] [0x0] [0xfe7ff81f] [0x1ff0fe7f] [0xf000f00] [0x1f000f00] [0xfc07fe07] [0x1f00fe07] [0xf000f00] [0x1ff00f00] [0xfe7ffe7f] [0xf81f] [0x0] [0x0] < ;is;is ;is;is ;is;is ;is;is > [0xffffffff] [0xf000ffff] [0xf000f000] [0xf000f000] [0xf000f000] [0xf000] [0x0] [0x0] [0xffffffff] [0xf0ffff] [0xf000f0] [0xf000f0] [0xfefff8ff] [0x1f00feff] [0xf000f00] [0x1ff00f00] [0xfe7ffeff] [0xf81f] [0x0] [0x0] [0xfe7ff81f] [0xff8ff7f] [0xf000f0] [0xf000f0] [0xfefff8f7] [0x1ff8ffff] [0xff00ff0] < r?do, > [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0xffffffff] [0x700ffff] [0x1f000f00] [0x7c003e00] [0xf001f800] [0xc007e003] [0x1f800f] [0x7c003e] [0xf000f8] [0xe0] [0x0] [0x0] [0xfe7ff81f] [0x1ff8fe7f] [0xff00ff0] < r?do, > [0xfc3ffe7f] [0x1ff8fe7f] [0xff00ff0] < r?do, > [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0xfe7ff81f] [0x1ff8fe7f] [0xff00ff0] < r?do, > [0xff7fffff] [0xf00ef1f] [0xf000f00] [0x1ff00f00] [0xfe7ffeff] [0xf81f] [0x0] [0x0] [0x78007800] [0x7800] [0x0] [0x78007800] [0x78007800] [0x78007800] [0x78007800] [0x78007800] [0x78007800] [0x78007800] [0xf03ff83c] [0xc00ff01f] [0x0] [0x0] [0x0] [0x0] [0xfc3ffc1f] [0xf83f] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0xf000f0] [0xf000f0] [0x3cf000f0] < ,iy,is > [0x80ffe0ff] [0xff00ff] [0xf0ffc0ff] [0xfff1fcf3] < r?si?s > [0x7f0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x70000] [0xc01f800f] [0xc01fc01f] [0x7800f] [0x0] [0x0] [0x0] [0x0] [0x0] [0xffffffff] [0x1f00ffff] [0xfe003f00] [0xe00ff803] [0xfe803f] [0xffffffff] [0xffff] [0x0] [0x0] [0x1f000f00] [0x3e001f00] [0x7c007c00] [0xf001f800] [0xe003f001] [0xc007c007] [0x1f800f] [0x3e001f] [0xfc007c] [0xf8] [0x0] [0x0] [0x0] [0x70000] [0xc01f800f] [0xc01fc01f] [0x7800f] [0x0] [0x70000] [0xc01f800f] [0xc01fc01f] [0xc007c00f] [0x78003] [0x1c000e] [0xf000f000] [0xe001e001] [0xc001c001] [0x80038003] [0x30003] [0x20002] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x80018001] [0xc003c003] [0xe007c003] [0xe007e007] [0xc003e007] [0x8001c003] [0x0] [0xc0038001]

{block 14}
[0xe007e007] [0x8001c003] [0x0] [0x0] [0x0] [0x0] [0xc003c003] [0xc003c003] [0xfc3ffc3f] [0xc003fc3f] [0xc003c003] [0xc003] [0x0] [0x0] [0x0] [0x0] [0xfe7ff81f] [0xff0fe7f] [0x7e007e0] [0xc7e387e1] [0xc7e3c7e3] [0xfee3fee3] [0xe0f8e1] [0xff000e0] [0xfe7ffe7f] [0xf81f] [0x0] [0x0] [0x0] [0x0] [0x381c1008] [0xf81f7c3e] [0xe007f00f] [0xf81ff00f] [0x381c7c3e] [0x1008] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x70000] [0xc01f800f] [0xc01fc01f] [0xc007c00f] [0x78003] [0x1c000e] [0xfe7ff81f] [0xff0fe7f] [0x70007f0] [0x3e000f00] [0xe003f800] [0xc003c003] [0x0] [0xc0038001] [0xe007e007] [0x8001c003] [0x0] [0x0] [0xfcfff0ff] [0xfe7ffeff] [0xff1fff3f] [0xff07ff0f] [0xff01ff03] [0xff00ff00] [0xff00ff00] [0xff03ff01] [0xff0fff07] [0xff3fff1f] [0xfefffe7f] [0xf0fffcff] [0x0] [0x6e0000] [0x71007f] [0x600060] [0x600060] [0x60] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x180000] [0x7e0018] [0x18007e] [0x180018] [0x180018] [0x1c] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x3e0000] [0x63007f] [0x630063] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x3e0000] [0x63007f] [0x7e007f] [0x7f0060] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x1e0000] [0x3003f] [0x7f003f] [0x7f0063] [0x803b] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x6e0000] [0x73007f] [0x630063] [0x630063] [0x63] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x180018] [0x0] [0x180038] [0x180018] [0x180018] [0x1c] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x3e0000] [0x60007f] [0x3f007e] [0x7f0003] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x630000] [0x7f0077] [0x63006b] [0x630063] [0x63] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x3e0000] [0x61007f] [0x600060] [0x7f0061] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x630000] [0x630063] [0x7f0063] [0x3003f] [0x7f0043] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x380000] [0x180018] [0x180018] [0x180018] [0x180018] [0x1c] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x3b0000] [0x63007f] [0x7f0063] [0x3003f] [0x7f0043] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x1a000e] [0x7e0018] [0x18007e] [0x180018] [0x180018] [0x18] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] < srb > [0x630063] [0x7f006b] [0x77007f] [0x63]

{block 15}
[0x30003] [0x3b0003] [0x63007f] [0x630063] [0x7f0063] [0x3b] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x630000] [0x630063] [0x770063] [0x1c003e] [0x8] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x6e0000] [0x63007f] [0x630063] [0x7f0063] [0x60006e] [0x600060] [0x0] [0x0] [0x0] [0x0] [0x0] [0x600060] [0x6e0060] [0x63007f] [0x630063] [0x7f0063] [0x6e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x600060] [0x6e0060] [0x73007f] [0x630063] [0x630063] [0x63] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x630000] [0x360077] [0x1c001c] [0x770036] [0x63] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x630000] [0x630063] [0x630063] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x3b0000] [0x63007f] [0x630063] [0x7f0063] [0x3003b] [0x30003] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f003e] [0x630063] [0x630063] [0x630063] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x1c000c] [0xc003c] [0xc000c] [0xc000c] [0x3f000c] [0x3f] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f003e] [0x30063] [0xe0007] [0x38001c] [0x7f0070] [0x7f] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f003e] [0x30063] [0xf000f] [0x630003] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x660006] [0x660066] [0x7f0066] [0x6007f] [0x60006] [0x6] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f007f] [0x600060] [0x7f007e] [0x30003] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f003e] [0x600063] [0x7f007e] [0x630063] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f007f] [0x30003] [0xe0007] [0x18001c] [0x180018] [0x18] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f003e] [0x630063] [0x7f007f] [0x630063] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f003e] [0x630063] [0x3f007f] [0x30003] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x60006] [0x0] [0x6000e] [0x60006] [0x60006] [0x660006] [0x3c007e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x3e001f] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x600060] [0x660060] [0x7c006e] [0x780078] [0x6e007c] [0x67] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x180000]

{block 16}
[0x3c003c] [0x18] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f007f] [0x1c000e] [0x7f0038] [0x7f] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x70003] [0xe0006] [0x1c000c] [0x380018] [0x700030] [0x60] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x3c0018] [0x18003c] [0x180000] [0x3c003c] [0x300018] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0xe000f] [0x18001c] [0x30] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x180018] [0x3c003c] [0x18003c] [0x18] [0x180000] [0x18] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x180018] [0x7e007e] [0x180018] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f003e] [0x630063] [0x6f006b] [0x60006e] [0x7f0063] [0x3e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7e0066] [0x3c003c] [0x66007e] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x180000] [0x3c003c] [0x300018] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f003e] [0x70063] [0x1c000e] [0x18] [0x180000] [0x18] [0x0] [0x0] [0x0] [0x0] [0x0] [0x0] [0x7f007e] [0x1f003f] [0xf000f] [0x1f000f] [0x7f003f] [0x7e]

{block 17}


{block 18}
:var ns [0x250] :var nblk [0x5a0] :var nc [0x11] ( 144a12 02a 42c/22a) | , ( copyright) # 2009 ( greenarrays,inc) | , 20 load 22 load 24 load ( colors) 28 load ]
: abuf [ 10000 ] ; | *
: cbuf [ 29000 ] ; | , ( decompress) mark 30 load restore empt ]
: env [ 34 ] winver 2* + ; env ( ironment) load | , 44 2 loads 62 5 loads 88 load 84 load | , | ,
: floppy [ 52 ] ; | * | .
: dump [ 48 ] load ; | *
: flush save ;
: icons | . [ 54 ] ; | *
: audit [ 90 ] ; | *
: index [ 76 ] ; | *
: html [ 176 ] ; | , | , mark empty ( arrayforth) 144 load qwerty seeb | , ( application tools) 202 2 loads mark empty | , | , exit ( or compile any following...)
: q # 706 [ 660 ] load ; mark empty

{block 19}
( x86 colorforth and arrayforth tm)
: ns ( number of sectors compressed if neg,) | cr
( last compressed if pos.)
: nblk ( number of uncompressed blocks.)
: nc ( no. of compressed cylinders, deprecated) | cr
[ these vars must be first things in block! | br


: abuf ( starting block of) # 3 ( mb audit buffer)
: cbuf ( starting block of) # 3 ( mb compression buffer)
: floppy ( utilities for floppy format and ops.)
: dump ( compile memory display background task)
: flush ( eases concurrent use of pf/ef.)
: icons ( compile icon editor)
: audit ( utility for reconciliation and merging)
: index ( file listing first lines of blocks)
: html ( colorforth source to 2-up html file) | , | , ( saying) [ qwerty ] enables ( the qwerty keyboard mode till next boot.) | cr
[ seeb ( toggles blue word display) ] on.

{block 20}
( macros) macro ]
: swap $168b 2, $c28b0689 , ;
: 0 [compile] ?dup $c031 2, ; | -cr : if $74 2, here ;
: -if $79 2, here ; | -cr : while ( n-nn) [compile] if swap ;
: -while ( n-nn) [compile] -if swap ; | -cr : a [compile] ?dup $c28b 2, ;
: a! ?lit if $ba 1, , ; ] then $d08b 2, [compile] drop ;
: 2* $e0d1 2, ; | *
: 4@ ( b-n) $8b 2, ; forth ]
: a, 2* 2* , ; macro ]
: @ ?lit if [compile] ?dup $58b 2, a, ; ] then $85048b 3, $ 0 , ;
: ! ?lit if ?lit if $5c7 2, swap a, , ; ] then $589 2, a, [compile] drop ; ] then [compile] a! $950489 3, $ 0 , [compile] drop ;
: nip $4768d 3, ;
: + ?lit if $5 1, , ; ] then $603 2, [compile] nip ;
: or $633
: binary ?lit if swap 2 + 1, , ; ] then 2, [compile] nip ;
: and $623 [compile] binary ; | -cr : +or $60b [compile] binary ;
: u+ ?lit if $681 2, , ; ] then $44601 3, [compile] drop ;
: ? ?lit $a9 1, , ; | -cr : over [compile] ?dup $4468b 3, ;

{block 21}
( pentium macros' 1, 2, 3, , compile 1-4 bytes)
: drop ( lodsd, flags unchanged, why sp is in esi - in kernel)
: then ( fix address - in kernel)
: swap ( sp xchg)
: 0 ( 0 0 xor, macro 0 identical to number 0)
: if ( jz, flags set, max 127 bytes, leave address)
: -if ( jns, same)
: a ( 2 0 mov, never used?)
: a! ( 0 2 mov, unoptimized)
: 2* ( shift left)
: 4@ ( fetch word on byte boundary.)
: a, ( compile word address)
: @/! ( fetch/store from/to word address, or eax)
: nip swap drop
: +/or/and ( number or sp with eax)
: u+ ( add to 2nd number, number or sp)
: ? ( test bits, set flags, literal only!)
: over ( sp 4 + @)

{block 22}
( - macros)
: push ?lit if $68 1, , ; ] then $50 1, [compile] drop ;
: pop [compile] ?dup $58 1, ;
: - $d0f7 2, ;
: *end swap
: end $eb
: loop 1, here - + 1, ;
: until $74 [compile] loop ;
: -until $79 [compile] loop ;
: for [compile] push [compile] begin ;
: *next swap
: next $75240cff
: 0next , here - + 1, $4c483 3, ;
: -next $79240cff [compile] 0next ;
: i [compile] ?dup $24048b 3, ;
: +! ?lit if ?lit if $581 2, swap a, , ; ] then $501 2, a, [compile] drop ; ] then [compile] a! $950401 3, $ 0 , [compile] drop ;
: nop $90 1, ;
: align here - 3 and drop if [compile] nop [compile] align ; ] then ;
: or! [compile] a! $950409 3, $ 0 , [compile] drop ;
: * $6af0f 3, [compile] nip ;
: */ $c88b 2, [compile] drop $f9f72ef7 , [compile] nip ;
: /mod [compile] swap $99 1, $16893ef7 , ;
: / [compile] /mod [compile] nip ;
: mod [compile] /mod [compile] drop ;

{block 23}

: push ( lit to sp; eax to sp)
: pop ( sp to eax)
: - ( ones-complement)
: begin -a ( current code address - byte)
: while a-aa ( if-escape from any structure usage example begin xxx while xxx next xxx then)
: for n ( push count onto return stack,) begin
: *next aa-aa ( swap) for ( and) if ( addresses)
: next a ( decrement count, jnz to) for, ( pop return stack when done)
: -next a ( same, jns - loop includes 0)
: i -n ( copy loop index to data stack)
: *end aa-aa ( swap) end ( and) if ( addresses)
: end a ( jmp to) begin
: +! na ( add to memory, 2 literals optimized)
: align ( next call to end on word boundary)
: or! na ( inclusive-or to memory, unoptimized)
: * mm-p ( 32-bit product)
: */ mnd-q ( 64-bit product, then quotient)
: /mod nd-rq ( remainder and quotient)
: / nd-q ( quotient)
: mod nd-r ( remainder)

{block 24}
( - compiled macros)
: 2/ ( n-n) $f8d1 2, ; | *
: time ( -n) [compile] ?dup $310f 2, ;
: 7push $57 1, ; | *
: 7pop $5f 1, ; forth ]
: @ @ ; | *
: ! ! ; | *
: + + ; | *
: - - ; | *
: */ */ ; | *
: * * ; | *
: / / ;
: /mod /mod ; | *
: 2/ 2/ ;
: dup dup ; | *
: drop drop ; | *
: nip ( ab-b) nip ;
: over over ; | *
: swap swap ; | *
: and and ;
: or or ; | *
: +or +or ; | *
: +! +! ;
: exit 7pop 7pop ; | *
: negate ( n-n) - 1 + ;
: min ( nn-n) less if drop ; ] then swap drop ;
: abs ( n-u) dup negate
: max ( nn-n) less if swap then drop ;
: v+ ( vv-v) push u+ pop + ;
: loads ( bn) for dup push load pop 2 + next drop ;
: writes ( acn) for write next drop drop ;
: thru ( fl) over negate + 2/ 1 + loads ;
: reads ( acn) for read next drop drop ; macro ]
: dann [compile] then ;
: then ( a-a) here over negate + 128 + | , | .. -256 and drop if abort dann [compile] dann ; forth

{block 25}

: 2/ ( arithmetic right shift)
: time ( pentium cycle counter, calibrate to actual clock rate)
: 7push/7pop ( save/restore save register 7, edi)
: @-drop ( these macros redefined in) forth ( so they may be executed)
: +or ( and) negate ( when you just can't use -)
: min ( and) max ( minimum and maximum)
: abs ( absolute value)
: v+ ( add 2-vectors)
: exit ( terminates interpretation of a block.)
: loads ( load successive blocks)
: thru ( loads first thru last block inclusive)
: nc ( number of cylinders booted and saved)
: writes ( address, cylinder, cylinder count)
: reads ( address, cylinder, count.) [ floppy access note do not hit any keys while floppy is being written - wait for light to go out ]
: then ( aborts on jump out of range.)

{block 26}


{block 27}


{block 28}
( colors etc)
: -offset ( n-n) [ offset ] @ negate + ;
: block [ offset ] @ +
: blks $100 * ;
: wrtboot [ 0 block ] 0 1 writes stop ;
: white $ffffff color ;
: red $ff0000 color ;
: green $ff00 color ;
: blue $ff color ;
: silver $bfbfbf color ;
: black 0 color ;
: 5* 5 for 2emit next ;
: cf 25 dup at red $b $5 $1 $1 $5 5* green $14 $2 $1 $3 $e 5* ( chip) 25 550 at red $1c $1c $19 $5 $d 5* ;
: fill ( nan) for over over ! 1 + next drop drop ;
: move ( sdn) for over @ over ! 1 + 1 u+ next drop drop ;
: erase ( bn) push 0 swap block pop blks fill ;
: copy ( n) [ blk ] @ block over block 512 move [ blk ] ! ;

{block 29}

: block n-a ( block number to word address)
: wrtboot ( write boot and kernel)
: colors ( specified as rgb' 888 bits)
: at xy ( set current screen position - in kernel)
: box xy ( lower-right of colored rectangle - in kernel)
: 5* emit ( five characters in reverse order)
: cf ( display double-size colorforth)
: fill n an ( writes n into a cell string)
: move sdn ( copies a cell string from s to d)
: erase bn ( zeroes a string of blocks)
: copy n ( copies current editor block and its shadow to the given block)

{block 30}
( decompress) empt 32 load ]
: char ( -n) $ 0 b! ( ?new) 4 bits b 8 and drop if b 4 and drop if 3 bits 7 ; ] then 1 bits 5 ; ] then 4 b $f and drop if ; ] then
: eob ( n) drop pop drop ;
: chars ( n-n) char ?full c! 2*c b or chars ;
: word ( n) 28 [ nb ] ! dup chars tbits ;
: short ( n) 28 bits
: t, -4 [ nb ] ! b tbits ;
: number ( n) $ 0 b! 1 bits t,
: 32bits 16 bits 16 bits b , ;
: variable ( n) word 32bits ;
: tag ( -n) b $f and dup jump eob word number word word number short word short word word word variable short word short
: words ( ?new) 4 bits tag words ;
: range ( ann) over block [ h ] ! dup push erase [ aa ] ! $ 0 [ na ] ! begin words [ h ] @ 256 + -256 and [ h ] ! next ;
: restore [ ns ] @ dup and -if abs [ ns ] ! 36 block [ cbuf ] block [ 18 blks nc @ -2 + * ] move [ cbuf block ] 36 [ nblk @ -36 + ] range ; ] then drop ;

{block 31}

: char ( examine high bits; shift 4, 5 or 7 bits)
: eob ( end of block)
: chars ( shift characters until 0)
: word ( shift characters, then tag)
: short ( 28-bit value+tag)
: number ( 1-bit base+tag, value in next word)
: 32bits ( for values)
: variable ( word, value)
: tag ( vector)
: words ( examine tags)
: range ( process each block)
: move ( blocks 72 thru 1419 to 3000)
: res ( restore compressed blocks)

{block 32}
( - more) macro ( uses ebx)
: b [compile] ?dup $c38b 2, ;
: b! $d88b 2, [compile] drop ;
: c! $c88b 2, [compile] drop ;
: 2*d $c3a50f 3, ;
: 2*c $e0d3 2, ; forth :var na [0xe] :var nb [0x9] :var h [0x4062000] :var an :var aa [0x472cbd3] :var nz [0x4]
: ?new [ na ] @ dup and drop if ; ] then
: new [ aa ] @ @ [ an ] ! 1 [ aa ] +! 32 [ na ] ! ;
: shift ( n-n) dup negate dup [ nb ] +! [ na ] +! c! [ an ] @ 2*d 2*c [ an ] ! ;
: bits ( n) ?new dup negate [ na ] @ + -if dup push + shift new pop negate shift ; ] then drop shift ;
: tbits ( nn) [ nb ] @ 8 + c! 2*c or
: , [ h ] @ ! 1 [ h ] +! ;
: tz ( nn-n) over [ nz ] ! dup negate push + b begin dup 1 and drop if drop drop pop drop [ nz ] @ ; ] then 2/ next b! dup [ nz ] @ - + - [ nb ] +! pop drop ;
: ?full ( n-n) [ nb ] @ dup and -if tz dup push -4 + [ nb ] +! tbits $ 0 dup pop dup - 29 + [ nb ] ! ; ] then drop ;

{block 33}

: b ( pop ebx, register 3, into eax)
: c! ( push eax into register 1, ecx)
: 2*d ( shift ebx left by ecx. bits from eax)
: 2*c ( shift eax left by ecx)
: na ( bits remaining in source word)
: nb ( bits remaining in ebx)
: h ( destination address)
: , ( store at destination)
: ?new ( fetch new word if necessary)
: new ( 32-bits in current word)
: shift ( eax into ebx, decrement) nb
: tbits ( fill ebx with tag)
: ?full ( is there room in ebx?)
: bits ( shift bits into ebx. overflow into next word)

{block 34}
( native system dependencies) macro ]
: p@ [compile] a! [compile] ?dup $ec 1, ; forth ]
: key? $64 p@ 1 and drop if $60 p@ $80 and drop if ; ] then pop drop then ;
: clock [ 40 ] load ;
: altfrm ( -b) [ aper @ 1024 768 * -4 * + ] ;
: topram ( -b) [ $30000000 ] ;
: !work ( n) block 0 over [ 1 ] + @ [ 35 ] + [ 36 ] / writes stop ;
: @rest ( nn) push [ 36 ] + block [ 2 ] pop reads stop ;
: @back ( n) dup block 0 [ 2 ] reads dup [ 18 ] + block dup @ [ 18 block @ ] or drop if drop [ 78 ] @rest ; ] then dup [ 1 ] + @ dup and -if nip abs [ 35 ] + [ 36 ] / [ -2 ] + @rest ; ] then drop drop [ 78 ] @rest ;
: !back ( n) block 0 [ nblk ] @ [ 18 ] / writes stop ;
: @cyls ( acn) reads stop ;
: screen 0 dup at 1024 768 box ;
: utime ( -n) 0 ; | br


: serial ( -n) [ 108 ] ;

{block 35}

: key? ( exits calling defn if key struck)
: clock ( loads time of day suppt)
: altfrm ( byte addr of alternate frame buffer)
: topram ( end ram avail for applications.)
: @back and !back ( read/wrt full disk to/from adr) [ @back reads only active part of compressed ]
: @cyls ( equiv to reads)
: screen ( fills screen with current color)
: utime ( null definition for now for compatability)

{block 36}
( windows system dependencies)
: key? [ keych ] @ 0 or drop if pop drop ; ] then ;
: beep ; | *
: clock 38 load ;
: topram | *
: altfrm ( -b) [ endram -4096 768 * + ] ;
: !work ( n) dup block [ 1 ] + @ [ 1 ] + 2/ wwork ;
: @back ( n) dup 19 rback dup [ 18 ] + block dup @ | , [ 18 block @ ] or drop if drop [ 1440 ] rback ; ] then | , dup [ 1 ] + @ dup and -if nip abs [ 1 ] + 2/ rback ; | , ] then drop [ 3 ] + @ rback ;
: !back ( n) [ nblk ] @ wback ;
: @cyls ( acn) [ abuf ] @back push [ 18 ] * [ abuf ] + block | , swap pop [ 18 256 * ] * move ;
: screen 0 dup at 868 for 0 1024 line next | , 0 dup at ; | *
: serial ( -n) [ 112 ] ;
: fopen ( af-h) push push 0 32 ( exist) 3 0 # 0 [ 3 | , ] pop pop swap [ 4 ] * fcreate ; | , :var flng [0x65d] flng 4 * dup ]
: frd ( anh-n) push push push [ 0 + ] pop pop swap | , pop fread | *
: frw? ( ok-n) if drop [ flng ] @ then ;
: fwr ( anh-n) push push push [ 0 + ] pop pop swap | , pop fwrite frw? ; | *
: r/o [ $80000000 ] ;
: w/o [ $40000000 ] ; | * | ...
: r/w [ r/o w/o + ] ;

{block 37}

: key? ( exits calling defn if key struck)
: save ( writes full disk image)
: beep ( alert in hardsim)
: clock ( loads time of day suppt)
: altfrm ( byte adr of alt frame buffer)
: topram ( end ram avail for applications.)
: @back and !back ( read/wrt full disk to/from adr) [ @back reads only active part of compressed, and only active part of straight disks with vars ]
: @cyls ( equiv to reads)
: screen ( fills screen with current color) | br


: fopen ( opens an existing win32 file given word adr of name and access code of) r/o w/o ( or) r/w. ( returns handle, indicators nz if it's good. the alternate value) # 3 ( enables sharing for read and write; necessary to open a file sf has open with clib.)
: frd ( and) fwr ( read and write on things with win32 handles.)

{block 38}
( - clock)
: sec ( -n) utime [ 60 60 * 24 * ] mod ;
: minute ( -n) sec 60 / ;

{block 39}

: utime ( returns unix time in sec since epoch 0000z fri 1/01/1970)
: sec ( seconds since midnight needs unsigned mod by time we are all dead)
: min ( minutes past midnight)

{block 40}
( native clock) macro ( pentium timer)
: p@ [compile] a! [compile] ?dup $ec 1, ;
: p! [compile] a! $ee 1, [compile] drop ; forth ]
: ms 100000 * for next ;
: ca $70 p! $71 ;
: c@ ca p@ ;
: c! ca p! ;
: !bcd push 10 /mod 16 * + pop c! ;
: !hm 100 /mod 4 !bcd 2 !bcd $ 0 dup c! ;
: bcd c@ 16 /mod 10 * + ;
: sec0 4 bcd 60 * 2 bcd + 60 * 0 bcd + ;
: sec sec0 2 ms dup sec0 or drop if drop sec ; ] then ;
: minute sec 60 / ;
: hms sec 60 /mod 60 /mod 100 * + 100 * + ;
: ymd 9 bcd 100 * 8 bcd + 100 * 7 bcd + ;
: day 6 c@ -1 + ;
: hi 10 c@ $80 and drop if ; ] then hi ;
: lo 10 c@ $80 and drop if lo ; ] then ;
: cal hi lo time - hi lo time + ( 748) ;
: beep $b6 $43 p! $ee $42 p! $ 0 $42 p! ( on) $61 p@ 3 or $61 p! 50000000 for next ( off) $61 p@ 3 or $61 p! ;

{block 41}


{block 42}


{block 43}


{block 44}
( logo and watermark)
: logo show black screen 800 710 blue box 600 50 at 1024 620 red box 200 100 at 700 500 green box # 18 ( list) text cf keyboard ; logo | , | ,
: -safe ( a-f) negate here + $80000000 and drop ;
: ?logo sp 17 + @ -safe if logo ; ] then ;
: empty empt ?logo ; | , | ,
: 2u.r ( nw) -1 + dup push for 10 /mod next $f and | , begin [ 0 ] + if pop [ 1 ] + | *
: .lo for [ 24 ] + 2emit next ; ] then drop space space next [ 1 ] .lo ;
: ?ec blk 2 + @ 0 + drop if red ; ] then silver ;
: watermark show black screen 765 603 at | , [ blk ] @ ?ec 6 2u.r +list keyboard ; | , | ,
: +buf ( n-n) [ blk ] @ over or if | , | ... over or [ blk 1 + ] ! ; ] then drop ; | , | ,
: edit ( n) +buf [ blk ] ! | *
: e watermark +e ;
: list ( n) +buf [ blk ] ! lis ; | *
: l [ blk ] @ list ;

{block 45}
( logo and editor display extensions.) | , ( empty smart for less display wanking) | , | ,
: logo ( displays colorforth logo)
: -safe ( returns true flag if addr is past) [ here.
: ?logo ( displays logo screen if current display) | , ( generator has been forgotten.)
: empty ( switches to) logo ( display only if current display has been forgotten.) | , | , editor display ( is extended to show block no.) | , ( being edited above the keyboard hints, colored red if the editor is 'hot'.)
: +buf ( preserves) blk ( if new block is different)
: list ( displays the given block without entering the editor.)
: l ( lists the current editor block.)

{block 46}
( miscellaneous)
: !dict ( fmh) [ h ] ! [ macros ] ! [ forths ] ! ;
: interp ( b) align load ; ( temp) 9 here 4 / -1 + +! ]
: finish [ cad ] @ interp ; | , | ,
: -kbd ( -t) 7push pop dup and drop ;
: fh ( n-b) -kbd if 7push pop [ 0 block | , negate ] + 256 / + ; ] then [ blk ] @ + ;
: paws pause ; | *
: pause dup paws drop ;

{block 47}

: !dict ( resets dictionary to a saved state)
: interp ( is a temp patch for missing interpreter entry point.)
: finish ( executes at same stack level as load but starts interpreting at editor's current cursor position.) | , | ,
: -kbd ( returns true/nonzero flag if a word that calls it is being interpreted from a block as opposed to from the keyboard. use with caution from deep within an app that might have monkeyed with register) # 7
: fh ( from here, block number relative to editor or interpreter block as appropriate.)
: pause ( is redefined to push an extra item onto stack while displaying for symmetry with kbd.)

{block 48}
( dump) empty :var x [0x483e000] :var y [0xfb40dca0]
: 5-8 8 /mod 32 /mod 32 /mod $100 * + $100 * + $100 * swap 4 * + ;
: one dup @ dup 5-8 h. space h. space dup h. cr ;
: lines for one -1 + next drop ;
: dump [ x ] !
: r show black screen [ x ] @ 15 + 16 text lines keyboard ;
: it @ + @ dup h. space ;
: lines for white i [ x ] it i [ y ] it or drop if red then i . cr -next ;
: cmp show blue screen text 19 lines red [ x ] @ h. space [ y ] @ h. keyboard ;
: u 16
: +xy dup [ x ] +! [ y ] +! ;
: d -16 +xy ;
: ati $f4100000 ( ff7fc000) or ( agp graphics reg)
: byte 4 / dump ;
: fix for 0 over ! 1 + next ; dump

{block 49}
( does not say empty, compiles on top of application)
: x -a ( current address)
: one a-a ( line of display)
: lines an
: dump a ( background task continually displays memory --- takes address -- displays three cols with address on right contents in middle and- the left col is f18 instruction view)
: u ( increment address)
: d ( decrement)
: ati ( address of agp graphic registers)
: byte a ( byte address dump)
: fix an-a ( test word)

{block 50}
( timing) :var tmt [0x1115a1a8] :var tmn [0xf652bbb4] :var tmp [0x3d44e16] :var secs
: tmclr 0 [ tmt ] ! 0 [ tmn ] ! 0 [ tmp ] ! 0 [ secs ] ! ;
: tms ( a) time - [ 1 ] + swap +! ;
: tme ( a) time swap +! ;
: tare [ tmt ] tms pause [ tmt ] tme ;
: 0tare [ tmn ] tms switch [ tmn ] tme ;
: counter utime negate [ secs ] +! ;
: timer utime [ secs ] +! ;

{block 51}


{block 52}
( floppy utility) empty :var hd [0x1] :var ad [0x25312]
: array pop 2/ 2/ ;
: com align array [ $1202004d , $6c 2, ]
: word ( n) [ ad ] @ ! 1 [ ad ] +! ;
: sectors ( cs-c) buffer [ ad ] ! 18 for over [ hd ] @ $100 * + over 18 mod 1 + $10000 * + $2000000 + word 1 + next drop ;
: head ( ch-c) dup [ hd ] ! $400 * $1202004d + [ com ] ! dup 2* - 1801 + sectors format ;
: cylinders ( n) push [ com ] 0 pop for 0 head 1 head 1 + next ( stop) drop drop ;
: format ( nc @) 80 cylinders stop ;
: archive [ 0 block ] 0 [ nc ] @ writes stop ;
: check [ abuf block ] 0 [ nc ] @ reads stop ;
: ati $10cd4123 [ vesa ] ! ; ( setup for ati video card)
: nvidia $10cd4118 [ vesa ] ! ; ( for nvidia card then save)

{block 53}

: format ( issue format command 30 cyl - in kernel)
: hd ( disk head)
: ad ( current address in) buffer
: buffer ( usual floppy cylinder buffer)
: array ( return word address)
: com ( format command)
: word ( store word into command string)
: sectors ( build sector table)
: head ( build sectors for selected head)
: cylinders ( sectors advance 1 for each cylinder - to allow time for head step)
: format ( only desired cylinders to save time)
: bytes ( arguments for crc)
: archive ( verify save' compute crc, save, read-back, recompute crc - first 64 bytes used by floppy read/write -- the two crc numbers should be the same !)

{block 54}
( icons) empty macro ]
: @w $8b66 3, ;
: !w [compile] a! $28966 3, [compile] drop ;
: *byte $c486 2, ; forth :var ic [0xb] :var cu [0xa7]
: sq [ xy ] @ $10000 /mod 16 + swap 16 + box | cr
17 0 +at ;
: loc [ ic ] @ [ 16 24 8 */ ] * [ 12 block 4 * ] + ;
: 0/1 $8000 ? if green sq ; ] then blue sq ;
: row dup @w *byte 16 for 0/1 2* next drop | cr
[ -17 16 * ] 17 +at ;
: ikon loc 24 for row 2 + next drop ;
: adj 17 * swap ;
: cursor [ cu ] @ 16 /mod adj adj over over at | cr
red 52 u+ 52 + box ;
: line ( i-in) for dup emit 1 + next ;
: set ( xy) over lm at 0 10 for 12 line cr next | cr
8 line drop ;
: ok show black screen cursor 18 dup at ikon | cr
text [ ic ] @ dup . h. 400 60 set keyboard ; 56 load ok h

{block 55}
( draw big-bits icon)
: @w a-n ( fetch 16-bit word from byte address)
: !w na ( store same)
: *byte n-n ( swap bytes)
: ic -a ( current icon)
: cu -a ( cursor)
: sq ( draw small square)
: xy -a ( current screen position, set by) at
: loc -a ( location of current icons bit-map)
: 0/1 n-n ( color square depending on bit 15)
: row a-a ( draw row of icon)
: ikon ( draw big-bits icon)
: adj nn-nn ( magnify cursor position)
: cursor ( draw red box for cursor)
: ok ( background task to continually draw icon, icon number at top)

{block 56}
( - control panel)
: +ic 1 [ ic ] +! ;
: -ic [ ic ] @ -1 + 0 max [ ic ] ! ;
: bit [ cu ] @ 2/ 2/ 2/ 2/ 2* loc + $10000 [ cu ] @ $f and 1 + for 2/ next *byte ;
: toggle bit over @w or swap !w ;
: td toggle
: d 16
: wrap [ cu ] @ + [ 16 24 * ] dup u+ /mod drop [ cu ] ! ;
: tu toggle
: u -16 wrap ;
: tr toggle
: r 1 wrap ;
: tl toggle
: l -1 wrap ;
: h pad nul nul accept nul tl tu td tr l u d r -ic nul nul +ic nul nul nul nul nul nul nul nul nul nul nul nul [ $2500 , $110160c dup , , $2b000023 , 0 , 0 , 0 ,

{block 57}
( edit icon)

{block 58}


{block 59}


{block 60}
( serial 3f8 2e8 1050) macro ]
: p@ [compile] a! [compile] dup $ec 1, ;
: p! [compile] a! $ee 1, [compile] drop ;
: 1@ $8a 2, ;
: 1! [compile] a! $288 2, [compile] drop ; forth ]
: r [ 0 + ] + ;
: 9600 12 ;
: 115200 1 ;
: b/s $83 [ 3 r ] p! 115200 [ 0 r ] p! 0 [ 1 r ] p! 3 [ 3 r ] p! ;
: init b/s ( 16550) 1 [ 2 r ] p! 0 [ 4 r ] p! ;
: xmit ( n) [ 5 r ] p@ $20 and drop if [ 0 r ] p! ; ] then ( pause) xmit ;
: cts [ 6 r ] p@ $30 and $30 or drop if cts ; ] then xmit ;
: st [ 6 r ] p@
: xbits $30 and $10 / dup 1 and 2* 2* + 2/ ;
: st! [ 4 r ] p! ;
: ?rcv [ 5 r ] p@ 1 and drop if [ 0 r ] p@ then ;
: rcv ?rcv if ; ] then ( pause) rcv ;

{block 61}

: p@ p-n ( fetch byte from port)
: p! np ( store byte to port)
: 1@ a-n ( fetch byte from byte address)
: 1! na ( store byte to byte address)
: r n-p ( convert relative to absolute port address. base port on stack at compile time. compiled as literal at yellow-green transition)
: 9600
: 115200 ( baud-rate divisors. these are names, not numbers)
: b/s ( set baud rate. edit to change)
: init ( initialize uart)
: xmit n ( wait for ready and transmit byte)
: cts n ( wait for clear-to-send then xmit)
: st -n ( fetch status byte)
: xbits n-n ( exchange status bits)
: st! n ( store control byte)
: ?rcv ( fetch byte if ready. set flag to be tested by) if
: rcv -n ( wait for ready and fetch byte)

{block 62}
( word search) macro ]
: bt ( nm-n) [ $68bd08b ] , [ $f04768d ] , [ $d21bc2a3 ] , ; forth ]
: tag? ( nm-n) over $f and swap bt drop ;
: red? ( n-nm) [ $1008 ] tag? if [ $4092 ] ; ] then [ $1008 ] ;
: t2 ( nn-nn) 1 +
: t1 ( nn-nn) 1 [ curs ] +!
: t0 ( nn-nn) 1 + ;
: map ( nnn-nn) $f and jump | indent
     t0 t1 t2 t1 t1 t2 t1 t1 | indent
     t1 t1 t1 t1 t2 t1 t1 t1
: tcurs ( nn-n) over block push -1 [ curs ] ! 0
: tcu1 ( nnn-n) dup i + @ map over over negate + drop -if t1 drop drop pop drop ; ] then tcu1 ;
: -curs ( -) [ curs ] @ -1 + 0 max [ curs ] ! ; here ]
: tpoint [ blk ] @ [ curs ] @ tcurs drop -curs ; cpoint !

{block 63}
( word search tcurs)
: bt ( returns nz and less if bit n of m is set. pops t to 2, bit test index t mask 2, 2-2-sbb to set nz if carry.)
: tag? ( nz and less if bit in m indexed by tag of token n is 1.)
: t2 nn-nn ( 2 cell - big nums, var)
: t1 nn-nn ( 1 cell)
: t0 nn-nn ( extensions, undefined)
: map end n wrd-end n ( inc n and maybe curs)
: tcurs blk offset-blk ( convert offset to tokens in curs)
: -curs - ( decrement curs to zero)
: tpoint - ( fix abort to point cursor correctly, except if last word in block)

{block 64}
( - more) :var fmask [0xfffffff0] :var fnn [0x5e723890] | cr
:var fna [0x4009200] :var fbits [0x5e9a] 18 block fna ! ]
: +shad ( a-a) dup [ fna ] @ or 256 and + ;
: 1word ( -n) word [ words ] @
: 1wz 2 less drop if drop ; ] then nip -1 + 1wz ;
: want? ( nm-n) tag? if or ; ] then drop drop -1 ;
: -found ( na) @ [ fbits ] @ want? [ fmask ] @ and drop ;
: reedit ( fna) nip dup 1 + [ fna ] ! | indent
     $100 /mod -offset swap tcurs swap | indent
     dup and drop if dup [ blk ] ! then edit ;
: find 1word $5e9a | -cr : fnd+ 18 block -16
: fnd ( nbam) [ fmask ] ! [ fna ] ! [ fbits ] ! 16 or [ fnn ] ! 0
: f ( f) [ fnn ] @ 16 or [ fna ] @ begin | indent
     +shad [ nblk ] @ block less drop while | indent
     over over -found while 1 + end | indent
     then reedit ; ] then drop drop drop ;
: def 1word [ $1008 ] fnd+ ; here ekt 21 + ! ]
: fkc drop [ pcad ] @ @ [ $140 ] tag? if [ 32 ] / edit ; | cr
] then red? fnd+ ( blk @) dup ; here ekt 22 + ! ]
: fk drop ( drop) [ cad ] @ [ fna ] ! 1 f ( blk @) dup ;
: from ( n) 1word swap [ $5e9a ] swap block [ -16 ] fnd ;
: literal ( n) $20 * [ $140 ] 18 block [ -32 ] fnd ;

{block 65}
( word search)
: +shad ( skips shadows if in one and skipping.)
: 1word -n ( return 1st cell of word from kbd.)
: find ( finds following short word, starting in block 18, regardless of color.)
: def ( finds only definitions.)
: f ( find next occurrence of word last found)
: fk ( 'f' key in edit keyboard. drops key and block number and behaves like f except continues search from current editor position in current kind of block src/shad.)
: fkc ( if word left of cursor is a number, list that block. if red or magenta definition, searches for references. otherwise searches for definitions.)
: from n- ( like find but start from block number)
: literal n- ( finds any equivalent literal)

{block 66}
( editor recolor) 8 display + @ 13 display + ! ]
: array pop 2/ 2/ + @ ; ( 1-4-9 2-5 8-6-15)
: reclr align array | cr
[ 0 , 4 , 5 , 3 , 9 , 2 , 15 , 7 , | cr
6 , 1 , 10 , 11 , 12 , 13 , 14 , 8 , ]
: wadr ( -a) [ pcad ] @ [ blk ] @ max ; here ekt 20 + ! ]
: change wadr @ $f and reclr wadr @ $fffffff0 and or wadr ! ; $220e100a ekt 33 + ! | br

( obsolete comment cases) $f000000 ekt 32 + ! | cr
ekt 16 + @ dup ekt 17 + ! ekt 18 + !

{block 67}
( tags) | cr
( extend) execute 32-bit ( define) | cr
] compile 32-bit [ 27-bit [compile] immediate | cr
] 27-bit ( comment cap caps) | cr
( variable address blue 27-bit) | br


: array ( fetch new tag)
: reclr ( table of color cycles)
: wadr -a ( address of word to left of cursor)
: change ( color of word to left of cursor)
: 220e100a ( 0a-c 10-d 0e-f 22-j)

{block 68}
( blue words) :var ?blu [0xff] 0 ?blu ! ]
: -w@ ( -n) 7push pop -1 + @ ; | *
: .blu [ ?blu ] @ color
: type1 [ 9 display + @ 5 + ] push ; | , | , here | *
: blu ; | *
: -blue ( b-t) dup 1 + 4@ + [ -5 + ] or | , | ... drop ; | , | ,
: d03 ( -a) [ 3 display + ] ; | . | . | . here ]
: exr [ d03 @ ] nop [ d03 ] ! red type1 ;
: -cr blu [ 0 + ] nop [ d03 ] ! ; | *
: sp/2 $b0000 [ xy ] +! ; | , | ,
: bs [ xy 1 + ] @ 21 + $10000 * [ xy ] @ less | , | ... drop drop if $ffea0000 [ xy ] +! then ;
: wd ( nn-/n) over or if 0 and drop ; | , | ... ] then nip pop pop drop push 1 or drop ;
: simple ( -w) -w@ -16 and | , ( *) $fa000000 wd if bs .blu -cr bs ; ] then | , ( ,) $fc000000 wd if bs .blu cr ; ] then | , ( .) $ea000000 wd if .blu bs ; ] then | , ( ..) $ebd40000 wd if .blu bs ; ] then | , ( ...) $ebd7a800 wd if .blu bs ; ] then ;

{block 69}
( blue and grey words) | *
: must ( fit into one cell!) | , | ,
: -w@ ( returns word being interpreted by display)
: .blu ( display blue word)
: type1 ( displays word with color already set) | , | ,
: exr ( one-shot red display suppressing cr)
: -cr ( arms exr for next red word encountered.)
: s/2 ( halfspace for reports.) | , | ,
: bs ( backspace protecting left margin)
: wd ( is a factor of) simple ( to test shannon codes)
: simple ( returns regular blue word for execution but handles special words internally.) | , | ,
: exb ( display and execute blue word iff found in dictionary.)

{block 70}
( - blue and grey) | , | , here 14 display + ! ]
: exb simple .blu itick if drop ; ] then | , dup -blue if drop ; ] then push ( drop) ; | , | ,
: seeb [ ?blu ] @ $ff or [ ?blu ] ! ;
: ?seeb ( -t) [ ?blu ] @ [ 0 ] + drop ; | , | ,
: @lit -w@ 32 / ; ( grey) here display 13 + ! ]
: tadr $c0c0c0 color @lit 1024 /mod swap | , 2 over -256 and drop if 1 + then h.n | , 0 + if 39 emit dup 1 h.n then drop space ; | , | , ( old blue words)
: br blu cr cr ; | *
: tab ( n) for space next ;
: indent blu cr 3 tab ; | *
: kr cr ; | *
: cr blu kr ;

{block 71}

: seeb ( toggle display of blue words)
: ?seeb ( set flag non-zero if blue words visible) | , | ,
: @lit ( fetch 27-bit literal from current word)
: tadr ( display target address) | , | ,
: br ( blank line)
: tab ( advance n spaces)
: indent ( 5 spaces)

{block 72}
( convert cf character to/from ascii) | cr
macro ]
: 1@ $8a 2, ; | -cr : 1! [compile] a! $288 2, [compile] drop ; forth ]
: string pop ;
: cf-ii align string | cr
[ $6f747200 , $696e6165 , $79636d73 , $7766676c , | cr
$62707664 , $71757868 , $33323130 , $37363534 , | cr
$2d6a3938 , $2f7a2e6b , $2b21273b , $3f2c2a40 , ]
: ch $fffffff0 and unpack [ cf-ii ] + 1@ $ff and ; | br


: ii-cf string | cr
[ $2a00 , $2b , $2b2d0000 , $2725232e , | cr
$1b1a1918 , $1f1e1d1c , $28292120 , $2f000000 , | cr
$3a43355c , $3d3e3440 , $54523744 , $3336393c , | cr
$38314742 , $3f414632 , $563b45 , $23000000 , | cr
$a13052c , $d0e0410 , $24220714 , $306090c , | cr
$8011712 , $f111602 , $260b15 , ]
: chc $ffffffe0 + [ ii-cf ] + 1@ $ff and ; | br


: set1 $3d21223a $3e2c203c
: !8 ( nn-) [ cf-ii $2c + 2/ 2/ ] ! [ cf-ii $28 + 2/ 2/ ] ! ;
: set0 $2b21273b $3f2c2a40 !8 ;

{block 73}
( colorforth to ascii and ascii to colorforth)
: cf-ii ( otr inae ycms wfgl bpvd quxh) | indent
     ( 3210 7654 -j98 /z.k +!'; ?,*@)
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ?) | indent
     ( cba@ gfed 02ih onml srqp wvut 1yx) | indent
     ( cba@ gfed 02ih onml srqp wvut 1yx) | br

[ to facilitate pathnames and html strings... ]
: set1 ( modifies cf-ii table.) | cr
; ( to colon,) ] ' ( to doublequote,) + ( to equal,) | cr
@ ( to lessthan,) * ( to blank,) ? ( to greaterthan)
: set0 ( restores original cf-ii table.)

{block 74}
( pathname input) -nat 72 load set1 ]
: strng ( n-a) pop + ;
: fnam ( n-a) align strng [ here 80 + h ! :var hld [0xc]
: emt ( n-) [ hld ] @ fnam 1! 1 [ hld ] +! ;
: +shan ch emt dup and if +shan ; ] then drop ; | br


: ,src 7@+ @
: xx dup and if +shan 7@+ @ dup 15 and drop | cr
while then [ 0 ] and emt 7dec ; ] then xx ;
: named ( string) 0 [ hld ] ! -kbd if ,src ; | cr
] then ( keyboard) 0 word 0 | cr
begin push dup and while end then drop | cr
begin pop dup and while +shan end then emt ; | cr

: onam ( n-a) align strng [ here 80 + h ! ]
: bnam ( n-a) align strng [ here 80 + h ! ]
: !str ( b) push named [ 0 fnam ] 4 / pop 4 / [ 20 ] move ;
: onamed 0 onam !str ; onamed ( okadwork.cf)
: bnamed 0 bnam !str ; bnamed ( okadback.cf) | cr
0 onam 'ofn ! 0 bnam 'bfn !

{block 75}
( filename input)
: strng ( defines an array of bytes.)
: fnam ( is a zero terminated ascii string consisting of) hld ( chars including the null.) emt ( appends a character to this string.)
: +shan ( appends a shannon word to fnam.) | br


: named ( returns the byte address of a null terminated ascii string representing the following colorforth string, which may follow in either source code or in keyboard input.) | cr
( example) [ named ( //./a;) | br


: onamed ( and) bnamed ( override the default .cf) | cr
( filenames used by save and audit)

{block 76}
( index) empty -nat | cr
:var pad [0x109e4000] abuf block 4 * pad ! | cr
:var hld [0x109e79a4] pad @ hld ! :var pos [0x2] 0 pos ! ]
: nxt ( a-an) dup 1 + swap @ ;
: -eol? [ pos ] @ [ 47 ] or drop ;
: .sp 32
: .ch ( c) -eol? if [ hld ] @ 1! 1 [ hld ] +! 1 [ pos ] +! ; | indent
     ] then drop ;
: crlf 0 [ pos ] ! 13 .ch 10 .ch ; | br


: .hd ( n) [ -10 ] + -if [ $3a ] + .ch ; ] then [ $41 ] + .ch ;
: .dec ( n) [ 0 ] + -if $2d .ch negate then [ -1 ] swap | cr
begin [ 10 ] /mod dup and while end then drop
: spit ( -1 ...) begin .hd [ 0 ] + -until drop ; | br


: hd ( n-nn) dup [ $f ] and swap 2/ 2/ 2/ 2/ ;
: .hex ( n) [ -1 ] swap begin hd $fffffff and while end then drop spit ; | cr
78 load | br

named ( index.txt) exit 18 1440 run

{block 77}
( index)
: hld ( place in file)
: spot ( in line)
: nxt ( fetch next word)
: emit ( ascii character, won't go past column) # 72
: space ( written to file)
: crlf ( to file)
: digit ( hex digit to file)
: .h ( print hex number)
: .d ( decimal number) | br

[ usage example in bottom line.

{block 78}
( - more)
: word ( n) .sp [ $fffffff0 ] and
: cont ( n) dup and if ch .ch cont ; ] then drop ;
: short ( n) .sp 2/ 2/ 2/ 2/ dup 1 and drop | indent
     if 2/ .hex ; ] then 2/ .dec ;
: variable ( an-a) word 0
: long ( an-a) .sp push nxt pop $10 and drop | indent
     if .hex ; ] then .dec ;
: eol ( n) begin drop 47 [ pos ] ! ;
: tag ( a-a) dup and until dup $f and jump | cr
cont word long eol word long short word | cr
short word word word variable short eol short
: ?sp ( nl-n) + -if .sp then ;
: line ( n) -100 ?sp -900 ?sp 1000 + | indent
     dup .dec space block 0 [ pos ] ! | indent
     begin -eol? while nxt tag end | indent
     then drop crlf ;
: run ( 1st lst+1) [ pad ] @ [ hld ] ! over negate + 2/ | indent
     for dup line [ 2 ] + next drop
: sav 0 32 2 0 0 w/o [ 0 fnam ] fcreate dup push | cr
[ pad ] @ [ hld ] @ over negate + pop fwr drop fclose ;

{block 79}
( index.1)
: short ( number)
: literal ( long number)
: word ( text, not number)
: cont ( inuation word)
: variable ( name and value)
: eol ( red word means end of line)
: tag ( vector table)
: words ( print maximum n words or to eol)
: run [ first-block last+1 | cr
( prints first line of each block in range) | cr
( to a log file) in windows

{block 80}
( qx) :var ?qxc [0x102f7e2d] :var qb [0x528] 82 load ]
: ?c ( n-n) green dup [ blk ] @ or drop if white then ;
: !qx [ ?qxc ] assign ?c ; !qx | , | ,
: nx [ qb ] @ 120 + | *
: qx ( n !qx) 0 max abuf /mod | , | ... push 2 /mod 60 / 120 * + pop abuf * + [ qb ] ! | , show black screen white 0 60 for dup 30 /mod | , | ... 42 * swap tab/2 [ qb ] @ over 2* + [ ?qxc ] xqt | , | ... dup .r .cmt 1 + next drop keyboard ;
: bx [ qb ] @ -120 + qx ; | -cr : ax [ blk ] @ qx ;
: sx [ qb ] @ 1 or qx ;
: ox [ qb ] @ [ abuf ] /mod 1 or [ abuf ] * + qx ;

{block 81}
( index page overview display) | br


: qx ( shows the heading comments of the index page in which block) [ n ( lies, source or shadow.) | br


: nx ( shows the next page and) bx ( the preceding.)
: sx ( toggles between source and shadows for the current page.) | br


: ax ( shows the page in which the current editor block lies.) this block is displayed in green

{block 82}
( - formatting) :var ws [0x102f7cad]
: tab/2 ( xy) push [ 11 ] * [ 3 ] + pop [ 15 ] * [ 3 ] + | cr
over lm at ; | -cr : emit/2 ( c) [ 48 ] + emit
: -sp/2 [ -11 $10000 * ] nop [ xy ] +! ; | br


: /bl [ ws ] assign nop ; | -cr : /sp [ ws ] assign sp/2 ;
: .r ( n) [ 4 ] for 10 /mod next $f and [ 4 ] for [ 0 ] + if | cr
pop [ 1 ] + | -cr : .lo for [ 24 ] + emit/2 next ; | cr
] then drop [ ws ] xqt next [ 1 ] .lo ; /sp ]
: .n ( n) [ 32 ] / /bl .r /sp ;
: .s/2 ( n) [ 0 ] + if unpack emit/2 .s/2 ; ] then drop ;
: .wd ( n) [ $8200 ] tag? if sp/2 then [ $8000 ] tag? if .n ; ] then -16 and .s/2 ;
: .cmt ( n) 18 less drop if drop ; ] then block 7 for dup @ [ 0 ] + while [ $8201 ] tag? while .wd | cr
[ 1 ] + next drop ; ] then then pop drop drop drop ;

{block 83}
( index page overview display) | br

( these definitions are necessary due to the way in which colorforth kernel is factored.)

{block 84}
( resident compress) 86 load ]
: short 4 rbits 28 bits ;
: lit 4 rbits 2/ 2/ 2/ 2/ 1 rbits
: 32bits drop 1 + dup @ 16 bits 16 bits ;
: variable 1word 32bits ;
: /whit ( n-n) -16 and 9 or atom ;
: tag ( an-an) dup $f and jump cont atom lit atom atom lit short atom short atom /whit /whit variable short atom short
: atoms ( a) dup @ dup and if tag drop 1 + atoms ; ] then 4 bits drop drop ;
: range ( nn-an) here/4 here4 push new for dup block atoms 1 + next drop $ 0 31 bits drop pop here4 over negate + ;
: !lng ( nw) [ 127 ] + [ 128 ] / [ 72 ] + dup ( nsec) [ 0 ] block [ 1 ] + ! dup negate [ ns ] ! [ 35 ] + [ 36 ] / [ nc ] ! ;
: save 7push [ h ] @ push [ cbuf 36 + block 4 * ] h ! 36 [ nblk @ -36 + ] range ( an) !lng drop $ 0 block [ cbuf ] block [ 36 blks ] move [ cbuf ] !work [ ns ] @ abs [ ns ] ! pop [ h ] ! 7pop ;

{block 85}

: short ( tag, then 28bit value+base)
: lit ( tag, then base)
: 32bits ( from next word. 2 chunks)
: variable ( single word, then 32-bits)
: /whit ( replaces a word's tag with 9, making it a lowercase comment.)
: tag ( identify kind of word) [ note /whit used for tags $a and $b to convert these deprecated capitalized comments to lower case. when all source of interest has been compressed at least once this may be removed. ]
: atoms ( scan thru block. 8 0s eob)
: range ( process blocks, number and count. 31 0s eof)
: sve ( compress blocks 72 thru 1419)
: flop ( write floppy; save number of cylinders)

{block 86}
( - more) macro ( uses ebx)
: r3@ [compile] ?dup $c38b 2, ;
: r1! $c88b 2, [compile] drop ;
: 2*d $c3a50f 3, ;
: 2*c $e0d3 2, ;
: 2/r $c8d3 2, ; forth :var nb [0xd]
: here/4 here 3 and if 1, here/4 ; ] then drop ;
: here4 here 2/ 2/ ;
: new 32 [ nb ] ! ;
: shift ( nn-n) dup negate [ nb ] +! r1! 2*d 2*c ;
: rbits dup r1! swap 2/r swap
: bits ( nn-n) dup negate [ nb ] @ + -if dup push + shift r3@ , new pop negate shift ; ] then drop shift ;
: char -if 2* -if 2/ 7 bits ; ] then 2/ $80000000 or 5 bits ; ] then 4 bits ;
: chars dup and if char chars ; ] then ;
: 1word 4 rbits chars 4 bits ;
: atom ( an-an) 4 rbits
: cont chars over 1 + @ dup and if $f and drop if 4 bits ; ] then ; ] then drop 4 bits ;

{block 87}

: r3@ ( fetches register) # 3 ( onto stack.)
: r1! ( stores top of stack to register 1.)
: 2*d ( shift ebx left by ecx. bits from eax)
: 2*c ( shift eax left by ecx)
: 2/r ( rotate eax right by ecx)
: nb ( number of bits remaining in word)
: here/4 ( align to word boundary)
: here4 ( word address in dictionary)
: new ( 32-bits in current word)
: shift ( eax into ebx, decrement) nb
: rbits ( rotate bits to high-order position)
: bits ( shift bits into ebx; cross word boundary)
: char ( examine high bits. shift 4, 5 or 7 bits)
: chars ( shift all non-zero characters)
: 1word ( short word without continuation for variable)
: atom ( shift tag, then characters)
: cont ( continue without tag)

{block 88}
( display text) macro ]
: 7@+ ( -a) [compile] ?dup $c78b 2, $47 1, ; | *
: 7dec $4f 1, ;
: @ret ( -b) [compile] ?dup $24048b 3, $5240483 , ;
: 4@ ( b-n) $8b 2, ; forth ]
: tick ( b-b) dup [ 1 ] + 4@ + 5 + ;
: call $e8 | *
: dst 1, @ret tick here 3 + - + , ;
: jmp $e9 dst ; | *
: execute ( b) push ; | , | ,
: .shan ( n-) dup and if unpack emit .shan ; ] then drop ;
: .shans ( a) begin dup @ [ $8201 ] tag? while -16 and | , | ... .shan 1 + dup @ [ $8200 ] tag? drop if space | , then end then drop drop ; | *
: +str ( a-a) + ; macro ]
: ,lit ( n) [compile] ?dup $b8 1, , ;
: strings ( i-a) 7push pop [compile] ,lit jmp +str nop ;
: .' ( comments) 7@+ [compile] ,lit call .shans nop ;
: remember [ forths ] @ [compile] ,lit [ macros ] @ [compile] ,lit [ h ] @ [ 15 ] + [compile] ,lit ( call) jmp !dict nop ; forth | , | ,
: ' ( -b) -kbd if 7@+ @ itick if abort then ; | , ] then tic ;
: eval ( a) 7push [ 1 ] + push 7pop | , | ... [ sp 1 + ] @ execute 7pop ;

{block 89}
( various useful extensions.) | br


: 7@+ ( interpret only, returns adr of next word in block and skips over it ... 7-0-mov 7-inc)
: 7dec ( used to correct address after 7@+)
: @ret ( fetch return address, skip bytes of code.)
: 4@ ( cell fetch on byte boundary)
: tick ( given adr of call instr, return tgt adr)
: call ( and) jmp ( generate xfers to next word) | br


: .shan ( displays a shannon coded string)
: ,lit ( compiles a literal.)
: .' ( displays the following comment or comments.)
: remember used ( in a containing word to make that word restore dictionary to what immedately follows it.) | br


: strings ( starts an array of words in source.)
: ' ( interp only, returns next word's code addr.)
: execute ( is a call to the given routine adr.)
: eval ( interprets the source word whose address is given.)

{block 90}
( disk audit utility) empty 30 load :var bias | , :var sep [0x2710] abuf sep ! :var head [0x59f] 1439 head ! ]
: +blocks ( sdn) 2* ( bloks ;)
: bloks ( sdn) push swap block swap block pop [ 256 ] * move ; | *
: n18 ( i-a) [ abuf 18 + block ] + ;
: wipe [ blk ] @ 1 erase ( e) lis ; | *
: to ( n) [ head ] ! ;
: obliterate ( lh) over negate + erase ;
: matching ( sd) less if swap then | , dup [ bias ] ! negate + [ sep ] ! ;
: cast ( nn-n) dup push /mod 1 or pop * + ;
: other ( n-n') [ bias ] @ negate + [ sep ] @ cast [ bias ] @ + ; | *
: lesser ( n-n) dup other min ; 92 load ]
: ?blk ( n-n?n+) lesser dup block over other block [ 256 ] for over @ over @ or drop if drop drop dup [ 1 ] + pop drop ; ] then [ 1 ] + [ 1 ] u+ next drop drop [ 1 ] + ; | *
: ?blks ( sn-?) for ?blk next drop ;
: ?bin ( kernel) 0 12 ?blks ( icons) 12 6 ?blks ;
: unpk abs [ 1 n18 ] ! | , [ abuf 36 + ] block [ cbuf ] block [ 1404 ] blks move | , [ cbuf block ] abuf 36 + [ 3 n18 ] @ [ -36 ] + range ;
: check [ abuf ] @back [ 0 n18 ] @ [ 18 block @ ] or | , drop if ; ] then [ 1 n18 ] @ | , dup and -if unpk ; ] then drop ;

{block 91}
( disk mgmt and reconciliation utility.)
: bloks ( copies n blocks from s to d, front to back so only moves overlap downward safely.)
: +blocks ( copies n blocks and their shadows.)
: obliterate ( wipes from block l to block h.)
: matching ( sets up to match s to d.)
: to ( sets block no. past end of source area.)
: other ( given a block number in one of the areas returns the corresponding block no. in the other area.)
: lesser ( given a block number returns the lesser of the pair it is a member of)
: ?blks ( scans a range of blks leaving nos of any differing blks on the stack.)
: ?bin ( scans the binary parts of okad disk.)
: check ( reads backup to) # 3000 ( and decompresses if appropriate)

{block 92}
( - compare) :var cvec [0x102f9446]
: blink [ cvec ] assign ( n) dup other [ blk ] ! edit ;
: var ( nnxx-nnd) push push 1 + 1 u+ pop pop
: *1 ( nnxx-nnd) or ;
: *2 ( nnxx-nnd) var push over @ over @ or pop + ;
: tag ( nn-n) dup $f and jump *1 *1 *2 *1 | , | ... *1 *2 *1 *1 | .. *1 *1 *1 *1 | .. var *1 *1 *1
: ?nul ( nnxx-nnxx) over over +or drop if ; ] then drop drop pop drop drop drop ;
: co ( naa-n) over @ over @ ?nul tag drop if | , | ... drop drop [ cvec ] xqt ; ] then 1 + 1 u+ co ;
: com ( n-n) dup block over other block co ;
: g [ blk ] @ lesser
: gg ( n) blink [ head ] @ over - + drop -if drop ; | , ] then [ 1 ] + com gg ;
: v [ blk ] @ other edit ;
: give [ blk ] @ dup other 1 bloks ;
: take [ blk ] @ dup other swap 1 bloks ;
: all 0 [ abuf ] matching [ nblk ] @ [ -1 ] + to [ 17 ] gg ;
: diff [ cvec ] assign red ;
: !cx [ ?qxc ] assign ( n-n) ?c diff com ; | , !cx | *
: empty empt !qx ;

{block 93}

: blink ( displays the given block with its other set as the editor's 'other' block)
: var ( compares a variable name, advancing pointers to skip its value.)
: *1 ( compares garden variety words.)
: *2 ( compares large literals.)
: tag ( compares source cells given, true if diff, advancing ptrs and ignoring variable vals.)
: ?nul ( ends loop in co if nuls hit in both blks.)
: co ( does work of com given adrs of both blks.)
: com ( invokes editor to blink the given block if it differs from the other, otherwise returns.)
: g ( scans for diffs after current editor block.)
: v ( shows the other block)
: give ( writes current editor block over its twin)
: take ( writes twin over current editor block.)
: check ( reads backup to 3000 for matching.)
: all ( scans the whole usable area of the disk.)
: cvec ( is behavior on com finding difference;)
: diff ( makes it just set color for qx.)
: !cx ( makes qx aware of us,)
: empty ( redefined to kill that awareness.)

{block 94}
( improved stack display) :var nr [0x2] | , | ,
: -msg [ ' nul ] 'msg ! 2 [ nr ] ! ;
: msg -msg pop 'msg ! ;
: rep -1 [ nr ] +! [ nr ] @ 0 + drop if ; ] then -msg ;
: ?msg 'msg @ -safe if -msg ; ] then ;
: empty empt ?msg ?logo ; | , | ,
: ks0 ( -a) 'stk 1 + @ 4 / -1 + ;
: ksp ( -a) 'stk 2 + @ 4@ 4@ 4 / ;
: .s ks0 ksp negate + ( dup .) 0 less drop if | , | .. abs . .' ( below empty) ; ] then 0 + if | , | .. | .. [ 5 ] over less drop if .' ( ...) swap then drop | , | .. | .. dup push ksp + begin | , dup @ ?. -1 + next ( drop) then drop ; | , ( install) ' .s 'stk ! ( exit) | , | ,
: -range msg rep red .' ( out of range) ; macro ]
: then ( a-a) here over negate + 128 + -256 and | , drop if -range abort dann [compile] dann ; forth exit | ,
: dstk | *
: z ( 'msg assign white) | , 'stk 2 + @ 9 + 4@ 4@ # 4 ( / ?.) ;

{block 95}

: -msg ( deactivates any current message and sets) nr ( to default life span of) # 2 ( refreshes, which typically means) [ two keystrokes. ]
: msg ( is std word to assign rest of defn to msg.)
: rep ( is used inside a msg to count down life.)
: ?msg ( deactivates if its code's been forgotten.)
: empty ( changes display/message only if needed.) [ messages display till forgotten, or aged using rep, or are replaced by another, or someone says -msg, or the message otherwise monitors the situation and uses -msg itself. | , | ,
: ks0 ( and) ksp ( return empty and current stack) | , ( pointers in word units.)
: .s ( displays stack, top on right,) [ yellow ( number is max number of entries to display. indicates stack below empty and ... when excess items.) | , ( factored separately so new versions may be) | , ( tested as messages with) ] nos

{block 96}


{block 97}


{block 98}


{block 99}


{block 100}
( show bin occupancy) empty compile ]
: ?any ( nn-nn) dup nn-n 2* $8000 + block 0 64 for | , | ... over @ $61fc or +or 1 u+ next nip 0 + | , drop if dup 100 mod swap then ;
: row ( nn) 18 for ?any 1 + next drop ;
: chk 0 18 for dup 1 + next drop ;

{block 101}


{block 102}


{block 103}


{block 104}


{block 105}


{block 106}


{block 107}


{block 108}
( ide native async) 0 fh orgn ! macro ]
: 1@ ( b-c) $8a 2, ;
: 1! ( cb) [compile] a! $288 2, [compile] drop ;
: 2@ ( b-h) $8b66 3, ;
: 2! ( hb) [compile] a! $28966 3, [compile] drop ;
: 4@ ( b-n) $8b 2, ;
: 4! ( nb) [compile] a! $289 2, [compile] drop ;
: swab ( h-h) $c486 2, ;
: swa4 ( n-n) $c80f 2, ; forth ]
: a-b ( a-b) 2* 2* ;
: b-a ( b-a) [ 3 ] + 2/ 2/ ;
: create ( -a) pop b-a ;
: rez ( n) h +! ;
: ?zero ( n-n) [ 0 ] or if dup or ; ] then ( -) [ -1 ] or ; | br

:var act :var vport [0x175] :var 0tg [0x1] :var 1tg [0x1] :var 2tg [0x1]
: cold 1 [ 0tg ] ! 1 [ 1tg ] ! 1 [ 2tg ] ! 0 [ act ] ! ; | br

( ser) 110 load 118 load ( routes) 120 load | cr
( generic) 122 6 loads ( panel) 134 load | cr
( user) 136 load 142 load ( creeper) 140 load | cr
canon load

{block 109}
( talk to chip via native rs232.) | br


: 1@ ( and) 1! ( byte fetch and store, byte address.)
: 2@ ( and) 2! ( halfcell fetch/store, byte adr.)
: swab ( and) swa4 ( 2-way and 4-way byte swaps.)
: a-b ( and) b-a ( convert cells to+from bytes.) | br


: bofs ( and) ofs ( make byte and cell offset adrs in a structure given byte posn and byte width.)
: create ( used after) [ align ( to exit with word adr of cell following in dictionary.) note that writing into such allocations invalidates nearby instruction cache! ]
: rez ( allots n bytes in the dictionary.)
: ?zero ( classical zero-equal returning 0 or -1 with indicators.) | br


: ntgt ( indices for active paths, 1 for adjacent.)
: act ( number of selected path, to which) vport ( leads.)
: cold ( sets no active paths.)
: user ( test code before canonicals.)

{block 110}
( - umbilical) $3f8 ( serial) 60 load ]
: !nam ; :var sport :var bps
: rsh ( ni-n) 0 + if for 2/ next ; ] then drop ;
: sdat align create [ 24576 rez :var bi [0x1e]
: -stream 0 [ bi ] ! ;
: stream ( -b) [ sdat a-b ] ;
: /str ( -b) [ bi ] @ [ stream ] + ; | br


: @18 ( -n) /str 4@ [ $3ffff ] and
: +wd 3 [ bi ] +! ;
: !18 ( n) [ $3ffff ] or [ $40 ] * [ $12 ] + /str 4! +wd ; | br


: +ser ( -ok) init 1 [ 0 ] + ;
: -ser ;
: reset [ 1 ] st! [ 100000 ] for next [ 3 ] st! ;
: toser ( bn) for dup 1@ xmit [ 1 ] + next drop ;
: inser ( w) stream swap [ 3 ] * for | indent
     rcv over 1! [ 1 ] + next drop ;

{block 111}
( async data are 18 bits per 3 bytes. to chip word inverted, shifted up 6, '12' inserted, then sent low order byte first. from chip are tbd.) | br


: !nam sport ( and) bps ( dummies for compatibility)
: 4@ ( and) 4! ( full cell on byte address.)
: +ser ( opens serial; true if good, handle in dh.)
: -ser ( closes the handle.)
: reset ( resets the chip.)
: toser ( transmits n bytes to chip.)
: inser ( receives w f18 words from the chip.) | br


: -stream ( clears byte index) bi ( in) sdat ( buffer.)
: stream ( byte adr of buffer.)
: /str ( byte adr of next 18-bit slot in buff.) | br


: @18 ( returns the next 18 bits from the stream.)
: !18 ( appends 18 bits to the stream. no higher order bits may be present!)

{block 112}
( ide windows async) 0 fh orgn ! macro ]
: 1@ ( b-c) $8a 2, ; | -cr : 1! ( cb) [compile] a! $288 2, [compile] drop ;
: 2@ ( b-h) $8b66 3, ; | -cr : 2! ( hb) [compile] a! $28966 3, [compile] drop ;
: 4@ ( b-n) $8b 2, ; | -cr : 4! ( nb) [compile] a! $289 2, [compile] drop ;
: swab ( h-h) $c486 2, ;
: swa4 ( n-n) $c80f 2, ; forth | br


: a-b ( a-b) 2* 2* ; | -cr : b-a ( b-a) [ 3 ] + 2/ 2/ ;
: create ( -a) pop b-a ; | -cr : rez ( n) h +! ;
: ?zero ( n-n) [ 0 ] or if dup or ; ] then ( -) [ -1 ] or ; | br

:var act [0x2] :var vport [0x1d5] :var 0tg [0x1] :var 1tg [0x1] :var 2tg [0x1]
: cold 1 [ 0tg ] ! 1 [ 1tg ] ! 1 [ 2tg ] ! 0 [ act ] ! ; | br

( ser) 114 3 loads ( routes) 120 load | cr
( generic) 122 6 loads ( panel) 134 load | cr
( user) 136 load 142 load ( creeper) 140 load | cr
canon load

{block 113}
( talk to chip via onspec usb.) | br


: 1@ ( and) 1! ( byte fetch and store, byte address.)
: 2@ ( and) 2! ( halfcell fetch/store, byte adr.)
: swab ( and) swa4 ( 2-way and 4-way byte swaps.)
: a-b ( and) b-a ( convert cells to+from bytes.) | br


: bofs ( and) ofs ( make byte and cell offset adrs in a structure given byte posn and byte width.)
: create ( used after) [ align ( to exit with word adr of cell following in dictionary.) note that writing into such allocations invalidates nearby instruction cache! ]
: rez ( allots n bytes in the dictionary.)
: +or ( inclusive or.)
: ?zero ( classical zero-equal returning 0 or -1 with indicators.) | br


: ntgt ( indices for active paths, 1 for adjacent.)
: act ( number of selected path, to which) vport ( leads.)
: cold ( sets no active paths.)
: user ( test code before canonicals.)

{block 114}
( - umbilical) :var sport [0x3] 1 sport ! ]
: rsh ( ni-n) 0 + if for 2/ next ; ] then drop ;
: sdat align create [ 24576 rez :var bi [0x65d]
: -stream 0 [ bi ] ! ;
: stream ( -b) [ sdat a-b ] ;
: /str ( -b) [ bi ] @ [ stream ] + ; | br


: @18 ( -n) /str 4@ [ $3ffff ] and
: +wd 3 [ bi ] +! ;
: !18 ( n) [ $3ffff ] or [ $40 ] * [ $12 ] + /str 4! +wd ; | br


: snam ( -a) align create ( //./) [ $2f2e2f2f , ( com) $6d6f63 , $0 , ]
: !nam [ sport ] @ 10 over - + drop -if 256 * 2560 /mod + $3000 + then $30 + snam a-b 7 + 4! ; !nam ]
: toser ( bn) [ dh ] @ fwr drop ;
: inser ( w) stream swap [ 3 ] * [ dh ] @ frd drop ;

{block 115}
( async data are 18 bits per 3 bytes. to chip word inverted, shifted up 6, '12' inserted, then sent low order byte first. from chip are tbd.) | br


: sport ( comp com port number)
: snam ( null terminated string //./comx)
: !nam ( sets port number in snam.)
: +ser ( opens serial; true if good, handle in dh.)
: -ser ( closes the handle.)
: reset ( resets chip. no inversion in rx line.)
: toser ( transmits) [ n ( bytes from byteadr) b ]
: inser ( receives w f18 words from the sync boot node.) | br


: -stream ( clears byte index) bi ( in) sdat ( buffer.)
: stream ( byte adr of buffer.)
: /str ( byte adr of next 18-bit slot in buff.) | br


: @18 ( returns the next 18 bits from the stream.)
: !18 ( appends 18 bits to the stream. no higher order bits may be present!)

{block 116}
( - com port management) | , :var dflg [0x1011] $1011 dflg ! | , :var bps [0xe1000] 115200 bps ! ]
: dcb ( n-a) align strng [ here 32 + h ! ]
: @dcb 0 dcb [ dh ] @ rdcb drop ; 0 0 dcb b-a 8 fill ]
: !dcb [ dflg ] @ [ 8 dcb ] 4! 0 dcb [ dh ] @ wdcb drop ;
: /dcb @dcb !dcb ;
: baud ( n) @dcb [ 4 dcb ] 4! ( bits) 8 [ 18 dcb ] 1! | , ( np/1sb) 0 [ 19 dcb ] 2! !dcb ; | , | ,
: +ser ( -ok) snam r/w fopen [ dh ] ! if | , [ bps ] @ baud 1 ; ] then 0 ;
: -ser [ dh ] @ [ 0 ] + if fclose 0 then [ dh ] ! ;
: ctl! ( n) [ dh ] @ fesc drop ; :var ?reset 1 ?reset ! ]
: reset [ ?reset ] @ 0 + if ( lo) [ 4 ] ctl! | , | .. [ 500000 ] for next ( hi) [ 3 ] ctl! then drop ;

{block 117}

: dcb ( structure controls mode of a com port.)
: dflg ( flags sent every time we control com port) # $1 ( binary always,) # $10 ( dtr on,) # $100 ( rts on.)
: @dcb ( and) !dcb ( read and write com port control.) [ dflg ( is always included in the setting.)
: /dcb ( sets dflg without changing anything else)
: baud ( sets baud rate and character framing.) | , | ,
: +ser ( opens serial; true if good, handle in dh.)
: -ser ( closes the handle.)
: reset ( resets chip. no inversion in rx line.) | , [ set ] ?reset [ zero to prevent resetting in ] talk

{block 118}
( - node) # 708 ( boot frames)
: wos ( -n) 0 ;
: /frame ( nw xfr jmp) -stream [ $10000 ] + !18 !18 [ 1 ] + 2/ ( words) 2* ( actual) # -1 ( +) !18 ;
: +frame ( wn) for dup @ !18 [ 1 ] + next drop ;
: +ram ( w n node) nn-n 2* [ $8000 ] + block u+ for dup @ [ $15555 ] or !18 [ 1 ] + next drop ;
: !frame ( f) drop stream [ bi ] @ toser ; | br


: exec [ $ae ] ;
: talk cold -ser +ser if drop reset $40 0 [ exec ] /frame $0 $40 [ 1600 ] +ram [ wos ] !frame ( good) ; ] then ( bad) -ser drop $bad dup abort ; | cr

: exch ( w n f n) push push dup [ $2 ] + [ -2 ] and [ vport ] @ pop /frame [ vport ] @ [ $12000 ] + !18 dup - [ $1 ] and drop if [ vport ] @ [ $10000 ] + !18 then +frame [ wos ] !frame pop inser -stream ; | br


: ok [ $12 ] ;
: fet [ $15 ] ;
: stat [ $1b ] ;
: bstk [ $1d ] ;

{block 119}
( boot frames begin with a 3 word header;) | indent
     ] 100xx ( jump to xx when done) | indent
     ddd ( mem/port adr to store payload) | indent
     n ( transfer length) | indent
     [ n ( words of payload, none if) n ( is 0.)
: /frame ( heads a new given) [ even ( words of payload, destination addr, final jump addr.)
: +frame ( appends words to payload.)
: +ram ( appends a string of code from binary produced by) compile ( for the given) [ node.
: !frame ( transmits frame given) [ wos ( or) wos! | br


: talk ( prepares chip for control thru node 19.)
: exch ( performs a transaction with target given addr and length of port stream, stream end action in boot node, and number of words reply.) | cr

: ok ( stream end to simply ack completion;) fet ( pumps one word from target;) bstk ( shepherds stack dump;) stat ( pumps ten.) exec ( is next boot frame.)

{block 120}
( - node) # 708 ( paths)
: line ( ncd) swap push swap | indent
     begin dup , over + -next drop drop ;
: count ( nc-ncd) dup [ 100 ] mod [ 0 ] + if | cr
( horz) swap drop [ 1 ] ; ( vert) ] then drop [ 100 ] / [ 100 ] ;
: to ( nn) over negate + -if | cr
( back) negate count negate line ; | cr
( forw) ] then count line ; | br


: 0pa align create [ 708 700 to 600 0 to | cr
1 17 to 117 717 to 716 708 to -1 , ]
: 1pa align create [ 708 , 608 , -1 , ]
: 2pa align create [ 708 717 to 617 17 to | cr
16 0 to 100 , 101 116 to 216 200 to | cr
300 316 to 416 400 to 500 516 to | cr
616 600 to 700 708 to -1 ,

{block 121}

: 0pth 1pth 2pth ( are manually set route lists for using the north, south, and west ports of node 19. end list is marked by -1) | br

( customize these paths by replacing entries in) paths ( table after loading ide.)

{block 122}
( - boot target adjacent) :var 'wall [0x102ff7fc]
: swall ( nn-i) over over or [ 1 ] and drop if or [ 2 ] and ; ] then # 10 [ 100 ] / swap # 10 [ 100 ] / or [ 2 ] and [ 1 ] + ;
: wall ( nn-i) [ 'wall ] xqt ; ' swall 'wall ! | br


: do! align create ( @p+a!.@p+) [ $4ab7 , | indent
     $0 , $0 , ( !;;;) $b555 , ]
: do@ align create ( ...@p+) [ $2c9b7 , | indent
     $0 , ( a!@!p+;) $2be35 , ]
: doi align create [ $10000 , ]
: dopu align create ( @p+;) [ $5555 , $0 , ]
: dostk align create ( !p+dup-push!p+) [ $cdbe , | br


: aa@ ( a-n) [ do@ 1 + ] ! do@ [ 3 ] fet [ 1 ] exch @18 ;
: aa! ( na) [ do! 1 + ] ! [ do! 2 + ] ! do! [ 4 ] ok [ 1 ] exch ;
: acall ( a) [ $10000 ] +
: ains ( w) [ doi ] ! doi [ 1 ] ok [ 1 ] exch ;
: apsh ( n) [ dopu 1 + ] ! dopu [ 2 ] ok [ 1 ] exch ;
: astk dostk [ 1 ] bstk [ 10 ] exch ;

{block 123}
( this code supports boot node controlling one of its immediate neighbors directly.) these all begin with focusing call and each must return! | cr

: port ( returns port for 0-3 rdlu ndx, then edges)
: wall ( is index for port between two nodes)
: 'wall ( vectors the active) wall ( definition)
: swall ( is standard) wall ( definition) | br


: doxxx ( port execution templates for target.)
: aa@ ( fetches from memory or port in target onto our stack here.)
: aa! ( stores a value from our stack here to port or memory in target.)
: ains ( executes an arbitrary instruction word which must end by returning.)
: acall ( executes a target word which must return or jump to ports.)
: apsh ( pushes a number onto target stack.)
: astk ( queries target stack nondestructively.)

{block 124}
( - stream components) :var 'pth [0x40c041c]
: nstream ( an-n'w) swap [ 'pth ] ! [ -2 ] + -if [ 0 ] pop drop ; ] then ( pre) [ 2 ] ;
: ?path ( i-n) [ 'pth ] @ + @ ;
: side ( n-a) [ 'pth ] @ + dup @ swap [ 1 ] + @ wall port ;
: /hdr ( w-w) dup [ -2 ] and [ 0 ] side [ exec ] /frame ( pre) [ 0 ] side [ $12000 ] + !18 [ -1 ] + dup [ 1 ] and drop if [ 0 ] side [ $10000 ] + !18 then [ -1 ] + ; | br


: +pump ( nw-nw) [ -8 ] + ( @p+b!@p+@p+) [ $4b17 ] !18 | cr
[ $1 ] side dup !18 dup [ $10000 ] + !18 [ $12000 ] + !18 | cr
( !b!b.@p+) [ $9bb7 ] !18 ( w) dup [ -1 ] + !18 | cr
( dup-push-if) [ $24861 ] !18 ( @p+!b.unext) [ $5bb4 ] !18 ;
: +load ( w n nb nd) push push ( @p+a!.@p+) [ $4ab7 ] !18 ( a) over !18 ( n) [ -1 ] + !18 ( dup-push-if) [ $24861 ] !18 | cr
( @p+!+.unxt) [ $58b4 ] !18 pop pop +ram ;
: +post ( p @p+b!.@p+) [ $4bb7 ] !18 [ 1 ] side !18 [ 0 ] side !18 ( a!@p+push;) [ $2bdbd ] !18 ( p) !18 ;

{block 125}
( templates and load streams)
: 'pth ( current posn in path list of nodes.)
: nstream ( given addr of path tbl, nodes away, gives no of wire nodes and total stream length)
: ?path ( returns node number relative to current posn in selected path.)
: side ( gives adr of) $ 0 ( near,) $ 1 ( far side next node)
: /hdr ( starts a stream of given length; if odd, we leave out jump after waking 1st node.) | br


: +pump ( makes port pump thru next node; its ram load and init postamble must be out of w.)
: +load ( builds a program load from binary given node ram addr, word count, words to take from binary, and node number. caller must append any words not taken from binary.)
: +post ( follows a node's ram load to set b to out, a to in, and jump to) p.

{block 126}
( - umbilical plumbing) :var 'foc [0x102ffc12]
: using ( nn) wall port [ vport ] ! ;
: avail ( n-p) [ 1000 ] mod nn-n idle ; | br


: +path ( n'wn-n'w) dup [ 'pth ] +! negate u+ ; | br


: unfoc ( -a) [ 'foc ] assign [ 1 ] ?path avail ; unfoc ]
: foc ( -a) [ 'foc ] assign [ 0 ] side ; | br


: rip ( nw-nw) [ 0 ] u+ if ( post) [ -5 ] + +pump [ 1 ] +path rip [ -1 ] +path then [ 'foc ] xqt +post ;
: rips ( an-n'w) nstream over [ 13 ] * + [ 5 ] + /hdr rip
: hose ( nw) drop drop 0 ?path 1 ?path using [ wos ] !frame ; | br


: wire ( nw-nw) [ 0 ] u+ if ( wire) [ $16 10 + negate ] + +pump [ 1 ] +path wire [ -1 ] +path ( wire) $0 [ $16 ] dup [ 1602 ] +load [ 0 ] side +post ; ] then ( last) $0 [ $20 ] dup [ -1 ] + | , [ 1603 ] +load [ 1 ] side [ $12000 ] + !18 [ 0 ] side +post ;
: wires ( an-n'w) nstream over [ 18 ( lwire) $16 + ] * + [ 10 ( llast) $20 + ] + nop /hdr wire hose ;

{block 127}
( this block creates and destroys umbilical wiring within the chip.) | br


: using ( sets) vport ( between given pair of nodes.)
: avail ( is idle pc val for given node. the initial mod is to support multichip ide.) | br


: +path ( steps) pos ( to,) neg ( away from target.) | br


: wires ( builds wire for path table) [ a. ( entry zero is boot node.) n ( is number of nodes away from boot in path;) ] $ 0 ( no uut,) $ 1 ( no wire, uut is meighbor,) $ 2 ( neighbor is last guy,) $ 3 [ n-2 ( wire nodes then last guy. generates call at end of last guy pgm that last guy sends target for focus.)
: rips ( rips out a wire built by) wire
: foc ( sets) [ 'foc ( to leave ripped wires focused on ide boot node;) ] unfoc ( restores) [ 'foc ( to default.)

{block 128}
( - routing control)
: targets ( -a) [ act ] @ align tbl [ 0tg , 1tg , 2tg , ]
: paths ( -a) [ act ] @ align tbl [ here 0pa , 1pa , 2pa , | -cr : 'pths [ 0 + b-a ] ; | br


: path ( i) [ act ] ! paths dup @ swap [ 1 ] + @ wall port [ vport ] ! ;
: node ( n) [ 3 ] for i [ -1 ] + path paths targets @ + @ over or drop while next drop ; ] then pop drop drop ; | br


: -hook ( i) path targets @ [ 1 ] or drop if paths targets @ rips [ 1 ] targets ! then ;
: hook ( i n) swap -hook [ 2 ] begin over over paths + @ or drop while dup paths + @ [ 0 ] + drop -if drop drop ; ] then [ 1 ] + end then dup targets ! paths swap wires drop ; | br


: ?adj pop [ 1 ] + dup 4@ swap [ 4 ] + targets @ 1 or drop if push drop ; ] then + push ;

{block 129}
( these functions support route setup and selection for internal wiring.) | br


: targets ( table of target index variables.)
: paths ( table of route lists.) | br


: path ( selects active path) [ i ( 0,1,2)
: node ( selects path whose target is node) [ n | br


: -hook ( rips out any wiring on path) [ i
: hook ( hooks up path) [ i ( to node) n ( ripping out any old wiring on that path.) | br


: ?adj ( executes following word and exits defn if selected path is to adjacent node, otherwise skips following word.)

{block 130}
( - target anywhere)
: dor! align create [ $12005 , $0 , $0 , ]
: dor@ align create [ $12000 , $0 , ]
: dori align create [ $1200a , $0 , ]
: dorp align create [ $1200d , $0 , ]
: dorst align create [ $12010 , ]
: stak align create [ 40 rez | br


: r@ ( a-n) ?adj aa@ [ dor@ 1 + ] ! dor@ [ 2 ] fet [ 1 ] exch @18 ;
: r! ( na) ?adj aa! [ dor! 1 + ] ! [ dor! 2 + ] ! dor! [ 3 ] ok [ 1 ] exch ;
: call ( a) [ $10000 ] +
: rins ( w) ?adj ains [ dori 1 + ] ! dori [ 2 ] ok [ 1 ] exch ;
: lit' ( n) ?adj apsh [ dorp 1 + ] ! dorp [ 2 ] ok [ 1 ] exch ;
: aupd astk
: @stk @18 ( s) [ stak 1 + ] ! @18 ( t) [ stak ] ! [ stak 2 + ] 8 for @18 over ! [ 1 ] + next drop ;
: upd ?adj aupd dorst [ 1 ] stat [ 10 ] exch @stk ;
: lit lit' upd ;
: boot ( a n nd) nn-n swap push 2* 32768 + block over + swap begin over @ [ $15555 ] or over r! [ 1 ] + [ 1 ] u+ next drop drop ;

{block 131}
( these operations work on any target node.) | br


: dorx ( port templates for remote target.) | br


: r@ r! rins lit call ( are the specific names for the primitives using appropriate sequences for adjacent or remote target nodes.) | br


: boot ( loads code into current remote node from binary image for node) [ nd ( from addr) a ( in both image and ram for) n ( words.)

{block 132}
( - remote instructions)
: compile recompile ; | -cr : canon [ 138 ] ;
: focus paths targets @ + dup @ swap -1 + @ wall port call ;
: virgin paths targets @ + @ avail call ; | br


: rop ( n) [ $a ] or [ 13 ] for 2* next ( ;s) [ $1555 ] + rins upd ;
: @b [ $a ] rop ; | -cr : @a [ $b ] rop ; | -cr : @+ [ $9 ] rop ;
: !b [ $e ] rop ; | -cr : !a [ $f ] rop ; | -cr : !+ [ $d ] rop ;
: r+* [ $10 ] rop ;
: r2* [ $11 ] rop ; | -cr : r2/ [ $12 ] rop ;
: r- [ $13 ] rop ; | -cr : r+ [ $14 ] rop ;
: rand [ $15 ] rop ; | -cr : ror [ $16 ] rop ;
: rdrop [ $17 ] rop ; | -cr : rdup [ $18 ] rop ;
: rover [ $1a ] rop ;
: ra! [ $1f ] rop ; | -cr : ra@ [ $1b ] rop ;
: rb! [ $1e ] rop ; | br


: up $145 ; | -cr : data $141 ; | -cr : down $115 ;
: left $175 ; | -cr : ldata $171 ; | -cr : right $1d5 ;
: io $15d ;

{block 133}
( single instruction words that may be executed by the target. these must end with return for s40 restriction compliance.) | br

( the following won't work on s40 due to bug 1.)
: r@p+ [ $c ] rop ;
: psh ( n) r@p+ ( value) rins ;

{block 134}
( indicator panel) 135 load ( node stack / upd) | .s | br

( path, via, hops, tgt - green selected) | .pth | br

( mem dump / ?ram or ?rom) | .ram

{block 135}
( code for panel)
: panel [ 134 ] list ;
: .s blu silver cr cr [ stak 6 + ] 4 for dup @ 5 h.n space [ 1 ] + next [ -5 ] + cr 6 for dup @ 5 h.n space [ -1 ] + next drop ;
: ?color ( nn-nn) over over or drop if silver ; ] then green ;
: .pth blu [ act ] @ cr 3 for cr i [ -1 ] + path [ act ] @ ?color . paths dup [ 1 ] + @ . targets @ dup . + @ . next path ; | br


: /ram align create [ 64 a-b rez ]
: rsp ( n dup) 1 and drop if sp/2 then ;
: .ram blu silver cr [ /ram ] 64 for i [ 7 ] and ?zero drop if cr space then i rsp dup @ 5 h.n i 1 and drop if space then [ 1 ] + next drop ;

{block 136}
( - tester)
: ent 0 ;
: n6tst 0 64 6 boot ent call 0 r@ dup 123 + dup 0 r! 0 r@ or if abort then drop 0 r! ( upd) ;
: rot ( n-n) [ $3ffff ] and 2* [ $40000 ] /mod + ;
: sto ( n) dup [ 63 ] for rot dup i r! -next drop | cr
[ 63 ] for rot i r@ over over or | indent
     drop if i abort then drop -next drop ;
: pat ( n) [ 18 ] for dup sto rot next drop ;
: ramtst 0 sto $3ffff sto 1 pat $3fffe pat ;
: one ( n) [ 2 ] swap hook pause ( n6tst) ramtst ;
: ?ok ( n-t) [ 2pa @ nn-n ] or ;
: all ( n) nn-n [ 1 ] + for i [ -1 ] + ?ok drop if i [ -1 ] + n-nn one then next ;
: !dac ( n i) 2 swap hook $155 or io r! ;
: !dacs ( n) dup 709 !dac dup 713 !dac dup 717 !dac dup 617 !dac 117 !dac ;
: nn ( n-n) -1 + dup !dacs ;
: ms 100000 * for next ;
: watch begin upd pause 1000 ms key? end ;
: ?ram 0 | -cr : suck ( a) ra@ [ /ram ] 64 for over r@ over ! [ 1 ] + [ 1 ] u+ next drop drop ra! ;
: ?rom [ $80 ] suck ;

{block 137}
( this test routine tester loads and runs the code compiled for node 6 on all other nodes except the root, stopping if a node crashes or, possibly, other failure criteria are met) | br


: one ( runs the test routine from node 6 compilation, entry point) ent ( , on node) [ n ( . aborts if we cannot write and read back memory.) select desired path at start. ]
: all ( tries the test starting with node n and going down to node zero, skipping node 19.) | br


: watch ( displays live stack from current node. this and other interactive functions can be enabled in a running program by placing a definition like this in outer loop...)
: poll @b $200 and if up b! @b push ;' $15d b! then drop ; | br


: !dac ( sets given output value in node i)
: !dacs ( sets given value in all dacs.)

{block 138}
( - canonical words)
: -canon remember
: @ ( a-n) r@ ;
: ! ( na) r! ; ( call lit upd rins boot !b already ok)
: +* r+* ;
: 2* r2* ;
: 2/ r2/ ;
: - r- ;
: + r+ ;
: and rand ;
: or ror ;
: drop rdrop ;
: dup rdup ;
: over rover ;
: a! ra! ;
: a ra@ ;
: b! rb! ;

{block 139}
( the final step in loading the ide is to redefine the canonical forth words to operate on the target node. this is done as a separate step so that you may define any sort of exerciser before losing access to host colorforth words.)

{block 140}
( - ide ats support)
: zxch ( w n f n) push push dup # $2 ( +) # -2 ( and) [ vport ] @ pop /frame ( vport @) # $12000 ( + !18 dup -) # $1 ( and drop if vport @) # $10000 ( + !18 then) +frame [ wos ] !frame pop inser -stream ; | br


: dox align create ( @p call) [ $56a9 , ( arg) $0 , ]
: xchg ( cmd arg - result) [ dox 1 + ] ! [ dox ] ! dox [ $2 ] fet [ 1 ( exch) ] zxch @18 ; | br


: pfocus paths targets @ + dup @ swap -1 + @ wall port dup call lit rb! ;
: vtest ( arg.ent-ans) $5600 or swap xchg ;
: test ( arg-ans) $4 vtest ;
: tfocus ( port) $5636 swap [ $10000 ] + xchg drop ;
: creep $563a [ 67 ] xchg drop ;
: rip $5602 $20000 xchg drop ; | br


: zfocus ( node) paths targets @ + @ wall port | cr
$10000 or dup dup r! $5636 over r! dup dup r! | cr
lit' ra! ;

{block 141}
( this block interchanges ats commands with any node adjacent to the ide boot node.) | br


: pfocus ( must be used after booting package into an adjacent node and before using the following words. focuses that node properly on the boot node with both) p ( and) b ( -) [ note! after pfocus regular ide functions may not be done against nodes in this path until ] rip [ has restored them to ] warm [ state. | br


: tfocus ( performs ats focus function to select port thru which test and creep operate. use ide port names.)
: test ( executes test w/) [ arg ( giving positive) ans. ]
: creep ( creeps into focused node, making it active and changing current active to wire.)
: rip ( tears out ats connection to active node returning it and all wire nodes to warm states.) | cr

: zfocus ( used by hand in ide to effectively tfocus the ide node under test on a given tgt node) [ works whether or not r! preserves a

{block 142}
( - all-nodes tester)
: fwall ( -n) paths targets @ + dup @ swap [ -1 ] + @ wall ;
: fport ( -a) fwall port ;
: fbit ( -n) fwall align tbl | cr
( r) [ $8000 , ( d) $2000 , ( l) $800 , ( u) $200 , ]
: nodes ( -n) 0 begin [ 1 ] + | cr
dup paths + [ 1 ] + @ [ 0 ] + drop -until paths @ | cr
over paths + @ or drop if ; ] then [ -1 ] + ;
: !one ( i) [ 2 ] path 2 swap paths + @ hook | cr
0 64 [ 1604 ] boot fbit 2 r! # 6 14 call ;
: !all [ 2 ] path nodes # 40 for pause i !one next ;
: ?one ( i-f) [ 2 ] path 2 swap paths + @ hook pause | cr
$3e r@ # $1e100 $8d00 or $3f r@ # $17d $430e or +or drop if upd ?ram 0 dup or drop ; ] then 1 dup and drop ;
: ?all [ 2 ] path 0 nodes # 40 for 1 + pause dup ?one while next drop ; ] then pop drop ;
: zz for i next ;
: z 1 ?one upd ;

{block 143}
( manage running a test in all nodes)
: fwall ( returns rdlu for feeding node)
: fport ( returns port from feeding node.)
: fbit ( returns io mask bit for feed node write.)
: nodes ( returns number of nodes in current path.)
: !one ( programs and starts the node whose index is given in 1..nodes)
: !all ( programs all nodes in the current path.)

{block 144}
( arrayforth tm and okad tools and designs) | cr
( copyright 2009-2012 greenarrays, inc.) | cr
:var cuco [0x5] :var testb :var dh 0 dh ! | cr
:var first [0xffffffff] -1 first ! :var orgn 0 orgn ! ]
: compile [ 146 ] load ;
: recompile compile [ orgn ] @ load lis ;
: softsim | -cr : so [ 148 ] load ; | br


: -nat winver drop if ; ] then exit ;
: tbl ( i-n) pop 2/ 2/ + @ ;
: xqt ( a) @ push ; | -cr : assign ( a) pop swap ! ;
: ray ( i-a) pop 2/ 2/ + ;
: aray ( n) [compile] align call ray [ 4 ] * [ h ] +! ; | br

( ascii file names) 74 load | cr
( png screen capture) 168 load | cr
( qx) 80 load ( stack) 94 load ]
: -tape [ 1 ] 1 and ; ( for redacted systems) | br

( chip design) 190 3 loads mark empty | cr
( okad tools) # 198 ( load) # 900 ( load)

{block 145}
( main load block for okad2 applications)
: testb ( nonzero to enable testbeds.)
: dh ( holds drive handle we are responsible for.)
: first ( execution of hardsim or softsim. initializes variables in either.)
: recompile ( compiles f18 code then reloads tool that depends on it like ide from load block in) orgn.
: compile ( compiles relevant f18 code.) | br


: -nat ( exits a block if running on native system)
: tbl ( self fetching cell array. usage...)
: squared ( i-n) align tbl [ 0 , 1 , 4 , 9 , 16 , ]
: xqt ( calls the code whose adr is in the var given.)
: assign ( places addr of following code in the location given and exits current definition.) | br


: ray ( defines i-a array usage) align ray
: aray ( use after red to make ray of n cells)

{block 146}
( f18 compiler) empty c | cr
0 0 laid nns fill 0 0 kinds nns fill | br

1400 load | br


: reset ( a) ?rst [ com ] @ resets ! ;
: kind ( n) [ com ] @ kinds ! ;
: node ( nn) nn-n nns mod dup [ com ] ! 0 -org | cr
node's 64 eras n-nn @rom load ;
: bin ( nn) 0 memory swap nn-n [ com ] ! 0 memory 64 move ; | br


: program [ nns -1 + ] for i [ com ] ! | cr
i idle reset i n-nn @rom load -next | cr
( special rom's) [ 1304 ] load | cr
-tape drop if [ 150 ] load then ; | br

1402 6 loads target 1380 load host ]
: h' ' ; | -cr : ' h' 6 + 4@ ;
: reclaim remember [ target program empty

{block 147}
( compiles all relevant f18 code.) | br


: laid ( is cleared for setting as nodes laid out)
: resets ( is set to default multiport executes for all nodes and may be overridden in source code using) reset
: kinds ( is set to default testbed none and may be overridden with) kind ( to 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers)
: node ( starts random compilation for node) [ nn ( by compiling node) nn's ( rom)
: bin ( saves the binary just generated in the bin for node) [ nn, ( which must be outside chip) # 0 # 0 ( .)
: program ( compile code for multicomputers. always compiles standard rom; if not tapeout, the load block at) # 1300 ( defines test environment which may be in rom, ram, or both.)
: reclaim ( remembers and restores dictionary)

{block 148}
( f18 software simulator) empty compile | , ( demo bootstream) 1242 load empty | , ( prelude) 1250 load ( boot descriptors) 1236 load | , ( engine) 1252 8 loads ( opcodes) 1268 4 loads | , ( boot loader) 1238 load | , ( display) 1276 6 loads 1248 load 1288 2 loads | , ( preserve variables) :var nmem :var n2mem
: nm2m [ nod2 ] @ !node [ n2mem ] @ mem ! | , | ... [ nod ] @ !node [ nmem ] @ mem ! ; :var big [0x2]
: puka ( nn-a) nn-n 2* $8000 + block ;
: code ( nn nn) puka push puka pop 64 move ; | , ( keyboard) 1292 2 loads | , ( ports and pins) 1296 2 loads | , ( interactive) 1240 load | , | ,
: /softsim 0 [ time ] ! power | , [ first ] @ 1 + if drop nm2m ; ] then # 0 [ first ] ! | , 100 [ big ] ! 1 [ gap ] ! -1 [ wind? ] ! | , [ 100 ] !node [ 0 ] mem ! [ 100 ] other | , [ 0 ] !node [ 0 ] mem ! [ 0 ] node 0 [ xo ] ! 0 [ yo ] ! !vis ; | , | , ( init and testbeds) 216 load | , ( start) /softsim ok h

{block 149}
( comment demo bootstream if you are going to be generating your own for simulation.)

{block 150}
( test code for chip) reclaim | br

( ide parts) 1372 5 loads reclaim | cr
( all nodes) 1350 load reclaim | br

( ats tests) 480 load reclaim | br

( polyforth) 360 load reclaim | cr
( eforth) 1080 load reclaim | br

( applic code) 200 load | br



{block 151}
( this block defines what) ] compile ( does.) | cr
( the system code loaded at the start is used by common development tools and should generally be left alone. it goes into bins 1600..2317 as follow) | br

# 1600 ( ide code code; spi r/w/boot) | , # 1700 ( polyforth) | , # 1800 ( ---; temp sram for eforth.) | , # 1900 ( ats/ide; ---) | , # 2000 ( creeper modules) # 1 ( full) | , # 2100 ( creeper modules) # 2 ( full) | , # 2200 ( creeper modules) # 3 ( half) | , # 2300 ( creeper modules) # 4 ( reserved) | , | , ( note that special rom leaves residue in 008 and 106.)

{block 152}
( redact okad disk) audit load | br

( to arm this block, make) | cr
( this word white...) exit | br

( okad) 196 1244 obliterate | br

( type save to commit changes)

{block 153}
( load this block to redact an okad disk for public release or extensive programming.) | br

] additional housekeeping... | cr
[ 144 ( comment loading of okad application.) | cr
18 ( uncomment loading of application tools.) | cr
196ff ( merge in released pd software.)

{block 154}
( c-a-c - ascii for gds only!) macro ]
: 1@ $8a 2, ; forth ]
: string pop ;
: cf-ii string [ $6f747200 , $696e6165 , $79636d73 , $7766676c , $62707664 , $71757868 , ( 336a7a6b) $33323130 , $37363534 , ( 2d313938 - 2d7a3938) $5f7a3938 , ( 2f322e30) $2f6a2e6b , ( 2b213a3b) $24213a3b , $3f2c2a40 , ]
: ch $fffffff0 and unpack [ cf-ii ] + 1@ $ff and ;
: ii-cf string [ $2a00 , ( 0 +) $2b , $2b2d0000 , $2725232e , ( zjk 1b262224) $1b1a1918 , $1f1e1d1c , $28292120 , $2f000000 , $3a43355c , $3d3e3440 , ( 02 484a3744 kj) $54523744 , $3336393c , $38314742 , $3f414632 , ( 1 493b45 z) $563b45 , ( -) $23000000 , $a13052c , $d0e0410 , ( 02 181a0714 kj) $24220714 , $306090c , $8011712 , $f111602 , ( 1 190b15 z) $260b15 , ]
: chc $ffffffe0 + [ ii-cf ] + 1@ $ff and ;

{block 155}
( colorforth to/from ascii w/gds specifics) | br


: cf-ii ( otr inae ycms wfgl bpvd quxh) | indent
     ( 3210 7654 -j98 /z.k +!'; ?,*@)
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ?) | indent
     ( cba@ gfed 02ih onml srqp wvut) | indent
     ( 1yx cba@ gfed 02ih onml srqp wvut 1yx)
: notice [ j and z transposed in cf-ii; - converts to underscore, + to dollar.

{block 156}
( big letters) macro ]
: *byte $c80f 2, ; forth ]
: clr [ aper 2 + ] ; :var sz [0xe] :var cur [0x5ee010] 14 sz ! ]
: ptab ( xy) 1024 * + [ aper @ 4 / ] + [ cur ] ! ;
: center ( n) [ sz ] @ -24 * 768 + 2/ ptab ;
: table 12 * [ 12 block ] + ;
: 1line ( a) [ sz ] @ for [ clr ] @ over ! 1 + next drop ;
: pix ( a) [ sz ] @ for dup 1line 1024 + next drop ;
: row ( an-an) 16 for dup and -if over pix then [ sz ] @ u+ 2* next 1024 [ sz ] @ * [ sz ] @ -16 * + u+ ;
: !emit table [ cur ] @ 12 for over @ *byte row row drop 1 u+ next drop drop [ sz ] @ 18 * [ cur ] +! ;
: !digit 24 + !emit ;
: 2. ( nn) /mod !digit !digit ;
: 4. ( n) 100 /mod 10 2. 10 2. ;

{block 157}


{block 158}
( big clock) empty 40 load 156 load ]
: hm sec 60 /
: sex ( n) 60 /mod 100 mod 10 2. 10 2. ; :var t0 [0x7eca]
: ?beep if ; ] then beep ;
: till [ t0 ] @ sec negate + green -if negate red then ?beep sex ;
: set ( n) 60 * sec + [ t0 ] !
: ok show black screen blue 0 center hm ( till) ;
: run dup pause drop key? run ; ok run

{block 159}


{block 160}
( compare) empty 30 load ]
: n18 ( i-a) [ abuf 18 + block ] + ;
: unpk abs [ 1 n18 ] ! [ abuf 36 + ] block [ cbuf ] block [ 1404 ] blks move [ cbuf block ] abuf 36 + [ 3 n18 ] @ [ -36 ] + range ;
: check [ abuf ] @back [ 0 n18 ] @ [ 18 block @ ] or drop if ; ] then [ 1 n18 ] @ dup and -if unpk ; ] then drop ;
: blink dup [ abuf ] + [ blk ] ! edit ;
: var push push 1 + 1 u+ pop pop
: *1 or ;
: *2 var push over @ over @ or pop + ;
: tag ( nn-n) dup $f and jump *1 *1 *2 *1 *1 *2 *1 *1 *1 *1 *1 *1 var *1 *1 *1
: co ( naa-n) 256 for over @ over @ tag drop if drop drop pop drop pop drop dup 2 u+ ( i) pop swap blink ; ] then 1 + 1 u+ next drop drop ;
: com ( n) dup block over [ abuf ] + block co ;
: q ( nn) for com 2 + next drop ;
: all 18 [ 1439 -18 + 2/ ] q ;
: old [ blk ] @ [ abuf ] mod dup [ abuf ] + [ blk ] ! copy ;

{block 161}

: check ( reads backup to) # 3000 ( and decompresses if appropriate)
: blink ( displays the given block with its other set as the editor's 'other' block)
: var ( compares a variable name, advancing pointers to skip its value.)
: *1 ( compares garden variety words.)
: *2 ( compares large literals.)
: tag ( compare compares the two source cells given, returning true if they differ. ignores variable differences.)
: ?nul ( ends the loop in co when nuls are found in both blocks.)
: co ( given the addresses of the two blocks does the work of com.)
: com ( invokes editor to blink the given block if it differs from the other, leaving stack set to continue the scan by typing q. otherwise returns.)
: all ( scans the whole usable area of the disk.)
: q ( scans for differences given starting block and number of source blocks skipping shadows.)
: note! ( return stk probably grows!)

{block 162}


{block 163}


{block 164}


{block 165}


{block 166}


{block 167}


{block 168}
( png empty) -nat :var w [0x400] :var hh [0x300] :var d [0x1]
: frame # $1d0000 [ aper @ 4 / ] ; 172 load 174 load ]
: -crc ( a) here over negate + crc .. ;
: here/4 ( -a) here 3 and drop if 0 1, here/4 ; ] then here 2 2/s ;
: bys ( nn-b) .. here swap , ; | cr
( pallettes) 170 load | br


: !png ( awh-an) [ d ] @ / [ hh ] ! [ d ] @ / [ w ] ! here/4 swap $474e5089 , $a1a0a0d , ( ihdr) $52444849 13 bys [ w ] @ .. [ hh ] @ .. $304 , $0 1, -crc ( plte) pallette ( idat) $54414449 0 bys swap deflate -crc ( iend) $444e4549 0 bys -crc here/4 over negate + ; | br


: 'at ( xy-a) 1024 * + [ frame ] + ;
: full 1 [ d ] ! 0 dup 'at 1024 768 !png ;
: png full wgds ;

{block 169}

: d ( is reduction factor)

{block 170}
( - pallettes)
: paper $45544c50 48 bys | cr
$ffffff 3, $c00000 3, $c000 3, $c0c000 3, | cr
$c0 3, $c000c0 3, $c0c0 3, $404040 3, | cr
$c0c0c0 3, $ff0000 3, $ff00 3, $ffff00 3, | cr
$ff 3, $ff00ff 3, $ffff 3, $0 3, -crc ; | br


: crt $45544c50 48 bys | cr
$0 3, $c00000 3, $c000 3, $c0c000 3, | cr
$c0 3, $c000c0 3, $c0c0 3, $404040 3, | cr
$c0c0c0 3, $ff0000 3, $ff00 3, $ffff00 3, | cr
$ff 3, $ff00ff 3, $ffff 3, $ffffff 3, -crc ; | br


: pallette ( paper) crt ;

{block 171}


{block 172}
( - crc) :var ad1 [0x39f8] :var ad2 [0xc60b] macro | br


: 2/s ?lit $e8c1 2, 1, ; | -cr : 1@ $8a 2, ; forth ]
: bit ( n-n) 1 ? if 1 2/s $edb88320 or ; | indent
     ] then 1 2/s ;
: ,crc ( nn) for dup 8 for bit next , | indent
     1 + next drop ;
: table ( -a) align array [ 0 256 ,crc ]
: crc ( bn-n) -1 swap for over 1@ over or $ff and table swap 8 2/s or 1 u+ next - nip ; | br


: +adl ( n) $ff and [ ad1 ] @ + dup [ ad2 ] @ +
: adl! [ ad2 ] ! [ ad1 ] ! ;
: +mod [ ad1 ] @ 65521 mod [ ad2 ] @ 65521 mod adl! ;

{block 173}

: 2/s ( shift right by literal)
: 1@ ( fetch byte, address in eax)
: array ( return word address in dictionary)
: bit ( process 1 bit with standard 32-bit crc)
: fill ( construct crc table for bytes)
: table ( said table)
: crc ( compute crc for a byte string)
: ad1/ad2 ( adler checksums)
: +adl ( add a byte to both checksums)
: adl! ( store checksums)
: +mod ( truncate checksums)

{block 174}
( - lz77) macro | -cr : *byte $c486 2, ;
: !bx [compile] a! $289 2, [compile] drop ; forth | br


: *bys dup 16 2/s *byte swap $ffff and *byte $10000 * + ; | -cr : .. *bys , ;
: 0/1 $80 ? if $7e and $7e or drop if 7 ; ] then $f ; ] then 0 and ;
: 4b dup 0/1 $9 and over 8 2/s 0/1 $a and +or swap 16 2/s 0/1 $c and +or ;
: pix dup @ [ d ] @ u+ 4b ;
: row 1, dup [ w ] @ 2/ dup 1 + dup 2, - 2, 0 dup 1, +adl for pix 16 * push pix pop or dup 1, +adl next drop +mod [ d ] @ 1024 * + ; | br


: deflate $178 2, 1 0 adl! [ hh ] @ -1 + for 0 row next 1 row drop [ ad2 ] @ *byte 2, [ ad1 ] @ *byte 2, here over 4 + negate + *bys over -4 + !bx ;

{block 175}

: 0/1 ( 0, f or 7 for dark, bright or dim)

{block 176}
( cf-html) empty -nat | cr
:var pad [0x109e4000] abuf block 4 * pad ! | cr
:var hld [0x109ebe78] pad @ hld ! 178 6 loads ]
: estyle ,link ,t1cr ( cfhtml.css '?) ;
: .hdr [ pad ] @ [ hld ] ! ,t1cr ( @html? @head?) istyle | cr
( estyle) ,t1cr ( @/head? @body? @table?) ;
: .blk ( n) 0 [ pos ] ! crlf ,t1 ( @td*class+cf?) | cr
dup even? if dup .dec ,t1cr ( *list) then | cr
.cr block ,t1 ( @code) 0 [ class ] ! 0 [ --cr ] ! | cr
begin @+ dup and while .token end then | cr
[ class ] @ eq? if ,t1 ( ?) then drop drop | cr
begin -eol? while .nb end then .cr | cr
,t1 ( @/code?) .cr ,t1cr ( @/td?) ;
: .sep ,t1 ( @td?) .nb .nb ,t1 ( @/td?) ;
: .blks ( first last+2) over negate + 2/ for | cr
,t1 ( @tr?) dup 1 or .blk .sep dup .blk | cr
,t1cr ( @/tr?) [ 2 ] + next drop ;
: .tlr ,t1cr ( @/table? @/body? @/html?) sav ;
: run ( first last+2) .hdr .blks .tlr ; | br

named ( cf.html) exit 18 1440 run

{block 177}
( colorforth to html utility) | br

( the html is created between) pad ( and) hld | cr
( by) ] .html ( and its factors) .hdr .blks ( and) .tlr ( , then written to the file last) [ named ( .) | br

( uncomment) ] estyle ( in) .hdr ( to use an external) | cr
( stylesheet, maybe for printing.) | br

( pairs of blocks are formatted 2-up using html tables, with the odd/even blocks used to invoke) [ .html ( or) .blks ( displayed on the right. 'n list' is shown above the even block.) | br

176 188 .html ( puts shadows on left, while) | cr
177 189 .html ( puts them on the right.) | br

seeb ( toggles blue-word visibility.) | br

( the last line of each block is filled) | cr
( with) ] nbsp ( for column alignment. the) [ class ] @ | cr
( line closes the) [compile] code ( tag of an empty block.)

{block 178}
( - generate html details) | cr

: eq? ( nn-n) over or if drop -1 then - ( nz? ;)
: nz? ( n) dup and drop ;
: even? ( n) $1 or $1 and drop ; | br


: @+ ( a-an) dup 1 + swap @ ;
: @tag ( a-at) dup @ $f and ; | br


: sc $3b ( semicolon)
: ch, ( c) [ hld ] @ 1! 1 [ hld ] +! ;
: lb $7b ( left-brace) ch, ;
: rb sc $7d ( right-brace) ch,
: crlf 13 ch, 10 ch, ; | br


: ,token ( n) ch if ch, ,token ; ] then drop drop ;
: ,word ( a-a) begin @+ ,token @tag drop until ; | cr
( loop) ] begin ,word
: ,comments ( a) @tag 9 or drop until drop ; macro | cr

: ,t ( words) 7push pop [compile] ,lit call ,comments nop ;
: ,trb ( words) [compile] ,t call rb nop ;
: ,t1 ( words) call set1 [compile] ,t call set0 nop ;
: ,t1cr ( words) [compile] ,t1 call crlf nop [ forth

{block 179}

: eq? | -cr : nz? | -cr : diff? | -cr : even? ( leave only flags) | cr

: @+ | -cr : @tag ( are common factors) | br

( the following words generate ascii text only for html tags and source formatting; it will not be visible in the html display.) | br


: sc | -cr : ch, | -cr : lb | -cr : rb | -cr : crlf ( punctuation output) | br

( the macros enable in-line output from the) | cr
( standard cf-ascii table using) [ set0 ( default or the extended table using) set1 | br


: ,token ( output ascii characters for one token)
: ,word ( output a token and any extension tokens)
: ,comments ( output contiguous comment words) | br


: ,t ( output from current set, don't change set.)
: ,trb ,t ( output followed by) rb
: ,t1 ( output from) set1 ( , return to) set0 ( at end)
: ,t1cr ,t1 ( output followed by) crlf

{block 180}
( - translate text and numbers) :var pos :var --bs [0x1]
: -bol? [ pos ] @ nz? ; | *
: -eol? [ pos ] @ 46 or drop ;
: .cr ,t1 ( @br?) 0 [ pos ] ! ; | , ( loop) ] begin .cr | *
: emit ( c) ch, 1 [ pos ] +! ;
: .ch ( c) -eol? until emit ;
: .sp -eol? if -bol? if $20 emit ; ] then then ;
: .2sp .sp | *
: .nb $26 ( ampersand) .ch ,t ( nbsp) sc ;
: ?sp [ --bs ] @ nz? if .sp then 1 [ --bs ] ! ;
: -sp 0 [ --bs ] ! ;
: .sp.tn ( n) ?sp ( .tn ;)
: .tn ( n) ch if .ch .tn ; ] then drop drop ;
: ?ch ( n) ?seeb if .ch ; ] then drop .nb ;
: ?sp.tn ( n) ?sp ( ?tn ;)
: ?tn ( n) ch if ?ch ?tn ; ] then drop drop ;
: .hd ( n) [ -10 ] + -if [ $3a ] + .ch ; ] then [ $41 ] + .ch ;
: .dec ( n .sp) ?sp [ 0 ] + -if $2d .ch negate then [ -1 ] swap begin [ 10 ] /mod dup and while end then drop
: spit ( -1 ...) begin .hd [ 0 ] + -until drop ;
: hd ( n-nn) dup [ $f ] and swap 2/ 2/ 2/ 2/ ;
: .hex ( n .sp) ?sp [ -1 ] swap begin hd $fffffff and | , while end then drop spit ;
: .ad/s ( n) 1024 /mod swap hd hd hd drop ?sp | , dup and if dup .hd then drop .hd .hd | , [ 0 ] + if [ 47 ] .ch dup .hd then drop ;

{block 181}
:var pos ( character display) pos ( ition in line)
: -bol? | -cr : -eol? ( test position)
: .cr ( visible crlf)
: emit ( visible character)
: .ch | -cr : .sp | -cr : .2sp | -cr : .nb ( quirky characteristics) | cr
[compile] note [ .sp ( does nothing at left margin) | cr
[compile] note .ch ( does) .cr ( after 46th character) | cr
[compile] note .2sp ( takes only one space at left margin) | cr
[compile] note .nb ( takes only one character position.) | br


: .tn | -cr : .sp.tn ( display a token.) | br


: .hd | -cr : hd | -cr : spit ( are number-output factors)
: .dec | -cr : .hex | -cr : .ad/s ( display numbers)

{block 182}
( - translate cf token details) | cr
:var class [0x2d200009] :var --cr
: ,class ( a) @ [ class ] @ over or drop ( diff?) if | cr
[ class ] @ nz? if ,t1 ( @/code? @code) then | cr
,t1 ( *class+) dup [ class ] ! ,token ,t1 ( ?) ; | cr
] then drop ; macro ]
: ,c 7push pop [compile] ,lit call ,class nop ; forth ]
: .quirks ( n) [ --bs ] @ -1 + nz? if 1 [ --bs ] ! drop ; | , | ... ] then [ --cr ] @ nz? if .2sp drop 0 [ --cr ] ! ; | , | ... ] then ( class) nz? if -bol? if .cr then then ;
: .space -eol? if .nb then ;
: .indent .cr # 4 2 for .nb next ;
: .blue ( n) ?seeb if dup .sp.tn then | , $9080000e ( cr) eq? if .cr drop ; | , ] then $e721000e ( -cr) eq? if 1 [ --cr ] ! drop ; | , ] then $8625920e ( space) eq? if .space drop ; | , ] then $76c08c4e ( indent) eq? if .indent drop ; | , ] then $c620000e ( br) eq? if .cr .cr then drop ;
: ?simple ( n-n) | , | ... $fc00000e eq? if ?tn .cr pop drop ; ] then | , | ... $fa00000e eq? if ?tn -sp pop drop ; ] then | , | ... $ea00000e eq? if ?sp.tn -sp pop drop ; ] then | ... $ebd4000e eq? if ?sp.tn -sp pop drop ; ] then | ... $ebd7a80e eq? if ?sp.tn -sp pop drop ; ] then ;

{block 183}
:var class ( current class) | cr
:var --cr ( true suppresses) cr ( before next red word) | cr

: ,class | -cr : ,c ( class defining words, cf style) | br


: .quirks ( handle the spacing before red words) | br


: .space ( blue spaces are ignored at eol!)
: .indent # 4 ( + html leading space) | br


: .blue ( generate most of the blue-word effects)

{block 184}
( - translate cf tokens)
: sh? ( n-n) 2/ 2/ 2/ 2/ dup 2/ swap 1 and drop ;
: lh? ( an-an) push @+ pop $10 and drop ; | br


: .t1 ( n) ,c ( t1) .sp.tn ;
: .t2 ( an-a) lh? if ,c ( h2) .hex ; ] then ,c ( d2) .dec ;
: .t3 ( n) [ class ] @ ,c ( t3) .quirks ( .sp.tn) .tn ;
: .t4 ( n) ,c ( t4) .sp.tn ;
: .t5 ( an-a) lh? if ,c ( h5) .hex ; ] then ,c ( d5) .dec ;
: .t6 ( n) sh? if ,c ( h6) .hex ; ] then ,c ( d6) .dec ;
: .t7 ( n) ,c ( t7) .sp.tn ;
: .t8 ( n) sh? if ,c ( h8) .hex ; ] then ,c ( d8) .dec ;
: .t9 ( n) ,c ( t9) .sp.tn ;
: .ta ( n) ,c ( ta) .sp.tn ;
: .tb ( n) ,c ( tb) .sp.tn ;
: .tc ( an-a) ,c ( tc) .sp.tn ,c ( dc) @+ .dec ;
: .td ( n) sh? ,c ( hd) .ad/s ;
: .te ( n) ,c ( te) ?simple .blue ;
: .tf ( n) sh? if ,c ( hf) .hex ; ] then ,c ( df) .dec ; | br


: .token ( an-a) dup $f and jump | cr
.tn .t1 .t2 .t3 .t4 .t5 .t6 .t7 | cr
.t8 .t9 .ta .tb .tc .td .te .tf

{block 185}

: sh? ( extract short number, true flag if hex)
: lh? ( extract long number, true flag if hex) | br

( tag ------- cf class ------- html class) | cr
[compile] .t0 ( extension token ........) [compile] same [compile] as [compile] last
: .t1 ( execute word ...........) [ t1
: .t2 ( execute long number ....) [ h2, d2 ]
: .t3 ( define word ...........) | -cr : t3
: .t4 ( compile word ...........) t4
: .t5 ( compile long number ....) h5, d5
: .t6 ( compile short number ...) h6, d6
: .t7 ( compile macro ..........) [compile] t7
: .t8 ( execute short number ...) [ h8, d8 ]
: .t9 ( lowercase text comment . t9)
: .ta ( capitalized text comment ta) [compile] deprecated
: .tb ( uppercase text comment . tb) [compile] deprecated
: .tc ( variable ...............) :var tc dc
: .td ( target address ......... hd)
: .te ( editor command .........) [compile] te
: .tf ( short number comment ... hf, df) | br


: .token ( translate tag-by-tag) | indent
     [compile] note ( address may be incremented)

{block 186}
( - stylesheet details and file output)
: vat ,t ( *vertical-align; top) sc ;
: bcw crlf ,t ( *background-color; white) sc ;
: wsn crlf ,t ( *white-space; nowrap) sc ;
: fo ,t ( *font-) ;
: ffm crlf fo | indent
     ,t ( family; lucida*console,monospace) sc ;
: fwb crlf fo ,t ( weight; bold) sc ;
: fz fo ,t ( size;) ;
: fc lb ,t ( *color;) $23 ( sharp) ch, ;
: fsi sc fo ,t ( style; italic) rb ;
: tt sc ,t ( *text-transform;) ; | br


: ,link ,t1 ( @link *rel+stylesheet) | indent
     ,t1 ( *type+'text/css' *href+') ; | br


: fopen ( af-h) push push 0 32 ( exist) 2 0 0 | indent
     pop pop swap fcreate ;
: sav [ 0 fnam ] w/o fopen dup push | indent
     [ pad ] @ dup negate [ hld ] @ + pop | indent
     fwr drop fclose ;

{block 187}

: vat | -cr : bcw | -cr : wsn | -cr : fo | -cr : ffm | -cr : fwb | -cr : fz | -cr : fc | -cr : fsi | -cr : tt | cr
( space-saving factors of internal stylesheet) | br


: ,link ( most of the external stylesheet link) | br


: fopen | -cr : sav ( open, write, close html file) | cr
[compile] note ( byte addresses throughout)

{block 188}
( - internal stylesheet)
: istyle ,t1cr ( @style*type+'text/css'?) set1 | cr
,t ( td) lb vat bcw wsn ffm fwb fz ,trb ( x-large) ,t ( code) lb fz ,t ( large) tt ,trb ( lowercase) | cr
,t ( .t1) fc ,trb ( ddaa00) | cr
,t ( .h2) fc ,t ( aa7700) fsi | cr
,t ( .d2) fc ,trb ( ddaa00) | cr
,t ( .t3) fc ,trb ( ff0000) | cr
,t ( .t4) fc ,trb ( 00cc00) | cr
,t ( .h5) fc ,t ( 009900) fsi | cr
,t ( .d5) fc ,trb ( 00cc00) | cr
,t ( .h6) fc ,t ( 009900) fsi | cr
,t ( .d6) fc ,trb ( 00cc00) | cr
,t ( .t7) fc ,trb ( 00cccc) | cr
,t ( .h8) fc ,t ( aa7700) fsi | cr
,t ( .d8) fc ,trb ( ddaa00) | cr
,t ( .t9) fc ,trb ( 444444) | cr
,t ( .ta) fc ,t ( 000000) tt ,trb ( capitalize) | cr
,t ( .tb) fc ,t ( 000000) tt ,trb ( uppercase) | cr
,t ( .tc) fc ,trb ( ff00ff) | cr
,t ( .dc) fc ,trb ( 00ff00) | cr
,t ( .hd) fc ,t ( bbbbbb) fsi | cr
,t ( .te) fc ,trb ( 0000ff) | cr
,t ( .hf) fc ,t ( 777777) fsi | cr
,t ( .df) fc ,trb ( 444444) ,t1cr ( @/style?) ;

{block 189}

: istyle ( internal styles are aimed toward) | cr
( providing code examples for stand-alone use in other documents. although it's black-on-white, it faithfully displays the colorforth screen.) | br

( some cf-html rendering tests) | br

[ load 2147483647 $80000000 ]
: t1 ; ] 2147483646 $80000001 87 $57 [compile] ?lit [ 87 $57 ( rtoeani rtos ascii) :var var [0x7b] | cr
| -cr : quirky = $5 | indent
     # 87 # $57 [ -87 ( end) $0 ] $0 # $0

{block 190}
( ga144 chrt .18 design specific)
: gdsnos [ 440 ] ;
: nnx # 8 [ 18 ] ; | -cr : nny # 4 [ 8 ] ; | -cr : nns [ nnx nny * ] ;
: nnc ( nns) [ nns 2 * 144 + ] ;
: nn-n ( n-n) # 10 [ 100 ] /mod [ nnx ] * + ;
: n-nn ( n-n) [ nnx ] /mod # 10 [ 100 ] * + ; | br


: gapl [ 2 ( strap) 5 + ( pwr) 0 + ( chans) 20 2 * + ] ;
: gapr [ 2 ( strap) 5 + ( pwr) 0 + ( chans) 24 2 * + ] ;
: gapb [ 2 ( strap) 5 + ( pwr) 0 + ( chans) 28 2 * + ] ;
: gapt [ 2 ( strap) 5 + ( pwr) 0 + ( chans) 18 2 * + ] ;
: ray0 ( -xy) gapl [ 199 ] + gapb [ 199 ] + ;
: rayn ( -xy) nnx [ 350 ] * nny [ 759 ] * -1 + ray0 v+ ; | br


: gx [ rayn drop gapr + 199 + ] ;
: gy [ rayn nip gapt + 199 + ] ; | br


: origin # 164 # 89 26 26 ;
: cx [ origin drop 2 * gx + 2 + ] ;
: cy [ origin nip 2 * gy + 2 + ] ;
: -cx [ cx negate ] ; | -cr : cx*y [ cx cy * ] ; | br


: gfx [ 8 ] ; | -cr : gfy [ 16 ] ;

{block 191}

: gdsnos ( block for gds layer numbers)
: nnx ( and nny number of nodes/row and /column)
: nnc ( number of nodes compiled)
: nn-n ( and) n-nn ( convert yx notation to and from linear node numbers)
: gapl, r, b, t ( distance in tiles between inner edge of padring bus and outer edge of core pwr)
: ray0 ( and) rayn ( are gxy relative phys origin and upper right corner of node array. source of constants is) [ xtab ( and) ytab. ]
: gx ( and) gy ( bounds of pad ring.) [ always remember to check ] global [ reset wiring when size or placement of node array or pad ring are changed! ]
: cx ( and) cy ( bounds of seal ring.)
: -cx ( negative tiles/row)
: origin ( origin of 'die' i.e. pad ring within seal ring. c coords rel to seal; g rel to 'die')
: gfx ( and) gfy ( fill cell grid)

{block 192}
( ga144 pads, ports and resets) | br


: port ( i-pa) align tbl [ $1d5 , $115 , $175 , $145 , $195 , $185 , $1b5 , $1a5 , ]
: idle ( n-p) [ nnx ] /mod [ nny -1 + ] mod [ 1 ] min [ 4 ] + swap [ nnx -1 + ] mod [ 1 ] min 2* + port ;
: rstadr align tbl [ $aa , $195 , $185 , $1b5 , $1a5 , ]
: rstdef strings ( p0aa p13f p12f p11f p10f)
: ?rst ( pa-i) [ 4 ] for dup i rstadr or while drop -next abort then drop drop pop ;

{block 193}

: port ( returns port for 0-3 rdlu then edges)
: idle ( is idle p value for given node.)
: rstadr ( and) rstdef ( number values and white names of p straps rom, corn, side, top/bot, mid.)
: ?rst ( returns index of valid reset or aborts.)

{block 194}
( ga144 node types) | br


: laid [ nns aray | -cr : resets [ nns aray ]
: kinds [ nns aray | br


: 0's ( n) for 0 , next ;
: +roms ( -ia) align ray [ nns 0's ]
: iz ( nn i) swap nn-n +roms ! ; | cr
701 2 iz 705 10 iz 708 6 iz | indent
     709 14 iz 713 14 iz 717 14 iz | cr
117 14 iz 617 14 iz | cr
1 2 iz 200 18 iz 300 4 iz | cr
( eforth) 105 20 iz 106 20 iz ( sdram...) | cr
7 20 iz 8 20 iz 9 20 iz 107 20 iz 108 20 iz ]
: @rom ( nn-n) nn-n +roms @ [ 22 ] less if drop [ 1418 ] + ; ] then drop [ 100 ] mod [ 1301 ] + ; | br


: bedtab ( -serbed) [ cuco ] @ nn-n kinds @ ;
: ?serbed [ testb ] @ 0 or drop if bedtab ; ] then 0 ;

{block 195}

: laid ( nz if node laid out)
: resets ( index of reset address)
: kinds ( kind for testbeds)
: +roms ( and) @rom ( are here only as temporary kludges. we will eventually load a table from the node defns for default kind and prom source.)
: +roms ( array indexed by linear node number returning code number for rom load block.)
: iz ( sets node) [ nn ( to use rom load block) n ( codes- 0-arith 2-serdes 4-syncboot 6-async 10-spi 14-analog 18-1wire)
: @rom ( returns block number for production rom code applicable to the given node.)
: ?serbed ( 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers for) [ cuco ( if) testb ( nz.)

{block 196}


{block 197}


{block 198}


{block 199}


{block 200}
( user f18 code) reclaim | br

( softsim example) reclaim 0 node 1342 load | cr
( practical example pwm code) reclaim 842 load | br

( sha256 reclaim) # 900 # 5 ( loads) | , ( greg n1 object) # 950 ( load)

{block 201}
( use this load block to compile your code) | cr
( for the f18 computers.) | br

( as delivered, sample code loaded here is pro- vided to facilitate working with examples) | cr
( presented in the user's guide. it may be) | cr
( deleted if you no longer have use for it.)

{block 202}
( ga application tools)
: a-com # 3 [ 9 # 6 ] ; | *
: a-bps 921600 # 480000 ;
: c-com [ 5 # 8 ] ; | *
: c-bps 921600 ;
: host 206 ; | *
: target 208 ; | , ( modules) | *
: sram [ 264 ] ; | *
: pf [ 360 ] ; | *
: ether [ 720 ] ; | , ( utils) | *
: streamer [ 282 ] ; | *
: loader [ 210 ] ; | , | ,
: selftest ( port) [ 708 ] load ; :var stp [0x3]
: autotest ( port) [ 712 ] load ;

{block 203}
( these definitions are used in released code or documented procedures and shouldn't be changed or overloaded casually.) | br


: a-com ( and) c-com ( are com port numbers for eval board usb ports a and c.)
: a-bps ( and) c-bps ( are baud rates to which ide) | cr
( sets these usb ports.)
: host ( and) target ( load block numbers for serial ide configured to work with eval board host or target chips using default usb ports.) | br

[ definitions for getting started app note ]
: selftest ( runs ats selftest on either chip via the ide com port number given.)
: autotest ( given host ide com port number, runs ate tests of target chip using sync boot. then tests) [ serdes ( between the chips.)

{block 204}
( - user application tools)

{block 205}
( this is the place to compile definitions that you wish to be available after) empty. ( be sure to test compile separately before placing them here or you may cause) # 18 ( load to abort.)

{block 206}
( evb001 host chip ide) empty compile | br

serial load | cr
( customize) -canon 0 fh orgn ! | cr
a-com sport ! a-bps bps ! !nam | br


: dac ( n) $155 and io r! ; | br

( canon load)

{block 207}
( this load block compiles and configures the) | cr
( ide for the host chip on the eval board. it's also an example of configuring and customizing the ide without hacking it and breaking other uses of the ide.) | br

( this block starts by loading the serial ide in its standard form.) -canon ( forgets the mapping of canonical words like) ] @ ( and) dup ( onto the f18 so that we may interact with x86 code and ram.) | cr
( we then set) [ orgn ( so that the ide) ] compile ( will reload this block, and we set) [ sport ( to the usb port a for normal ide operations on host chip.) !nam ( updates pathname for that com port.) | br


: dac ( is defined to illustrate extending the ide) | cr
[ canon load ( restores mapping of canonical words onto the f18. comment this if you wish to use the 'r-words' for all f18 operations.)

{block 208}
( evb001 target chip ide) empty compile | br

serial load | cr
( customize) -canon 0 fh orgn ! | cr
c-com sport ! c-bps bps ! !nam | br


: dac ( n) $155 and io r! ; | br

( canon load)

{block 209}
( this load block compiles and configures the) | cr
( ide for the eval board's target chip. it's) | cr
( also an example of configuring and customizing the ide without hacking it and breaking other uses of the ide.) | br

( this block starts by loading the serial ide in its standard form.) -canon ( forgets the mapping of canonical words like) ] @ ( and) dup ( onto the f18 so that we may interact with x86 code and ram.) | cr
( we then set) [ orgn ( so that the ide) ] compile ( will reload this block, and we set) [ sport ( to the usb port c for normal ide ops on target chip.) | cr
!nam ( updates pathname for that com port.) | br


: dac ( is defined to illustrate extending the ide) | cr
[ canon load ( restores mapping of canonical words onto the f18. comment this if you wish to use the 'r-words' for all f18 operations.)

{block 210}
( ide based loader) :var pth [0x2] :var root [0x2c4] talk | , ( tables and routing) 2 fh 2 loads | , | ,
: body follower [ 0 ] + drop -if | , | ... [ root ] @ active or drop if deliver ; ] then ; | , | ... ] then [ 1 ] +route body [ -1 ] +route deliver ; | , | ,
: ship ( n) dup [ pth ] ! route active [ root ] ! | , | ... [ 1 ] +route foc body unfoc [ pth ] @ -hook ;

{block 211}
( ide scripting) | , | ,
: body ( recursively visit and initialize) | , ( each node in the path) | , | ,
: ship ( use given path and set foc mode) | , ( visit each node in the path then cleanup) | , ( by convention path) # 2 ( in the ide reaches all) | , ( nodes and is suitable for use by most apps.) | , | , [ usage ( is simple.) | , ( 1.) host ( or target) load loader load | , ( 2. describe the application using +node et al. 3.) ship

{block 212}
( - configuration tables) :var com [0x85]
: tabl pop 2/ 2/ [ com ] @ + ;
: jsr $e8 dst ; ( call has been clobbered already)
: table ( nn) [compile] align jsr tabl for dup , next drop ;
: a-boot [ -1 144 table | *
: c-boot [ -1 144 table ]
: b-boot [ -1 144 table | *
: p-reg [ $a9 144 table ]
: a-reg [ -1 144 table | *
: b-reg [ io 144 table | , | ,
: /a ( a) a-reg ! ; | *
: /b ( a) b-reg ! ; | *
: /p ( a) p-reg ! ;
: +node ( n) nn-n [ com ] ! ;
: /part ( acb) b-boot ! c-boot ! a-boot ! ;
: /ram ( b) b-boot ! 64 c-boot ! 0 a-boot ! ;
: rammer ( -acb) a-boot @ c-boot @ b-boot @ ; | , | ,
: aaray pop 2/ 2/ [ com ] @ [ 11 ] * + ;
: array ( n) [compile] align jsr aaray [ 11 ] * for 0 , next ;
: 'stack [ 144 array :var sp [0xa]
: @s+ 'stack [ sp ] @ + @ 1 [ sp ] +! ;
: !s- ( n) 'stack [ sp ] @ + ! -1 [ sp ] +! ;
: /stack ( stuff count) | , 10 [ sp ] ! dup !s- for !s- next ;

{block 213}
( - configuration tables)
: tabl
: jsr ( call from block) # 88 ( has been clobbered) | , ( so replace it with jsr instead)
: table ( build and initialize a table) | , ( tables hold configuration information)
: /a a ( specifies) [ a ( value for current node)
: /b a ( specifies) [ b ( value for current node)
: /p a ( specifies entry point for current node)
: +node n ( makes n the current node)
: /part acb ( specifies) [ address count ( and) bin | , ( for code to be loaded into current node later)
: /ram b ( specifies just the bin, load all) # 64
: rammer -acb ( returns) [ address count ( and) bin | , ( from table)
: /stack stuff count ( specifies) [ count ( items to be placed on the stack at load time)

{block 214}
( - routing) :var 'rte [0x40c0ef8]
: route ( i) 'pths + @ [ 'rte ] ! ;
: active ( -n) [ 'rte ] @ @ ;
: follower ( -n) [ 'rte ] @ [ 1 ] + @ ;
: +route ( n) [ 'rte ] +! active nn-n [ com ] ! ; | , | ,
: ?load c-boot @ [ 0 ] + drop -if ; ] then | , | ... rammer boot ; | , | ,
: deliver [ pth ] @ active hook ( pause) | , ?load a-reg @ - [ 0 ] + drop -if | , | ... a-reg @ lit' ra! then | , b-reg @ - [ 0 ] + drop -if | , | ... b-reg @ lit' rb! then | , 'stack [ 10 ] + @ dup and if dup | , | ... dup negate [ 10 ] + [ sp ] ! for @s+ lit' next | , | ... then drop | , p-reg @ call ;

{block 215}
( - routing)
: route i ( start on a path)
: active -n ( node being configured)
: follower -n ( next node in path)
: +route n ( change active node) | , | ,
: ?load ( load code into node now if table says to) | , | ,
: deliver ( init ram, a, b, stack, and p if) | , ( tables say to do so)

{block 216}
( softsim configuration) | , | , ( spi boot testbed) # 1244 # 2 ( loads) | , ( sync boot testbed 'addr,len') # 1230 ( load) | , | , ( smtm) 0 +node 0 /ram 0 /p | , ( /command test) 400 +node 0 /ram $25 /a $12 /b | , 9 8 7 6 5 4 3 2 1 $12345 10 /stack $a9 /p | , | , ( rom write test) # 200 ( +node) # $13 ( /p) | , | , # 0 # $32 # 103 ( break) | , # 0 # $be # 300 ( break)

{block 217}
( this block is loaded by softsim to set the) | , ( configuration for a given simulation. edit it as needed to set up testbeds, load application code and initialize it for running, and set) | , ( breakpoints.) | , | , see arrayforth user's manual for information | , about these options.

{block 218}


{block 219}


{block 220}


{block 221}


{block 222}


{block 223}


{block 224}


{block 225}


{block 226}


{block 227}


{block 228}


{block 229}


{block 230}


{block 231}


{block 232}


{block 233}


{block 234}


{block 235}


{block 236}


{block 237}


{block 238}


{block 239}


{block 240}
( framer) overlay ]
: exec [ $b6 ] ; | -cr : warm [ $a9 ] ; | -cr : io [ $15d ] ; | cr

: right [ $1d5 ] ; | -cr : down [ $115 ] ;
: left [ $175 ] ; | -cr : up [ $145 ] ; | cr
( streams) 2 fh 4 loads | br


: body ( w-w) follower [ 0 ] + drop -if | cr
?load post ; ] then -load -post pump | cr
[ 1 ] +route body [ -1 ] +route ?load post ; | cr

: length ( -n) 1 [ 'pth ] @ [ 1 ] + begin dup @ - [ 0 ] + | cr
-while - nn-n [ com ] ! c-boot @ [ 0 ] + -if [ -4 ] + | cr
then ( load) [ 5 ] + ( pump) [ 5 ] + ( post) @post + u+ | cr
[ 1 ] + end then drop drop ( -1pump) [ -5 ] + ; | br


: head ( a-w) active nn-n [ com ] ! [ $10000 ] + !18 | cr
[ 0 ] side dup !18 length dup !18 | cr
swap [ $12000 ] + !18 [ 1 ] +route ;
: frame [ exec ] head [ -1 ] + body drop [ -1 ] +route | , | ... c-boot @ [ 0 ] + drop -if 0 0 0 /part then | , | ... p-reg @ booter /root ; | , | , ( default path) 22 fh load

{block 241}
( framer load gets the stream vocabulary) | br


: body ( recursively make the body of a boot frame)
: length ( add up number of words in boot frame)
: head ( make boot frame header)
: frame ( make the whole boot frame) | indent
     # -1 ( for focus , +3 for header)

{block 242}
( - framer) :var com [0x83]
: tabl pop 2/ 2/ [ com ] @ + ;
: table ( nn) [compile] align call tabl for dup , next drop ;
: a-boot [ -1 144 table | *
: c-boot [ -1 144 table ]
: b-boot [ -1 144 table | *
: p-reg [ $a9 144 table ]
: a-reg [ -1 144 table | *
: b-reg [ io 144 table ]
: inits [ 1 144 table | *
: init 11 inits ! ;
: /a ( a) a-reg ! init ; | *
: /b ( a) b-reg ! init ;
: /p ( a) p-reg ! ;
: +node ( n) nn-n [ com ] ! ;
: /part ( acb) b-boot ! c-boot ! a-boot ! ;
: /ram ( b) b-boot ! 64 c-boot ! 0 a-boot ! ;
: booter ( -acb) a-boot @ c-boot @ b-boot @ ; | , | ,
: aaray pop 2/ 2/ [ com ] @ [ 11 ] * + ;
: array ( n) [compile] align call aaray [ 11 ] * for 0 , next ;
: 'stack [ 144 array :var sp [0xa]
: @s+ 'stack [ sp ] @ + @ 1 [ sp ] +! ;
: !s- ( n) 'stack [ sp ] @ + ! -1 [ sp ] +! ;
: /stack ( stuff count) init | , 10 [ sp ] ! dup !s- for !s- next ;

{block 243}
( stream components) com ( identfies current node)
: table ( creates an array initialized to) # -1
: x-boot
: x-reg ( arrays have booter and starter details)
: /p ( specifies entry point)
: /a ( initial value of a)
: /b ( initial value of b)
: +node ( connect to a node in a path) | cr

: /part ( from ide, specifies ram address,) | cr
( length and source) | , [ note scrub must be maintained to match the | , defaults stored here! ]
: booter ( find a, c, and b for +load) | br


: aaray
: array
: 'stack ( an array of) # 144 # 10 ( item stacks)
: @s+ ( get next item to be initialized)
: !s- ( store next item into stacks array)
: /stack ( specify stack initialization)

{block 244}
( - framer) :var 'pth [0x40bf20a]
: b-a ( b-a) [ 3 ] + 2/ 2/ ; | -cr : a-b ( a-b) 2* 2* ;
: create ( -a) pop b-a ;
: route pop b-a | *
: course ( a) [ 'pth ] ! ;
: active ( -n) [ 'pth ] @ @ ;
: follower ( -n) [ 'pth ] @ [ 1 ] + @ ;
: +route ( n) [ 'pth ] +! active nn-n [ com ] ! ; | br

:var wd [0x48403a8]
: 'stream ( -a) [ nnc 2 * $8000 + block 1 + ] ; | cr
( clear) 'stream 1 + wd ! ]
: stream ( -ac) [ 'stream 1 + ] dup [ wd ] @ - + - | , dup [ 'stream -1 + ] ! ;
: strlen ( -n) stream nip ;
: !18 ( n) [ $15555 ] or [ wd ] @ ! 1 [ wd ] +! ; | br


: wall ( nn-i) over over or [ 1 ] and drop if | cr
or [ 2 ] and ; ] then [ 100 ] / swap [ 100 ] / or | cr
[ 2 ] and [ 1 ] + ;
: side ( n-a) [ 'pth ] @ + dup @ swap [ 1 ] + @ wall port ; | cr

: 0/2 ( n-0/2) [ 0 ] + drop -if [ 0 ] ; ] then [ 2 ] ;
: @post ( -n) a-reg @ 0/2 b-reg @ 0/2 + | cr
'stack [ 10 ] + @ [ 2 ] * + [ 1 ] + ;

{block 245}
( stream components) | cr
'pth ( points to current place in path)
: b-a ( byte to word address)
: route ( stores address of new path in) [ 'pth
: course ( is user vocab for setting a path.)
: active ( return current node in path)
: follower ( return next node in path)
: +route ( move to next node in path) | indent
     [ pos ( moves forward) neg ( moves back) | br

wd ( point to next word in stream buffer)
: !18 ( stores word into stream buffer) | br


: wall ( given numbers of two adjacent nodes) | cr
( return index for shared port)
: side ( given numbers of two adjacent nodes) | cr
( return address of shared port) | br


: 0/2 ( false is 0 and true is) # 2
: @post ( add up the size of active node's) | cr
( postamble)
: to-do ... clean up 'stream as +2, | , define -1+ as length and -2+ as | , concat.

{block 246}
( - framer)
: pump ( w-w) [ -5 ] + ( @pdupa!@p) [ $4daf ] !18 | cr
[ 0 ] side [ $12000 ] + !18 dup [ -1 ] + !18 | cr
( push!..) [ $2fab2 ] !18 ( @p!unext.) [ $5a72 ] !18 ;
: post a-reg @ - [ 0 ] + drop -if | cr
( @pa!..) [ $4ab2 ] !18 a-reg @ !18 then | indent
     b-reg @ - [ 0 ] + drop -if | cr
( @pb!..) [ $4bb2 ] !18 b-reg @ !18 then | indent
     'stack [ 10 ] + @ dup and if dup | indent
     dup negate [ 10 ] + [ sp ] ! for | cr
( @p ..) [ $49b2 ] !18 @s+ !18 next then drop | cr
( always) p-reg @ [ $10000 ] + !18 ; | br


: +ram ( acb) nn-n 2* [ $8000 ] + block u+ | cr
for dup @ [ $15555 ] or !18 [ 1 ] + next drop ;
: +load ( acb) push ( @pa!@p.) [ $4a12 ] !18 | cr
over !18 dup [ -1 ] + !18 ( push...) [ $2e9b2 ] !18 | cr
( @p!+unext.) [ $5872 ] !18 pop +ram ;

{block 247}
( stream components) | br


: pump ( store) # 5 ( word port pump to stream buffer)
: post ( variable length word postamble,) | cr
( entry point, a, b, stack)
: +ram ( write ram contents to stream buffer)
: +load # 5 ( word load pump to stream buffer)

{block 248}
( - framer)
: ?load ( w-w) c-boot @ [ 0 ] + drop -if ; ] then | cr
booter +load ;
: -load ( w-w) c-boot @ [ 0 ] + -if drop ; ] then | cr
[ 5 ] + negate + ;
: -post ( w-w) @post negate + ; | br


: adjust begin strlen 7 and drop while | cr
0 !18 end then strlen 'stream ! ;
: scrub ( n) +node [ -1 ] dup dup /part | cr
-1 /a io /b warm /p ;
: fresh begin active scrub [ 1 ] +route | cr
active dup and drop -until 708 +node $aa /p ; | , | ,
: /root ( a' a c b) push push push | cr
$10000 +or !18 pop dup !18 pop dup !18 | cr
[ 0 ] + if pop +ram ; ] then drop drop pop drop ;

{block 249}
( stream components) | br


: ?load ( maybe add load pump and ram contents)
: -load ( subtract ram words from payload count) | cr
( if ram is to be loaded in active node)
: -post ( subtract length of postamble from) | cr
( payload count) | br


: adjust ( align stream to) # 8 # 18 ( bit word boundary)
: scrub ( remove previous initialization clues) | cr
( for node n in the current path) [ must be main- | , tained whenever defaults for tables change. ]
: fresh ( scrub the entire current path to prepare for another boot frame)

{block 250}
( ers flash erase function) overlay | cr
len ! dest ! | cr
serial load -canon | cr
a-com sport ! a-bps bps ! !nam panel ]
: esc key? esc ;
: wait esc 0 [ keych ] ! ;
: expand ( n-lh) dup $ffff and [ 4 ] * swap | cr
$f0000 and 64 / ;
: ersall [ $21 ] call ;
: ers32 [ $18 ] call ;
: ers [ dest ] @ 2* 2* [ $1e ] r! ers32 ;
: read ( a-a') dup expand lit' lit' [ $c ] call [ -2 ] + ;
: r ( d-dw) [ 2 ] + rdrop [ $25 ] call upd ;
: check [ dest ] @ read [ len ] @ for | cr
r $ffff or drop if pop [ 0 ] ; ] then -next [ -1 ] ; | cr
nores 285 list | cr
.noboot pause wait ( ** install noboot jumper) | cr
talk ( check a-com) 0 705 hook $0 64 1613 boot | cr
.boot pause wait ( *** remove noboot jumper) | cr
( ers) .erasing pause ( ersall) ers chill | , ( check) overlay

{block 251}
( erasing flash) | br


: ers ( an) | cr
[ a ( byte address in flash on 4k boundary) | cr
n ( number of) ] 16 bit words ( to erase)

{block 252}
( flash writer) # 18 ( bit) overlay | cr
7 + -8 and len ! dest ! source ! | cr
serial load -canon | cr
a-com sport ! a-bps bps ! !nam ( talk) | br


: esc key? esc ; | *
: wait esc 0 [ keych ] ! ; | cr
nores 285 list | cr
.noboot pause wait ( ** install noboot jumper) | cr
talk ( check a-com) 0 705 hook $0 64 1613 boot | , .boot pause wait ( *** remove noboot jumper) | , .erasing pause ( erase 1st 32k) | , | ... 0 $1e r! $18 call chill | , | , 0 705 hook $0 64 1609 boot focus | cr
0 706 hook $0 64 1610 boot | br

( flash commands) # 1214 2 fh load | , 285 list nosay | cr
.burning pause burn chill | cr
.checking pause check | cr
overlay

{block 253}
( writing a boot stream into flash) | br

( force length to) # 0 ( mod) # 8 ( so operation ends) | cr
( at a) # 16 ( bit boundary) | br


: 18burn ( sdn) | cr
[ s ( source address of buffer in host memory) | cr
d ( destination) # 8 ( bit address in flash) | cr
n ( length of stream in) # 18 ( bit words)

{block 254}
( - code for flash writer)
: read ( a) left lit' ra! dup $f0000 and 64 / | cr
swap $ffff and 4 * lit' lit' [ $23 ] call ;
: r left lit' ra! [ $29 ] call upd ;
: commence left lit' ra! [ len ] @ 8 / -1 + | cr
[ dest ] @ dup $f0000 and 64 / lit' | cr
$ffff and 4 * lit' lit' [ $2d ] call ;
: git ( a-an) dup [ 1 ] + swap @ [ $15555 ] or ;
: get ( a-a) git lit' ;
: burning [ source ] @ [ len ] @ for get !+ next drop ;
: fetch ( -n) [ $37 ] call # $3f [ $3a ] r@ ;
: check ( -t) [ dest ] @ read [ source ] @ [ len ] @ | cr
for git fetch over ( pause) over or | cr
drop if pop fail ; | cr
] then drop drop next drop good ;
: burn commence burning ; | br


: f 0 706 hook fetch 0 705 hook upd ;
: b 0 706 hook burn ;

{block 255}


{block 256}
( exercising flash) $20 org ]
: focus = $20 @p dup a! .. ( /) --l- ( /) ! ;
: reading = $23 ( l h) focus @p ! .. ( /) @p @p .. ( /) | cr
! ! .. @p ! ; ( /) $1200e , ( /)
: @word = $29 ( -n) @p ! .. ( /) [ $120d9 , ( /) | cr
] @p ! @ ; ( /) ] !p .. ( /)
: writing = $2d ( h l n) focus | cr
left @p ! .. ( /) @p a! .. ( /) | cr
! @p ! .. ( /) @p @p @p .. ( /) push push ! | cr
pop ! pop ! @p ! ; ( /) $1201d , ( /)
: stash = $37 focus @word !p ; = $3a 0 , | br

exit ]
: stash = $37 focus a push @word $3f a! ! pop a! ;

{block 257}


{block 258}
( writing flash) # 8 ( bits) overlay | cr
len ! dest ! source ! | cr
serial load -canon | cr
a-com sport ! a-bps bps ! !nam ( talk) | , nores 285 list 0 705 hook $0 64 1613 boot | , .erasing pause ( erase 2nd 32k) | , | ... $20000 $1e r! $18 call chill | , | , ( flash commands) # 1220 2 fh load | br

0 705 hook 0 64 1611 boot | cr
285 list nosay ( nores) | cr
.burning pause burn chill | cr
.checking pause check | cr
overlay

{block 259}
( programming) # 8 ( bit flash) | br


: burn ( sdn) | cr
[ s ( source address of buffer in host memory) | cr
d ( destination) # 8 ( bit address in flash) | cr
n ( length of stream in) # 16 ( bit words)

{block 260}
( code for reading and writing flash) # 8 ( bits) | cr

: out 0 706 hook ; | -cr : in 0 705 hook ;
: read ( a-a') in dup dup $f0000 and 64 / lit' | cr
$ffff and [ 4 ] * lit' [ $e ] call rdup upd [ -2 ] + ;
: r ( d-dw) [ 2 ] + rdrop [ $14 ] call upd ;
: r18 ( d-dw) [ 2 ] + rdrop [ $d9 ] call upd ;
: rr [ $8000 ] read r ;
: ers [ $24 ] call ; | -cr : pr [ $28 ] call ;
: send ( n) left ( pause) r! ;
: 2@+ ( b-b'h) dup 2 + swap 2@ $ffff and swab ;
: burn in [ dest ] @ dup [ $f0000 ] and [ 64 ] / lit' | cr
[ $ffff ] and [ 4 ] * lit' [ len ] @ lit' | cr
left lit' ra! pr out [ source ] @ [ len ] @ | cr
for 2@+ [ 4 ] * send -next drop ;
: check ( -t) [ dest ] @ read drop | cr
[ source ] @ [ len ] @ for 2@+ # $39 [ $3b ] call [ $3f ] r@ or | cr
drop if pop drop fail ; ] then -next drop good ;

{block 261}
( reading and writing flash) | br


: read ( begin at) # 20 ( bit flash byte address)
: r ( read the next) # 16 ( bit word from flash)
: r18 ( read the next) # 18 ( bit word from flash)
: rr ( begin and read first word at) # $8000
: ers ( erase whole flash)
: pr ( program assuming already erased)
: back ( back out to node) # 706 ( for streaming)
: send ( one word into node) # 705 ( , pause to display)
: 2@+ ( fetch) # 16 ( bit word + byte swap)
: burn n ( start programming flash in) # 705 ( ,) | cr
( then back out to) # 706 ( and stream words from) | cr
( the stream buffer into) # 705 ( .)

{block 262}
( default flash path for whole chip)
: line ( ncd) swap push swap | , | ... begin dup , over + -next drop drop ;
: count ( nc-ncd) dup [ 100 ] mod [ 0 ] + if | , ( horz) swap drop [ 1 ] ; | , ( vert) ] then drop [ 100 ] / [ 100 ] ;
: to ( nn) over negate + -if | , ( back) negate count negate line ; | , ( forw) ] then count line ; | , | ,
: entire align create [ 705 701 to 700 0 to | , 1 17 to 117 101 to 201 217 to 317 301 to | , 401 417 to 517 501 to 601 617 to 717 706 to | , -1 , | , | , ( retain asynch boot) 708 +node $aa /p

{block 263}

: line ncd ( comma nodes into a table starting at node) n ( for) c ( nodes incrementing by) d | cr

: /left ( extend line toward the left)
: /right ( extend line toward the right)
: /up ( extend line upward)
: /down ( extend line downward)
: entire ( default path table that) | cr
( covers the whole virginal chip)

{block 264}
( sram cluster mk1) | br

( load sram) 6 fh 3 loads | indent
     ( norm) 12 fh ( degen) # 12 # 16 ( fh) load

{block 265}
( load block for sram cluster mk1) | , ( as documented in an003.) | , | , ( packaged as per preliminary module standards) | , | , sram ( load block for f18 code) | , sram 2 + ( boot descriptors for cluster) | , sram 4 + ( optional residual path definition) | , ( f18 source code follows.)

{block 266}
( - load descriptor) | , | , ( interface) 107 +node 1614 /ram down /b | , | ... ( mask) $8a00 1 /stack ( re) $17 /p | , | , ( data) 7 +node 1615 /ram $20 /p | , ( cntl) 8 +node 1616 /ram $20 /p | , ( addr) 9 +node 1617 /ram $20 /p

{block 267}
( load descriptor for sram cluster) | , | , ( this descriptor is suitable for use with) | , ( ide loader, streamer, and softsim.)

{block 268}
( - residual paths) | , | ,
: s705 align create [ 705 701 to 700 0 to | , 1 6 to 106 101 to 201 208 to 108 109 to | , 209 210 to 110 10 to 11 17 to 117 111 to | , 211 217 to 317 301 to 401 417 to 517 501 to | , 601 617 to 717 706 to -1 , | , | ,
: s708 align create [ 708 701 to 700 0 to | , 1 6 to 106 101 to 201 208 to 108 109 to | , 209 210 to 110 10 to 11 17 to 117 111 to | , 211 217 to 317 301 to 401 417 to 517 501 to | , 601 617 to 717 709 to -1 ,

{block 269}
( memory clusters are often loaded before the) | , ( rest of the application so that external ram) | , ( may be initialized without burdening appli-) | , ( cation f18 code. these residual paths provide access from boot nodes to the rest of the chip in such cases.) | , | ,
: s705 ( residual path for spi flash boot streams.)
: s708 ( residual path for async boot or ide.)

{block 270}
( sram.16 address-bus) 9 node | cr
= $aa $20 org | br


: start = $20 right b! .. data a! .. $3 ( mask)
: cmd ( m) = $26 @b ( a16) 2* 2* over @b -if | indent
     = $28 - ( p04) and or ( a18) ! cmd ; | indent
     = $2a ] then ( p04) and or .. ( a18) ! cmd ; | , = $2c 1617 bin

{block 271}
( node) # 9 ( suspends while waiting for a16. it uses the two lower page bits to output an) | cr
( 18-bit address.) | cr
| indent
     ] a16 ( xx.aaaa.aaaa.aaaa.aaaa) | indent
     p04 ( 00.0000.0000.0000.pppp) | indent
     a18 ( aa.aaaa.aaaa.aaaa.aapp) | br

( the code is written to minimize/equalize the time to output the address, which must be stable when node8 stores the 'start' command.)

{block 272}
( - control-pins) 8 node host ]
: 'r-l- $1f5 lit ; target $0 org | br

( 'start' pin control table 0-7) | cr
= $0 $2556e ( r00) , $2557e ( r01) , | cr
= $2 $3556e ( r10) , $3557e ( r11) , | cr
= $4 $3557a ( w11) , $3556a ( w10) , | cr
= $6 $2557a ( w01) , $2556a ( w00) , | cr
= $8 $20 org | br


: start = $20 'r-l- b! io a!
: cmd = $24 @b ( stop) ! a push $7 ( mask) .. | indent
     @b ( a16) !b @b ( +p/-p) dup !b | indent
     2/ 2/ and ( i3) a! .. @ ( ctrl) pop a! | indent
     ( start) ! cmd ; | , = $2c 1616 bin

{block 273}
( node8 is fed a stop command during start-up, then suspends while waiting for a16. after starting the read or write, it again suspends while waiting for the stop command.) | br

( bits 4..2 of the /possibly inverted/ page value are used 'as-is' to index into the start table, setting two address bits, write enable, and chip enable.) ** note that reads and writes are swapped if the page 'overflows' into bit4, with disastrous results ** | cr
| cr
( cmd index) .lit. ( pin17 pin05 pin03 pin01) | cr
( w00 .0111) $2556a ( a19-0 a18-0 /we-0 /ce-0) | cr
( r00 .0000) $2556e ( a19-0 a18-0 /we-1 /ce-0) | cr
( w01 .0110) $2557a ( a19-0 a18-1 /we-0 /ce-0) | cr
( r01 .0001) $2557e ( a19-0 a18-1 /we-1 /ce-0) | cr
( w10 .0101) $3556a ( a19-1 a18-0 /we-0 /ce-0) | cr
( r10 .0010) $3556e ( a19-1 a18-0 /we-1 /ce-0) | cr
( w11 .0100) $3557a ( a19-1 a18-1 /we-0 /ce-0) | cr
( r11 .0011) $3557e ( a19-1 a18-1 /we-1 /ce-0)

{block 274}
( - data-bus) 7 node host ]
: in $14555 lit ; | -cr : out $15555 lit ;
: stop $3557f lit ; target | cr
| cr
= $aa $20 org ]
: start = $20 left b! out io data stop | indent
     out io data stop in io a! ( in) ! | indent
     down a! ( stop) !b
: cmd ( /soid/) = $31 @ ( a16) !b @ ( +p/-p) -if | br


: w16 ( /soid/p-) = $33 ( +p/-p) !b | cr
( /- setup + 45ns) @ ( w) a push push ( data) a! | cr
pop ! ( io) a! ( out) ! # 40 13 for unext ( stop) !b | cr
( -/) in ! pop a! cmd ; | br


: r16 ( /soid/p-) = $3c then ( +p/-p) !b | cr
( /- setup + 55ns) a push ( data) a! | cr
( io) drop ( out) drop # 50 40 for unext ( stop) !b ( -/) | cr
@ ( w) pop a! ! cmd ; | , = $43 1615 bin

{block 275}
( node7 suspends waiting for a16, passes it and page/r/w to nodes) # 8 ( and 9, finally controlling the data transfer and timing until sending the stop command.) | br

( the literals needed for writing are loaded) | cr
( onto the stack and used circularly to save) | cr
( time. /read's drops are free./) | br

( ----) ] .lit. ( pin17 pin05 pin03 pin01) | cr
( stop) $3557f ( a19-1 a18-1 /we-1 /ce-1)

{block 276}
( - interface) 107 node $0 org ]
: cx ( wp-) = $0 over push @ dup | , | ... ( a) !b over ( p) !b @b ( w) pop - ( w1) or if | , ( ne) @ ( w2) dup or ( ff) ! ; | , ( eq) ] then drop ( a) !b - ( -p) !b @ ( w2) !b $ffff ! ; | , | ,
: cmd = $a @ -if @ [ ' cx ] -until ( .e!) - !b !b @ !b ; ] then = $e @ -if ( mixpa) | , ( .mk!) = $f - push drop drop pop if ( mia) | , ( ..stim) = $11 drop and @ over over 2* ahead [ swap | , ( ..mask) = $14 ] then drop drop @ 2* over - | , ( ...both) = $c16 then and or
: re = $17 ( m) $15555 dup ahead [ swap | , | ... ] then ( .e@) = $19 ( a) !b ( p) !b @b ( w) ! ;
: cmds ( mixa) = $1b a! cmd | *
: poll ( mix) then io a! | , = $81e begin drop over over @ or and until | , = $21 over over and if ( mixt) = $23 and and ( mt) | , | .. dup $1000 and if left ahead [ swap ] then | , | .. = $28 drop $10000 over and if right ahead [ swap | , | .. = $2d ] then drop # $400 dup up then then | , | ... = $2f ( mtba) a! and or dup ! ( m) [ ' re ] end | , = $31 then drop 2* 2* -if right cmds ; | , = $35 ] then 2* 2* 2* 2* -if left cmds ; | , = $39 ] then up cmds ; = $3b 1614 bin

{block 277}
( node) # 107 ( full capability version.) | , ( polls for master requests and delivers stimuli)
: priority [ is ether/108, vm/106, snorkel/207 | , ( all requests are atomic. passes) ] ex@ ( and) ex! | , ( requests on to node 007, performs) cx? ( locally using those primitives. the command and stimulus mask) [ m ( is maintained on the stack.) | , | , ( requests are variable length messages decoded as shown below where - means 18-bit inverse of) # 16 ( bit argument.) | , | ,
: ex@ [ +p +a ( fetch)
: cx? [ -w1 +p a w2 ( comp-and-exch)
: ex! [ -p -a w ( store)
: mk! [ +0 -f m ( f-1 enables each master whose port write bit is set in) m. ( kills pending stimulus for any disabled master. abandons old mask.) | , ( f-0 adds a stimulus for each master whose port write bit is set in) m. ( caller should not post a stimulus for any disabled master.)

{block 278}
( - user node 106, 108, or 207.)
: x! ( wa) = $39 dup dup or
: ex! ( wap) | -cr : mk! ( mfp') = $3a - !b - !b !b ;
: x@ ( a-w) = $3c dup dup or
: ex@ ( ap-w) = $3d !b !b @b ;
: cx? ( wapn-f) = $3e - !b !b !b !b @b ; = $40

{block 279}
( example code for memory master nodes.) | cr
( memory-access words assume that addresses and data are 16-bit parameters with the upper two bits zero and pages are 4-bits with the upper) # 14 ( bits zero. p.a is thus a 20-bit address.) | br


: ex@ [ a p ( -) ] w ( fetch w from p.a)
: ex! [ w a p ( store w at p.a)
: mk! [ w f $ -0 ( set masks from w per f.)
: cx? [ w a p n ( -) ] f ( comp-and-exch) | br

cx? ( compares value at) [ p.a ( to) n. ( if same, writes) w ( to) p.a ( and returns true. otherwise, only returns false.) ] x@ ( and) x! ( are 16-bit versions to access the lowest 64k of available memory.) | br

mk! ( sets mask from w when f is 0;) | cr
( posts stimuli when f is 1.)

{block 280}
( - degenerate sram) 107 node $0 org | br


: cx ( wp-) = $0 over push @ dup | indent
     ( a) !b over ( p) !b @b ( w) pop - ( w1) or if | cr
( ne) @ ( w2) dup or ( ff) ! ; | cr
( eq) ] then drop ( a) !b - ( -p) !b @ ( w2) !b $ffff ! ; | br


: cmd = $a @ -if @ [ ' cx ] -until ( .e!) - !b !b @ !b ; ] then = $e @ ( .e@) = $f ( a) !b ( p) !b @b ( w) ! ; | br

= $11 $17 org ]
: start = $17 down b! right a!
: run = $1b cmd run ; = $1d

{block 281}
( node) # 107 ( minimal capability version.) | cr
( single master, no polling, no stimuli.) | cr
( maximum speed, minimum power.) | br

( all requests are atomic. passes) ] ex@ ( and) ex! | cr
( requests on to node 007, performs) cx? ( locally using those primitives.) | br

( requests are variable length messages decoded as shown below where - means 18-bit inverse of) # 16 ( bit argument.) | br


: ex@ [ +p +a ( fetch)
: cx? [ -w1 +p a w2 ( comp-and-exch)
: ex! [ -p -a w ( store)

{block 282}
( streamer) | cr
:var source [0x120f8000] :var dest [0x8000] :var len [0x11ff]
: stream ( -an) [ source ] @ [ len ] @ ;
: 18burn ( sdn) [ -30 fh ] load ;
: burn ( sdn) [ -24 fh ] load ;
: ers ( an) [ -32 fh ] load ;
: framer [ -42 fh ] ;
: chill 500 for 1000000 for nop next next ;
: file [ 12 fh ] ; | cr
( feedback) 284 load ]
: overlay remember

{block 283}
( stream building utilities) | cr
( persistant streamer variables) | cr
] source ( word address in host memory buffer) | cr
dest ( byte address in flash) | cr
len ( length of stream in words)
: stream -an ( returns) [ source ( an) len ]
: 18burn sdn ( burn flash in) # 18 ( bit words)
: burn sdn ( burn flash in) # 16 ( bit words)
: ers an ( erase 4k blocks containing range) [ an
: framer ( location of boot frame vocabulary)
: chill ( delay a long enough time to be sure) | cr
( that the previous operation is complete)
: overlay ( remember point for streamer utility) | cr
( saying) [ overlay ( restores the dictionary to) | cr
( its state when overlay was defined)

{block 284}
( flash utilties feedback) | , :var result :var 'say [0x102f8ff2] | , :var 'ask [0x102f8f25] :var 'at [0x102f929d]
: nosay [ 'say ] assign nop ; nosay ]
: noask [ 'ask ] assign nop ; noask ]
: noat [ 'ask ] assign nop ; noat ]
: .now blu [ 'say ] xqt ;
: .ask blu [ 'ask ] xqt ;
: .at. blu [ 'at ] xqt ;
: chs ( ...n) for emit next ; 2 fh load ]
: .res blu [ result ] @ | , # 0 [ -1 ] + -if drop .good ; ] then | , # 1 [ -1 ] + -if drop .fail ; ] then ;
: good 0 [ result ] ! ; | *
: fail 1 [ result ] ! ;
: nores 2 [ result ] ! ; :var leng [0x1000] 36 leng ! ]
: .str blu silver .' ( stream) space .' ( length) | , space [ leng ] @ . .' ( words) space | , [ leng ] @ 18 8 */ . .' ( bytes) space ;
: .nucleus [ 'at ] assign blu silver | , .' ( nucleus) space ;
: .stream [ 'at ] assign blu silver | , .' ( boot) space .' ( stream) space ;

{block 285}
( flash utilities) | , | , | .str | , | , | .now | , | .at. | , | , | .res | , | .ask

{block 286}
( - flash utilities feedback)
: .erasing noask [ 'say ] assign silver | , .' ( erasing) space ;
: .burning noask [ 'say ] assign silver | , .' ( burning) space ;
: .checking noask [ 'say ] assign silver | , .' ( checking) space ;
: .good green .' ( success) space ;
: .fail red ( fail) 0 $c $7 $5 $e 5 chs ;
: .boot nosay [ 'ask ] assign green .' ( remove) space
: .j26 .' ( j26) space .' ( then) space | , .' ( press) space .' ( key) space ;
: .noboot nosay [ 'ask ] assign green | , .' ( install) space .j26 ;
: .cont nosay [ 'ask ] assign green | , .' ( press) space .' ( space) space .' ( to) space | , .' ( burn) space .' ( new) space .' ( nucleus) space ;

{block 287}


{block 288}
( pf to flash) | br

( read/write) # 18 ( bit flash) | indent
     705 node 1364 load 1609 bin | indent
     706 node 256 load 1610 bin | cr
( read/write) # 8 ( bit flash) | indent
     705 node 1370 load 1611 bin | cr
( erase flash) | indent
     705 node 1352 load 1613 bin

{block 289}


{block 290}
( speedup spi boot) 705 node 0 org ]
: start 5 dup spi-exec ; | cr
= $3 1608 bin

{block 291}


{block 292}


{block 293}


{block 294}
( stream to file) named ( stream.bin)
: open ( bf-h) push push 0 32 ( exist) 2 0 0 | cr
pop pop swap fcreate ;
: change ( ac) for dup @ [ $15555 ] or over ! [ 1 ] + | cr
next drop ;
: keep [ 0 fnam ] w/o open dup push stream change | cr
stream push 4 * pop 4 * pop fwr drop fclose | cr
stream change ; keep

{block 295}
( stream to file)
: open bf-h ( b is byte address of filename)
: change ac ( stream is made as pattern not number)
: keep ( convert stream to number and write it to a file, then change it back to pattern)

{block 296}


{block 297}


{block 298}


{block 299}


{block 300}
( dc characterization code added march 2011.) | br

block 602 ( is code run in a node to measure power.) | br

blocks 604 ( thru) 636 ( are ide load blocks to set up various measurement conditions.)

{block 301}


{block 302}
( custom test code) 609 node $0 org ]
: t1 = $0 begin begin begin begin | cr
unext unext unext unext t1 ;
: t2 = $2 begin begin begin | cr
. unext unext unext t2 ;
: t3 = $4 begin begin . . unext unext t3 ;
: t4 = $6 begin . . . unext t4 ;
: t5 = $8 begin begin begin begin | cr
next next next next t5 ;
: t6 = $d begin begin begin begin | cr
. . . . next next next next t6 ;
: s++ = $13 $15555 dup | -cr : s.. dup dup dup dup dup dup dup dup ; | -cr : s+- $15555 $2aaaa s.. ;
: t7 = $1c s++ | -cr : t78e begin begin begin drop unext unext unext t78e ; | -cr : t8 = $1f s+- t78e ;
: t9 = $21 io b! -1 !b begin . drop @b -until ;
: txx = $28 s++ ( s+-)
: txxx begin ( . . .) - unext txxx ; = $2a
: temp # $2 $3fffe # $3 $3ffff 999 io b! push !b begin unext !b ; = $31
: temps temp temps ; = $33

{block 303}
( this load block, and the following) # 25 ( source/shadow pairs, are yours to do with as you please!)

{block 304}
( set all high z for leakage test) talk | br

0 200 hook 0 io ! | cr
0 300 hook 0 io ! | cr
0 9 hook 0 io ! | cr
0 7 hook 0 io ! | cr
( serdes already in input just focus it) | cr
0 701 hook focus | cr
2 709 hook $155 io !

{block 305}


{block 306}
( set all weak pd for wpd test) talk | br

0 200 hook $15555 io ! | cr
0 300 hook $15555 io ! | cr
# 0 # 9 ( hook) # 0 ( io !) | cr
# 0 # 7 ( hook) # 0 ( io !) | cr
( serdes already in input just focus it) | cr
# 0 # 701 ( hook focus) | cr
# 2 # 709 ( hook) # $155 ( io !)

{block 307}


{block 308}
( set all high for several tests) talk | br

0 200 hook $30003 io ! | cr
0 300 hook $30003 io ! | cr
0 9 hook $3ffff data ! | cr
0 7 hook $3ffff data ! | cr
( serdes already in input just focus it) | cr
# 0 # 701 ( hook focus) | cr
2 709 hook $aa io !

{block 309}


{block 310}
( set all low for several tests) talk | br

0 200 hook $20002 io ! | cr
0 300 hook $20002 io ! | cr
0 9 hook $0 data ! | cr
0 7 hook $0 data ! | cr
( serdes already in input just focus it) | cr
# 0 # 701 ( hook focus) | cr
2 709 hook $155 io !

{block 311}


{block 312}
( t04 all node access) talk | br

?rom pause upd pause | cr
2 708 hook pause 2 707 hook pause | cr
?ram pause upd pause | cr
1 lit pause 2 lit pause 3 lit pause | cr
+ pause +

{block 313}


{block 314}
( vt+- node) # 217 compile talk 2 217 hook upd | cr

: dak ( n a) $5bb2 over r! swap $155 or swap r! ;
: try ( n) up dak ;
: h $20000 io r! $0 try 100 ms 0 io r! | cr
0 begin dup $200 or $200 and drop while | cr
dup try 1 + io r@ $20000 and drop until then ;
: l $30000 io r! 511 try 100 ms 0 io r! | cr
255 begin dup $100 or $100 and drop while | cr
dup try -1 + io r@ - $20000 and drop until then ;

{block 315}


{block 316}
( vt+- node) # 517 compile talk 0 517 hook upd | cr

: dak ( n a) $5bb2 over r! swap $155 or swap r! ;
: try ( n) up dak ;
: h $20000 io r! $0 try 100 ms 0 io r! | cr
0 begin dup $200 or $200 and drop while | cr
dup try 1 + io r@ $20000 and drop until then ;
: l $30000 io r! 511 try 100 ms 0 io r! | cr
255 begin dup $100 or $100 and drop while | cr
dup try -1 + io r@ - $20000 and drop until then ;

{block 317}


{block 318}
( vt n7/8) compile talk | cr
2 7 hook $0 io ! data lit ra! focus | cr
2 8 hook $20000 io ! focus upd | cr

: rd ( a-n @!p) $39b2 over r! r@ ;
: git ( -n) left rd ;
: go key? git 1 and drop if $30000 io r! go ; | cr
] then $20000 io r! go ; go

{block 319}


{block 320}
( vt n9/8) compile talk | cr
0 9 hook $0 io ! data lit ra! focus | cr
0 8 hook $20000 io ! focus upd | cr

: rd ( a-n @!p) $39b2 over r! r@ ;
: git ( -n) right rd ;
: go key? git $20000 and drop if $30000 io r! go ; | cr
] then $20000 io r! go ; go

{block 321}


{block 322}
( t10 schmitt power) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! upd | cr
0 300 hook $15555 io ! upd | cr
0 9 hook ( input) 0 io ! upd | cr
0 7 hook ( output) $15555 io ! upd | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd | cr


{block 323}


{block 324}
( t11 suspended power) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
( susp boot-) $0 $0 ( warm) $a9 /frame wos !frame

{block 325}


{block 326}
( study single node + boot power) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
1 608 hook upd 0 64 609 boot ?ram

{block 327}


{block 328}
( t12a boot power) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
1 608 hook upd 0 64 609 boot ?ram | cr


{block 329}


{block 330}
( t12b boot pwr + drop same) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
1 608 hook upd 0 64 609 boot ?ram | cr
# 19 $1c call

{block 331}


{block 332}
( t12c boot pwr + drop alternating) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
1 608 hook upd 0 64 609 boot ?ram | cr
# 28 $1f call

{block 333}


{block 334}
( t12d boot pwr + greg test) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
1 608 hook upd 0 64 15 boot ?ram | cr
14 call

{block 335}


{block 336}
( t12e boot pwr + unext) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
1 608 hook upd 0 64 609 boot ?ram | cr
0 call

{block 337}


{block 338}
( sram test bd quiet i/o) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 8 hook ( all hi) $3557f io ! | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
0 705 hook $3ffff io ! | cr
0 -hook

{block 339}


{block 340}
( study single node w/boot suspended) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
1 608 hook upd 0 64 609 boot ?ram | cr
( run) # 0 $15555 # $3ffff lit dup dup dup $21 call | cr
( susp boot-) $0 $0 ( warm) $a9 /frame wos !frame

{block 341}


{block 342}
# 705 ( unext w/boot suspended) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
0 705 hook upd 0 64 609 boot ?ram | cr
( run) 0 call | cr
( susp boot-) $0 $0 ( warm) $a9 /frame wos !frame

{block 343}


{block 344}
( instr timing code) 610 node $0 org ]
: set $3fffe $3ffff 999 io b! 1 a! ;
: t1 = $7 set push !b begin unext !b ;
: t2 = $a set push !b begin next !b ;
: t3 = $e set push !b begin . unext !b ;
: t4 = $11 set push !b begin . . . unext !b ;
: t5 = $15 set push !b begin . . @ unext !b ;
: t6 = $19 set push io a! !b begin . . @ unext !b ;
: t7 = $1f set push !b begin . .. next !b ;
: t8 = $24 set push !b begin . .. . .. next !b ;
: t9 = $2a set push !b begin begin dup or push unext . . . . next $2 !b ; = $31

{block 345}


{block 346}
( study instr timing) talk | br

( no boot) 0 709 hook upd 0 -hook | cr
0 200 hook $15555 io ! pause | cr
0 300 hook $15555 io ! pause | cr
0 9 hook ( input) $15555 io ! $0 data ! pause | cr
0 7 hook ( output) $15555 io ! $0 data ! pause | cr
( serdes to output) | cr
0 701 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! pause | cr
0 $1 hook focus $3fffe lit $3fffe data ! | indent
     $20000 io ! upd pause | cr
0 705 hook upd 0 64 610 boot ?ram | cr
| cr

: t1 [ $7 ] call ; | -cr : t2 [ $a ] call ;
: t3 [ $e ] call ; | -cr : t4 [ $11 ] call ;
: t5 [ $15 ] call ; | -cr : t6 [ $19 ] call ;
: t7 [ $1f ] call ; | -cr : t8 [ $24 ] call ;
: t9 [ $2a ] call ;

{block 347}


{block 348}


{block 349}


{block 350}


{block 351}


{block 352}


{block 353}


{block 354}


{block 355}


{block 356}
( mark mem test all nodes) | cr
empty compile serial load panel talk 2 # 0 path | cr
:var tgt [0x1a1] :var tport [0x115] :var times | cr
:var runs [0x3] :var greg [0x1822e] :var /max [0x1822e] :var /tot | br


: init $0 [ greg ] ! 0 [ times ] ! 0 [ runs ] ! 0 [ /max ] ! 0 [ /tot ] ! 0 [ tgt ] ! 0 [ tport ] ! ; init | br


: xx [ 0 ] test 0 or if -1 + dup [ /max ] @ max [ /max ] ! [ greg ] ! ( drop) rip 9876 54321 abort then drop ; | br


: -us ( a-a) dup @ paths @ or drop ;
: -end ( a-a) dup @ -1 or drop ;
: pt@ paths targets @ + ;
: /go pause [ 0 ] 64 907 boot pfocus paths targets @ + ( ;)
: //go key? [ 1 ] + -us if -end if dup @ dup [ tgt ] ! over -1 + @ wall port dup [ tport ] ! ( pause) tfocus pause xx ( pause) creep //go ; ] then then drop 1 [ runs ] +! rip /go ;
: real | -cr : jj /go drop rip ; 776 list ( /go)

{block 357}
( old code, not checked recently.)
: go ( entered with path hooked to initial adjacent node. boots it with package and makes it active.)
: //go ( entered with path tbl adr for the active node on stack.)

{block 358}
( mark burn on one weak node) | cr
empty compile serial load panel talk 2 # 0 path | cr
:var tgt [0x2c6] :var tport [0x175] :var times | cr
:var runs [0x3] :var greg :var /max :var /tot | cr

: init $0 [ greg ] ! 0 [ times ] ! 0 [ runs ] ! 0 [ /max ] ! 0 [ /tot ] ! ; init ]
: kk 0 64 907 boot pfocus left tfocus ( creep right tfocus)
: //run init pause
: /con key? 0 test 0 or if dup 1 [ times ] +! -1 + dup [ /max ] @ max [ /max ] ! dup [ greg ] ! [ /tot ] +! then [ greg ] ! 1 [ runs ] +! [ runs ] @ # 1000 # 10 2 mod dup and drop if /con ; ] then pause /con ;
: /real kk 12345 ; 778 list ( /go)

{block 359}
( old code, not checked recently.)
: go ( entered with path hooked to initial adjacent node. boots it with package and makes it active.)
: //go ( entered with path tbl adr for the active node on stack.)

{block 360}
( polyforth virtual machine) reclaim | , | , ( sram cluster mk1) sram load | , ( serial) 38 fh 3 loads reclaim | , | , ( stack) 106 node $39 org 278 load 14 fh 2 loads | , ( coprocs) 22 fh 4 loads | , ( bitsy) 105 node 18 fh 2 loads | , ( coprocs) 30 fh 4 loads | , | , ( flash to sram) 86 fh 2 loads reclaim | , ( erase and burn flash) 288 load | , ( spi speedup) 290 load | , | , ( serial wires) 102 node $20 org | ,
: start @ !b start ; = $21 1709 bin | , ( ganglia) 44 fh load ( snorkel) 48 fh load | , ( spi) 50 fh load | , ( ethernet cluster mk1) ether load

{block 361}
( this load block compiles the f18 code for all nodes in the polyforth vm.)

{block 362}
( - load descriptors) | ,
: l, ( nn) dup +node 100 /mod 1 and 2* swap 1 and + 1714 + push 32 32 pop /part ( warm) $a9 /p ;
: ganglia nns for i -1 + n-nn l, next ; | , | , ( sea of mk1) ganglia | , ( snorkel mk1) 207 +node 1605 /ram up /b $37 /p | , | , ( sram cluster mk1) sram 2 + load | , ( virtual machine) 2 fh load | , ( serial terminal) 4 fh load | , ( additional i/o) 6 fh load | , ( clock nodes) exit | , | .. 517 +node 517 /ram io /b $200 /p | , | .. 516 +node 516 /ram left dup /a /p right /b | , ( ethernet cluster mk1) exit | , | .. ether 2 + load

{block 363}
( this block describes entire chip's loading for polyforth boot environment.) | , | , ( suitable for use with ide loader, streamer,) | , ( and softsim.) | , | , ( all nodes not otherwise programmed are loaded with ganglia for ad hoc routing.) | , | , ( the sram cluster is invoked here for complete documentation although it has been loaded) | , ( earlier and is excluded from the path used by the main stream.) | , | , enable loading of clock nodes if you have ftdi or ether clock connected to 517. | , | , enable loading of ether cluster if you have | , nic hardware attached to right side of chip.

{block 364}
( -- virtual machine) | br

( buds) 205 +node 1705 /ram up /b 1 /p | indent
     5 +node 1704 /ram down /b 1 /p | indent
     206 +node 1702 /ram up /b right # 1 /p | indent
     6 +node 1701 /ram down /b 1 /p | br

( bitsy) 105 +node 1703 /ram | indent
     $ffe0 $15555 ( 'cold) 1 3 /stack | indent
     left /b right /a $31 /p | br

( stack) 106 +node 1700 /ram | indent
     $ffff 0 0 3 /stack | indent
     right /b left /p

{block 365}


{block 366}
( -- serial terminal) | br


: /wire ( io) $20 1 [ 1709 ] /part /b /a [ $20 ] /p ; | br

104 +node 1708 /ram $20 /p | cr
103 +node left right /wire | cr
102 +node right left /wire | cr
101 +node left right /wire | cr
100 +node 1706 /ram $20 /p | br

204 +node left up /wire | cr
203 +node right left /wire | cr
202 +node left right /wire | cr
201 +node right left /wire | cr
200 +node 1707 /ram $20 /p

{block 367}


{block 368}
( -- additional i/o) | , ( spi) 705 +node 1606 /ram io /b $a9 /p | , ( async bootable) 708 +node $aa /p

{block 369}
( loads the spi node with flash support in both) | .. ( ide and spi boot procedures.) | , ( when loading from spi, the async boot node is) | .. ( loaded with ganglion but the line here runs) | .. ( it at cold, thus allowing ide ops. for just) | .. ( ganglion, comment this line; to program it) | , | .. ( otherwise, override later with your own boot) | .. ( descriptors.) | , | , spi boot ( may load every node in the chip.) | , ide boot ( may load every node in the chip) with | , | .. the ] sole exception [ of node 708.

{block 370}
( - host ide with pf running) empty compile | , | , serial load | , ( customize) -canon 0 fh orgn ! 0 ?reset ! | , a-com sport ! a-bps bps ! !nam | , | , ( paths) 2 fh load | , ( select one...) pfonly ( pfeth) 'pths 2 + ! | , | ,
: dac ( n) $155 and io r! ; | , | , ( canon load)

{block 371}
( this load block compiles and configures the) | , ( ide for the host chip on the eval board, for) | , ( debugging f18 code in the rest of the chip after polyforth has been loaded.) | , | , ( regardless of how pf was booted ... ide or spi flash ... you will load this code and say talk to get started. the reset line is disabled for talk in this mode so that we don't kill pf.) | , | , canon load ( restores mapping of canonical words onto the f18. comment this if you wish to use the 'r-words' for all f18 operations.)

{block 372}
( -- residual paths) | ,
: pfonly align create [ 708 716 to 717 17 to | , 16 616 to 615 15 to 14 614 to 613 13 to | , 12 612 to 611 11 to 10 610 to 609 109 to | , 108 608 to 607 707 to 706 606 to 605 604 to | , 704 701 to 700 300 to 301 601 to 602 603 to | , 503 506 to 507 307 to 306 406 to 405 305 to | , 304 404 to 403 303 to 302 502 to -1 , | , | ,
: pfeth align create [ 708 717 to 617 609 to | , 509 515 to 415 409 to 309 313 to 213 208 to | , 308 608 to 607 707 to 706 606 to 605 604 to | , 704 700 to 600 300 to 301 307 to 507 506 to | , 406 405 to 505 504 to 404 403 to 603 601 to | , 501 401 to 402 502 to -1 ,

{block 373}
( maximum coverage paths usable after pf loaded, with or without ether+clock.) | , | ,
: pfonly ( covers all nodes not loaded by the base) | .. ( poly boot. it does not cover 205,) # 206 ( which) | .. ( must have discrete paths.) | , | ,
: pfeth ( covers all nodes but) # 416 ( after pf, ether) | .. ( and clock are all loaded. 205,) # 206 ( and) # 416 | , | .. ( must have discrete paths.)

{block 374}
( pf.16 stack) $0 org ]
: '1+ ( w-w) = $0 1 . + | -cr : mask ( w-w) = $2 $ffff and ;
: '2/ ( w-w) = $4 2* 2* 2/ 2/ 2/ mask ;
: popt ( p-pt) = $6 dup '1+ over x@ ;
: 'au! ( pst-p43) = $8 x!
: popst ( p-pst) = $9 popt
: pops ( pt-pst) = $a push popt pop ;
: pop43 ( pst-p43st) = $c push push popst pop pop ;
: '1- ( w-w) = $e -1 . + mask ; = $11 here $37 org ]
: psht ( pt-p) = $37 push '1- pop over ( x! ;) = $839 ( *) [ org
: pshs ( pst-pt) = $11 push psht pop ;
: pshw ( pstw-ptw) = $13 push pshs pop ;
: 'sp! ( ptp-pst) = $15 pshs popst ;
: 'drop ( pst-p3s) = $17 drop pops ;
: 'over ( pst-pts) = $18 over pshw ; | br


: sco ( x3) = $19 2* -if | cr
( code.sx x4) = $1a 2* ( up) [ $145 ] -until -d-- ; | cr
( code.sm x4) = $1d ] then drop push ; = $1e | br

# 3 ( words to recover!) $21 org

{block 375}
( the stack node abuts the memory driver. note that it includes x@ and friends.) | br


: psht ( is placed so it falls into) x! | br


: 'name ( denotes) vm instructions | cr

: others ( are internal words) | br

( the external data stack grows downward, using pre-dec writes post-inc reads.) | cr
( the internal stack holds the vm) [ stack pointer ( and cached) s ( and) t | br

( 16-bit words are) 00.nnnn.nnnn.nnnn.nnnn

{block 376}
( - stack cont'd)
: 'dup ( pst-ptt) = $21 dup pshw ;
: 'swap ( st-ts) = $22 over push push drop pop pop ;
: '2* ( w-w) = $24 2* mask ;
: 'or ( pst-p3w) = $25 over - and
: 'xor ( pst-p3w) = $26 or pops ;
: 'and ( pst-p3w) = $27 and pops ;
: 'neg ( n-n) = $28 '1-
: 'inv ( w-w) = $29 begin - mask ;
: 'zeq ( w-f) = $2a until begin dup or ;
: 'zlt ( n-f) = $2c 2* 2* -until dup or 'inv ;
: 'um+ ( uu-uc) = $2e + $10000 over and if or 1 ;
: 'nop = $33 then ( begin) ;
: 'qdup ( pst-pst/ptt) = $34 ( until)
: '- ( pst-p3n) = $34 'neg
: '+ ( pst-p3n) = $35 + mask pops ; | cr
= $37 1700 bin

{block 377}
( notes-) | indent
     ( the initial sp is reset by) cold | indent
     ( code must fit before block 740's) ] psht | indent
     ( some optimizations are commented out) | cr
( so as not to lose the code for use later when/if some code is put in rom.)

{block 378}
( pf.16 bitsy) $0 org ]
: 'else | -cr : bx@ ( a-w) = $0 @p !b !b . ( /) @p x@ ( /) | cr
@p !b @b ; ( /) ] !p . . . ( /)
: bx!- ( aw-a') = $4 @p !b !b dup ( /) @p . . . ( /) | cr
@p !b !b . ( /) @p x! ( /)
: dec ( a-a') = $8 -1 . + ;
: @2tos ( a-) = $a bx@
: bpshw ( w-) = $b @p !b !b ; ( /) ] @p pshw ( /)
: 'rp@ ( rip-rip) = $d push over bpshw pop ;
: 'lit ( rip-rip') = $f dup @2tos
: inc ( a-a') = $10 1 . + ;
: 'con ( rip-rip) = $12 bx@
: 'var ( rip-rip) = $13 dup bpshw
: 'exit ( rip-r'i'p') = $14 drop push
: popi ( r.p-r'ip) = $15 inc
: geti ( r.p-rip) = $16 dup bx@ pop ; | br


: bpopw ( -w) = $18 @p !b @b ; ( /) ] !p pops ( /)
: 'tor ( rip-rip) = $1a push bx!- bpopw pop ;
: 'r@ ( rip-rip) = $1d over bpshw ;
: 'rfrom ( rip-rip) = $1e push bpshw popi ;

{block 379}
( the return stack pointer 'r', top of return stack 'i', and vm instruction pointer 'p' live on the stack of the bitsy node. in stack pictures . shows return stack on right.) | br



{block 380}
( - bitsy cont'd)
: 'exe ( rip-rip) = $20 bpopw
: xxt ( ripx-rip) = $21 dup 2* 2* -if | cr
( code ripx2) = $23 2* -if | cr
( code.b ripx3) = $24 2* -if | cr
( code.bx ripx4) = $25 2* ( up) [ $145 ] -until -d-- ; | cr
( code.bm ripx4) = $28 ] then drop push ; | cr
( code.s ripx3) = $29 ] then @p !b push . ( /) @p @p . . !b pop !b .. @p !b ; ] .. ( /) sco .. | cr
( hi rix2) = $2e then drop push push bx!- pop pop ;
: run ( rip-rip) = $31 dup bx@ push inc pop xxt run ; | cr

: 'if ( rip-rip') = $35 bpopw if drop inc ; | cr
] then drop bx@ ;
: 'rx? = $39 @ bpshw ;
: 'tx? = $3a @p !b @b . ( /) !p . . @p ( /) ! @ !b ;
: 'rp! ( rip-rip) = $3d push bx!- bpopw geti ; | cr
= $40 1703 bin

{block 381}
( the bit-threaded code technique confines execution to the) ] bitsy ( loop and a small number of code words. pseudo-instruction format is) | br

[ xx.0aaa.aaaa.aaaa.aaaa ( high level call) | cr
xx.100x.xxaa.aaaa.aaaa ( xt in stack node) | cr
xx.1010.xxaa.aaaa.aaaa ( xt in stack up) | cr
xx.1011.xxaa.aaaa.aaaa ( xt in stack down) | cr
xx.110x.xxaa.aaaa.aaaa ( xt in bitsy) | cr
xx.1110.xxaa.aaaa.aaaa ( xt in bitsy up) | cr
xx.1111.xxaa.aaaa.aaaa ( xt in bitsy down) | br

( this version uses sco in stack node to decode all its instructions.) | br

7 word decode for stack node | cr
( code.s rix3) = $28 ] then 2* -if | cr
( code.sx rix4) = $29 @p !b !b . ( /) @b sco ( /) drop ; ( code.sm) = $2c ] then drop $1a000 or !b ;

{block 382}
( stack down bxxx) 6 node 0 org ]
: xqt = $0 @b push ex
: idle = $1 @p !b xqt ; ( /) ] drop !p . . ( /) = $3 | br


: ''s = $3 @p !b @p . ( /) pshs ( /) psht ( /) | cr
!b @p !b ; ( /) ] dup pops ; = $8 | br


: 43xp ( op) = $8 @p !b !b . ( /) pop43
: pops; = $a @p !b ; ( /) ] pops ;
: 'ex@ ( pst-p3w) = $c @p !b pops; ; ( /) ] ex@
: 'ex! ( pst-p54) = $e @p 43xp ; ( /) ] ex!
: 'cx? ( pst-p5f) = $10 @p 43xp ; ( /) ] cx?
: 'mk! ( pst-p54) = $12 @p 43xp ; ( /) ] - ex!
: 'sus = $14 @p !b ; ( /) ] @b drop ; | , = $16 1701 bin

{block 383}

: idle ( main program of coprocessor nodes. feeds owner instruction to give us the vm opcode and executes it.) | cr
opcodes [ must return to idle when done. | cr
] port ( code for owner) [ must ( end with return.) | br


: ex@ ( and friends cost) # 10 ( words, two more than the) # 8 ( which they took in the stack node.)
: 'mk! ( msk f) # 0 ( inverts) # 0 ( so ex! can do the work.)
: 'sus ( suspends vm waiting for stimulus.)

{block 384}


{block 385}


{block 386}
( stack up axxx) 206 node 0 org ]
: xqt = $0 @b push ex
: idle = $1 @p !b xqt ; ( /) ] drop !p . . ( /) = $3 | cr
| br


: start = $3 up b! idle ;
: free = $5 @p !b pop ; ( /) ] . ; ] .. | br

= $7 [ 1702 bin exit ]
: who = $7 @p !b @b @p ( /) !p @p ; ( /) 206 , ] + !b ;

{block 387}

: idle ( main program of coprocessor nodes. feeds owner instruction to give us the vm opcode and executes it.) | cr
opcodes [ must return to idle when done. | cr
] port ( code for owner) [ must ( end with return.) | br



{block 388}


{block 389}


{block 390}
( bitsy down fxxx) 5 node 0 org ]
: xqt = $0 @b push ex
: idle = $1 @p !b xqt ; ( /) ] drop !p . . ( /) = $3 | br


: 'next = $3 @p !b @b . ( /) push dup !p . ( /) | cr
push zif @p !b @p . ( /) drop inc ( /) dup bx@ | cr
!b @p !b ; ( /) ] pop inc ; ( /) ] then | cr
pop @p !b @p ( /) dec ( /) pop bx@ ; ( /) ] !b drop ; | , = $f 1704 bin

{block 391}

: idle ( main program of coprocessor nodes. feeds owner instruction to give us the vm opcode and executes it.) | cr
opcodes [ must return to idle when done. | cr
] port ( code for owner) [ must ( end with return.) | br


: 'next ( length is) # 12 ( vs) # 4 ( or) # 5 ( in bitsy, argh.)

{block 392}


{block 393}


{block 394}
( bitsy up exxx) 205 node 0 org ]
: xqt = $0 @b push ex
: idle = $1 @p !b xqt ; ( /) ] drop !p . . ( /) = $3 | br


: start = $3 up b! idle ;
: free = $5 @p !b pop ; ( /) ] . ; ] .. | br

= $7 [ exit
: no-op = $3 @p !b ; ] .. ( /) ; ] .. = $5
: upop = $5 @p !b ; ] .. ( /) bpopw = $7
: upsh = $7 @p !b ; ] .. ( /) bpshw = $9
: uin = $9 ( -n) @p !b @b ; ( /) ] !p .. = $b
: uout = $b ( n) @p !b !b ; ( /) ] @p .. = $d
: uid = $d upop uin 205 . + uout upsh no-op ; | , = $14 1705 bin

{block 395}

: idle ( main program of coprocessor nodes. feeds owner instruction to give us the vm opcode and executes it.) | cr
opcodes [ must return to idle when done. | cr
] port ( code for owner) [ must ( end with return.) | br



{block 396}


{block 397}


{block 398}
( serial transmit) 100 node $0 org ]
: !bit ( im-i) = $0 over and | cr
if # 0 ( dumb) $25555 ( maxim) # $35555 !b drop ; | cr
] then # 1 ( dumb) $35555 ( maxim) # $25555 !b drop ;
: putc ( dc-d) = $5 -
: putchar ( di-d) = $6 $ff or 2* | cr
9 for = $a ( 1-start, 8-data, 1-stop bit) | indent
     1 !bit 2/ over for . unext | cr
next = $e drop ( weak-pulldown) # $15555 ( !b) ; | br

= $f $20 org ( programmed with abandon)
: start io b! right a! 2400 ( est.) # 115200 ( baud) | cr
( stopbit state dumb) $25555 ( maxim) # $35555 !b
: wait ( d-.d) = $27 @ -if ( tx!) putchar wait ; | indent
     ] then ( !io) up a! ! .. @ right a! wait ; | br


: send ( cd) = $2f over putc send ;
: send/ ( d) = $31 $40 begin dup push putc | indent
     pop 1 . + $5f and end | , = $3a [ 1706 bin

{block 399}
( notes-) | indent
     tx ( is inverted for compatibility with the boot node conventions, i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo.) | br


: putchar ( takes a clean inverted octet and transmits it low bit first via p17.) | br


: wait ( suspends while waiting for inverted character or a new delay value.) | cr
| indent
     [ the first terminal operation must set | cr
the delay! | indent
     ] send ( and) send/ ( test the bit timing using external loop-back.)

{block 400}
( - receive) 200 node $28 org ]
: @bit ( cm-c) @b - over - and push and pop or ;
: getc ( d-dc) = $2b dup begin drop @b -until
: getchar ( dx-dc) = $2d over 2/ for . unext ( 1/2 bit) 8 for ( 1-start, 8-data, 1-stop bits) | indent
     $1ffff @bit 2/ over for . unext | cr
next 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ $ff and ; | br


: baud ( n-dd) = $3a if dup ; ] then - push | cr
= $83d begin @b . -until ( at start-bit of space) | , = $3e begin @b - -until ( at 1-bit) | cr
= $3f begin @b . zif then . -until ( at 0-bits) | cr
= $41 begin @b - zif then . -until ( stop-bit) | cr
pop - ( n) dup 2/ . + ( 1.5n) dup ; | br


: auto = $46 a push up a! @ baud ! pop a! dup !
: idle ( d) = $4c @b -if getchar - | indent
     @b 2* - -if over ! then drop drop idle ; ] then $200 and .. if auto ; ] then drop idle ; | br

= $58 $20 org ( programmed with some abandon)
: start io b! $5555 !b right a! 2400 idle ; | , = $27 1707 bin

{block 401}
( notes-) | indent
     rx ( is inverted for compatibility with the boot node conventions, i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. received characters may have one stop bit.) | br


: getchar ( called after seeing leading edge of start bit. returns clean inverted character. must be called before start bit begins!) | br


: baud ( space is 1...1'0010.0000'0) | indent
     ( stop bits ---' .hex..20. '--- start) | br


: idle

{block 402}
( - interface) 104 node $20 org | cr
( programmed with abandon)
: start io b! right a! ahead
: rx? = $24 $400 and .. if ( avail) up a! @ then
: rtn ( w-) = $29 $ffff and right a! ! | cr

: idle = $2d then @b 2* .. [ ' rx? ] -until | indent
     ( not read) 2* [ ' idle ] -until | indent
     ( write) @ 2* 2* 2/ 2/ .. -if
: tx! ( c-) = $33 @b $1000 and if ( full) drop rtn ; | indent
     ( room) ] then left a! over ! rtn ;
: iox ( c-) = $3a then left a! ! | indent
     up a! begin @ - -until - rtn ; | , = $40 1708 bin

{block 403}
( notes-) | indent
     ] idle ( is a polling loop waiting for) | cr
[ right ( reading -) rx? ( returns) ] 16-bit inv | indent
     character ( from recv queue or) 0 ( if) | indent
     ( queue is empty.) | cr
[ right ( writing - do) tx! ( for) ] 16-bit inv | indent
     character ( or) [ iox ( for) ] 16-bit pos | indent
     bit delay ( input.) | cr
| indent
     [ tx! ( returns the) ] 16-bit inv character ( when the xmit queue is full and) 0 ( otherwise.) | cr
| indent
     [ iox ( suspends until it puts the) ] 16-bit pos bit delay ( in the xmit queue and again while it discards any) inv characters ( in the recv queue before the new) pos bit delay ( arrives.)

{block 404}
( generate ganglia) | , | , 700 node $20 org reclaim | , ( rlud) ] r--- --l- ---u -d-- [ 2 fh load | , 1716 bin = $40 | , | , 701 node $20 org reclaim | , ( rlud) ] --l- r--- ---u -d-- [ 2 fh load | , 1717 bin = $40 | , | , 600 node $20 org reclaim | , ( rlud) ] r--- --l- -d-- ---u [ 2 fh load | , 1714 bin = $40 | , | , 601 node $20 org reclaim | , ( rlud) ] --l- r--- -d-- ---u [ 2 fh load | , 1715 bin = $40

{block 405}
( background nodes are filled by default with) | , ( ganglia, routing code in) # $20 ( to) # $3f ( thus they) | , ( may support either ide or neural messaging) | , ( until node is programmed some other way.) | , | , ( routing directions are geographic.) | , | ... ( coded direction rlud 0123) | , | , ( four bins hold node orientations...) | , | ... # 1716 # 100 | .. # 1717 # 101 | , | ... # 1714 ( 000) | .. # 1715 ( 001) | , | , ( routing note- step count is relative to the node first receiving one of these messages. if) | , ( all counts zero will deliver to its neighbor) | , ( in direction indicated by two lsb of path. a) | , ( turn to deliver to right neighbor of turner) is not expressible ( because whole field zero.) | , third run must never have count 8 or more!

{block 406}
( - ganglion template) | , | , ( a whence b whither) | , ( msg is focus call path cin-1 cout-1 code) | , | , # $20 ( org rlud r--- --l- ---u -d--)
: aim = $24 ( p-pa) dup 3 and $20 or b! @b dup b! !b | , @p ; ( / pump) ] leap
: whither = $2a ( p) -4 . + aim !b ( path) !b | , ( cnts) @ dup push !b @ dup push !b
: payload = $30 begin @ !b unext | , | ... begin @b ! unext ;
: /8 = $32 ( n-n) 2/ 2/ 2/ ;
: pump = $33 then pop a! @ dup
: turn ( pp) $3c and if drop whither ; ] then | , | ... drop dup $fc0 and if drop /8 /8 dup turn ; | , ] then drop aim ( cnts) @ push @ push payload ; | , = $40

{block 407}
( ganglia route messages much like chuck's 'sea' delivers exchanges of) # 1 ( or more word out and) | , # 1 ( or more word reply to arbitrary nodes with) | , ( source routing. message structure is...) | , | , | .. ] focus call ( to port) [ always there | , | .. | .. ] pump call [ interganglion only | , | .. | .. ] path ( see below) [ inter only | , | .. | .. ] reply count ( words-1) [ inter only | , | .. | .. ] payload count ( words-1) [ inter only | , | .. ] payload [ always there | , | .. ] reply [ always there | , | , ( path has) # 3 ( 6-bit runs low order taken first) | , ( run encoded nnnndd path has 3 runs,) | , | ... ( 2-bit direction rlud 0123) | , | ... ( 4-bit count 1-relative zero deliver immed) | , | ... | ... ( 3rd run must be lt) # 8 | , ( example from 708 to 617 go down 1 and right 8) | , | ... ( 8 0 1 3 packed as 807) in octal. | , | , ( when an exchange is finished all) | , ( ganglia are back where they were) | , ( on receipt of focusing call.)

{block 408}
( - snorkel) reclaim 207 node 0 org ]
: mk! ( fp'm)
: /! ( an-a) = $0 push dup - !b over - !b pop !b ;
: a+ = $3 ( ap-ap+) push 1 . + $10000 over and if | , | ... or 1 then pop . + ;
: +@ = $b ( a-an) a+ | *
: /@ = $c ( a-an) dup !b over !b @b ;
: @w = $e ( a-a'u) /@ 7 for 2* 2* unext | , | ... push +@ pop or ;
: dma = $14 ( x/r) a+ @w push +@ push +@ pop begin | , | ... pop pop dup push over push push drop ex | , next pop drop drop drop ( func) +@ push ;
: x16 = $20 ( x) dma /@ ! a+ ;
: r16 = $23 ( x) dma @ /! a+ ;
: x18 = $26 ( x) dma @w ! a+ ;
: r18 = $29 ( x) dma @ dup push 7 push | , | ... begin 2/ 2/ unext 3 and /! a+ pop /! a+ ;
: fin = $33 ( x) dup /! ( +three) dup - $8000 mk!
: idle = $37 ( begin) @b # 2 4 dup dup or /@ ( until) | , | ... push dup /! pop over @w a! ( func) +@ push ; | , = $40 1605 bin reclaim exit

{block 409}
] to activate snorkel ( wait till) [ mmptr ( zero then write addr of a) sequence/x ( to it and stim.) | , mmptr ( zeroed after stim and you may queue 2nd) x ( by writing and posting another stim.) mmptr | , ( defined in idle,) # 2 ( for node 108,) # 4 ( for 207.) | , | , ] x ( has) # 2 ( wd) [ port address ( followed by one or more) function/arg groups. ( all x) | *
: must | *
: be ( in bottom 64k of memory!) | , | , function/arg group ( is) # 1 ( word) [ jump adr ( in snork followed by) args ( if any.) funcs ( are...) | , ] x/r 16/18 ( count18, adr20) | , fin ( done-flg awaken?) | , | , ( if focusing call desired it must be first word in first transmit.) [ nothing about this code | , depends on using ganglia ... can source ide or any other reasonable protocol including direct stream or ad hoc node to node transfer.

{block 410}
( spi flash sst25wf080) reclaim 705 node 0 org ]
: entry = $0 pop a! ( delay) @
: nxt = $1 ( d-d) @ push ex . nxt ; | , | ,
: null = $3 ( d) dup !
: done = $4 ( d) -++ !b await ;
: cmd = $7 ( d) dup select
: out = $8 ( d) @ for @ 2* 2* 8obits zif | , | ... drop ( pop drop) ; ] then 8obits drop next ;
: byte = $10 ( d-dw) dup dup or
: +byte = $11 ( dw-dw) 7 push begin begin | , | ... --- !b --+ !b . @b -while | , | ... | ... drop - 2* - next ; ] then drop 2* next ;
: bytin = $1e ( d) @ for byte zif ! done ; | , | ... ] then +byte ! next done ;
: wout = $25 ( d) @ push .. zif begin | , | .. select $2b400 8obits drop [ swap ] then | , | .. | .. @ 2* 2* 8obits 8obits drop select dup | , | ... | ... begin drop @b -until drop next null ;
: slob = $33 ( d-dw) dup dup or
: +slob = $34 ( dw-dw) 7 push ibits ;
: slowin = $37 ( d) @ for slob zif ! done ; | , | ... ] then +slob ! next done ; | , = $3e 1606 bin reclaim

{block 411}
( timing roughly) # 53 ( ns 19.2 mhz read clock) | , ( clk low 16.5 ns 30. mhz so this is good for) | , ( all sst25wfxxx parts as well. with mk1 sram) | , ( we get) # 555 ( us block read time.) | , | , ( registers b-io a-boss t-delay r-cmd. command) | , ( stream starts with dly and then funcs...) | , | ,
: done ( deselect) [ and end operation. ]
: null ( does so after sending a dummy byte in.)
: cmd ( selects and pumps a command)
: out ( given nbyt-1 sends nbyt bytes to device.)
: bytin ( given nbyt-1 receives nbyt bytes from) | , | ... ( the device) [ and ends operation. ]
: wout ( given nwds writes nwds 16-bit words to) | , | ... ( the device in aai mode. used immed after) | , | ... ( address, should be followed by wrdi rdsr.) | , | ,
: slowin ( given nbyt-1 receives nbyt bytes from) | , | ... ( the device. used for slow mmc.)

{block 412}
( minimal spi) reclaim 705 node 0 org | , ( working before speed up)
: entry = $0 pop a! ( delay) @
: nxt = $1 ( d-d) @ push ex . nxt ; | , | ,
: null = $3 ( d) dup !
: done = $4 ( d) -++ !b await ;
: cmd = $7 ( d) dup select
: out = $8 ( d) @ for @ 2* 2* 8obits zif | , | ... drop ; ] then 8obits drop next ;
: byte = $10 ( d-dw) dup dup or
: +byte = $11 ( dw-dw) 7 push ibits ;
: bytin = $14 ( d) @ for byte zif ! done ; | , | ... ] then +byte ! next done ; | , = $1b 1606 bin reclaim

{block 413}
( minimal code but slow; timing roughly) # 64 ( ns or 15.4 mhz read clock, low) # 31 ( ns; write) # 76 ( ns or 13.2 mhz. when delay is zero. addl delay about) # 4 ( ns per count.) | , ( command stream starts with dly and then funcs) | , | ,
: done ( deselect) [ and end operation. ]
: null ( does so after sending a dummy byte in.)
: cmd ( selects and pumps a command)
: out ( given nbyt-1 sends nbyt bytes to device.)
: bytin ( given nbyt-1 receives nbyt bytes from) | , | ... ( the device) [ and ends operation.

{block 414}


{block 415}


{block 416}


{block 417}


{block 418}


{block 419}


{block 420}


{block 421}


{block 422}


{block 423}


{block 424}


{block 425}


{block 426}


{block 427}


{block 428}


{block 429}


{block 430}


{block 431}


{block 432}


{block 433}


{block 434}


{block 435}


{block 436}


{block 437}


{block 438}


{block 439}


{block 440}


{block 441}


{block 442}


{block 443}


{block 444}


{block 445}


{block 446}
( - sram loader nodes) | , | , ( wires) 605 node 0 org ]
: wire ( b! a!) @ dup !b for @ !b unext warm ; | , = $4 1711 bin | , | , ( sram loader node) # 108 | , 108 node $39 org 278 load | , 0 org | *
: start = $0 up a! left b! | , 0 @ dup push over x! | , begin 1 . + @ over x! next warm ; | , = $d 1713 bin

{block 447}
( minimal version of plumbing for sram boot from flash. wires are compiled only once and are) | , ( initialized with source port in a and dest) | , ( port in b.) | , | , ( message consists of word count n-1 followed by n words to be passed along.) | , | , ( node) # 108 ( now loads the image received from) | , ( flash into sram.) # 208 ( is just another wire) | , | , ( however, the generic sram interface code is) | , ( compiled at the usual place anyway, so this) | , ( bin can be used by both the streamer and the) | , ( ide)

{block 448}
( - spi flash) # 8 ( bits) 705 node 0 org host ]
: resume nnc 2 * $8000 + block @ $fffff and | indent
     18 8 */ 4 * lit ; target ]
: wait ( dw-dw) = $0 select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) = $4 select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) = $9 io b! ( fast) 5 ;
: fet ( ah al-d) = $c push push set ( read) $c00 cmd pop !8 pop 8obits !8 ;
: 16ibits ( d-db) = $12 dup 15 for | cr
rbit ibit - next $ffff and ;
: start = $19 down a! 0 $20000 fet | cr
16ibits dup ! for 16ibits ! next | indent
     resume fet 18ibits $1e000 . + - -if
: done io b! 20 20 -++ half warm ; ] then | cr
5 resume push spicmd spi-boot ; | cr
= $34 1710 bin

{block 449}

: start ( 1st word read is count in words)

{block 450}
( polyforth ide boot) host load loader load | , ( kill boots) 0 708 hook 0 -hook ]
: s1+ ( nm-mn') swap [ 1 ] + ; | , | , ( custom routes) 2 fh load sram 4 + load | , ( select) pfp0 'pths ! pfp1 'pths 1 + ! | , | ... s708 'pths 2 + ! | , ( vm build tools) 4 fh load 14 fh load | , | , ( sram) 6 fh load 1 ship | ,
: !img ( n) push [ fbuf ] 0 begin over 2@ swab | , over sm swap [ 2 ] + s1+ next drop drop ;
: !nuc [ chr ] @ 2/ [ 1 ] + !img ; | , | ... 1 108 hook !nuc | . unfoc 1 -hook | , | , ( rest) pf 2 + load | . 2 ship | . panel upd ?ram | ,

{block 451}
( customize ide for polyforth development.) | br


: pf ( loads polyforth f18 code, nucleus in sram, and starts it up.) | br

[compile] ***no [compile] canonical [compile] opcodes*** | cr
[ use the ] 'remote' [ ones

{block 452}
( - custom ide paths) | , | ,
: pfp0 align create [ 708 707 to 607 207 to | , 206 205 to -1 , | , | ,
: pfp0 align create [ 708 308 to 309 315 to -1 , | , | ,
: pfp1 align create ( sram) [ 708 108 to 107 7 to | , 8 9 to -1 ,

{block 453}
( paths) # 0 ( and) # 1 ( are customized for interactive devel and testing of polyforth.) | , | ,
: pfp0 ( is not used by the loading procedures and is available for detailed application testing. if more paths are needed in testing, stuff new path vectors after) pf ( is loaded.) | , | ,
: pfp1 ( is used after reset to load and start the sram cluster, then boot sram as needed.)

{block 454}
( - sram user code from nodes 106, 108,) # 207
: 2lit' ( nn-) swap lit' lit' ;
: sm ( wa-) 2lit' [ $39 ( x!) ] call ;
: sem ( wap-) push 2lit' pop lit' [ $3a ( ex!) ] call ;
: fm ( a-w) lit' [ $3c ( x@) ] call
: get ( -w) upd [ stak ] @ rdrop ;
: fem ( ap-w) 2lit' [ $3d ( ex@) ] call get ;
: 4lit' ( nnnn-) push push 2lit' pop pop 2lit' ;
: cxm ( wapw-f) 4lit' [ $3e ( cx?) ] call get ; | cr
| cr
( sram test code)
: fmem ( ap-...) 8 for push dup i fem | indent
     s1+ pop next drop drop ;
: smem ( wapn-) for push over over i sem | indent
     s1+ s1+ pop next drop drop drop ;
: n2x ( wapn-) 4lit' [ $42 ( n2x) ] call ;
: nqx ( wapn-) 4lit' [ $4a ( nqx) ] call ; | br



{block 455}
( this tester code assumes the ide is hooked to one of the sram user nodes.)

{block 456}
( - ph0 sram setup) | br

( kill boot nodes) # 2 # 2 ( hook) # 2 ( -hook) # 1 ( path) | br

( sram setup) sram 2 + load | br

( temporary) 108 +node 1713 /ram left /b

{block 457}
( load sram cluster for booting pf nucleus) | br

( this is done with ide path) # 1 ( from) # 708 ( down to) # 108 ( before any of the rest of the chip is set up.) | br

( after it's completed, the whole rest of the chip can be booted using the serpentine path 2. this relatively byzantine method is used instead of simply reloading the sram with a more regular path so that the methods will still work with external dram.) | br

( this block leaves path) # 1 ( connected to sram for use by !pf)

{block 458}


{block 459}


{block 460}
( install pf in flash) | , | , empty ( 1st pass) compile streamer load | cr
framer load ( the stream) 466 load | br

empty ( 2nd pass) compile streamer load | cr
framer load ( the stream) 466 load | br

.stream | cr
( write stream into flash) | cr
( display stream length) strlen leng ! | , stream 0 swap 18burn | , ( ask permission to burn nucleus as well)
: esc key? esc ;
: ?cont esc [ keych ] @ 0 [ keych ] ! | , | ... [ $7f ] and [ $20 ] or drop if noask exit ; ] then ; | , .cont pause ?cont | , | ... ( erase and burn nucleus) 462 load

{block 461}
( pf stream) | br

( two passes required to calculate address) | cr
( to resume booting from after loading sram) | cr
( and compile it into node) # 705

{block 462}
( - burn pf nucleus) | , empty compile streamer load | , .nucleus nores | , | , ( read pfdisk.blk) 464 load | , | ... fbuf source ! 4607 len ! | , ( display nuc length) | , | ... len @ 1 + 2 * 8 18 */ leng ! | , | , | ... ( burn nucleus) stream $8000 swap burn

{block 463}
( load this block to install polyforth for flash booting. just follow instructions.) | , | , ( burns nucleus to flash starting at 32k then) | , ( generates and burns full chip boot stream.)

{block 464}
( -- read pf nucleus) :var ft :var chr [0x2400]
: a-b ( a-b) 2* 2* ; | *
: b-a ( b-a) [ 3 ] + 2/ 2/ ; | ,
: fbuf ( -a) [ nnc 2 * $8000 + block a-b ] ; | , | ,
: +pf [ 0 fnam b-a ] r/o fopen if [ ft ] ! ; | , ] then drop abort ;
: -pf [ ft ] @ [ 0 ] + if fclose 0 then [ ft ] ! ; | , | ,
: @nuc +pf [ fbuf ] 9216 [ ft ] @ frd [ chr ] ! -pf ; | , | , named ( pf/pfdisk.blk) | , | , @nuc

{block 465}


{block 466}
( - generate pf stream) | br

( speedup) | indent
     0 0 3 1608 /root | br

( default) entire course | cr
( sram driver) sram 2 + load | , ( flash to sram) 2 fh load | , frame adjust ( resume point) | , | , fresh ( residual) sram 4 + load s705 course | , | ... ( rest of chip) pf 2 + load | , | , frame

{block 467}


{block 468}
( -- load polyforth nucleus) | ,
: /nwire ( in out) /b /a 0 4 [ 1711 ] /part 0 /p ; | , | , 705 +node 1710 /ram $19 /p | , 605 +node down left /nwire | , 606 +node left right /nwire | , 607 +node right left /nwire | , 608 +node left up /nwire | , 508 +node up down /nwire | , 408 +node down up /nwire | , 308 +node up down /nwire | , 208 +node down up /nwire | , 108 +node 1713 /ram left /b 0 /p

{block 469}


{block 470}


{block 471}


{block 472}


{block 473}


{block 474}


{block 475}


{block 476}


{block 477}


{block 478}


{block 479}


{block 480}
( g144a12 ats test components) | br

( pkg) # 2000 ( to) # 2017 482 18 loads | cr
( pkg) # 2100 ( to) # 2117 518 18 loads | cr
( pkg) # 2200 ( to) # 2208 554 9 loads | br

( ats/ide parts) # 1200 ( to) # 1206 630 7 loads | br

( steven mem-random xxxx) # 576 # 1 ( loads) | cr
# 1400 ( to) # 1400 # 648 # 1 ( loads)

{block 481}


{block 482}
# 2000 ( port tests) | cr
( creeper) reclaim 0 node 1344 load $1b org ]
: release = $1b @p ! ; ( /) ] ; ( /)
: bit = $1d ( n-nn) @p ! dup dup ( /) @p !p .. ( /) | cr
! @ or ;
: walk = $20 ( n) 17 for bit if pop !b pop | cr
release ; ] then drop 2* next drop ; | cr
= $28 4 org | -cr : ftst a $1ff and $13400 or
: tst = $8 ( cport) dup a! ! | cr
$15554 dup walk dup - walk release dup or !b ;
: trd = $f leap ( tr) | -cr : td = $10 @p tst ; ] -d--
: tdr = $12 td | -cr : tr = $13 then @p tst ; ] r---
: tdl = $15 td | -cr : tl = $16 @p tst ; ] --l-
: tru = $18 tr | -cr : tu = $19 @p tst ; ] ---u | cr
= $1b [ 2000 bin

{block 483}
( port tests)
: bit ( send and receive 1 bit pattern via port)
: walk ( test with pattern shifted left) # 18 ( times)
: tst ( focus neighbor with a call then) | cr
( walk with) # 1 ( bit set and) # 1 ( bit clear) | cr
( shifting left on the test node)
: release ( causes node under test to return .) | cr
( error code) # 0 ( for success ,) | cr
( loop index for failure) | cr
parameter ( is ignored) | br

tests ( on single neighbor and on pairs) | cr
[ address $4 ( tests the) tfocused ( neighbor) | cr
$13 ( tests the) right ( neighbor) | cr
$10 ( tests the) down ( neighbor) | cr
$16 ( tests the) left ( neighbor) | cr
$19 ( tests the) up ( neighbor) | cr
$15 ( tests the) down ( and) left ( neighbors) | cr
$12 ( tests the) down ( and) right ( neighbors) | cr
$18 ( tests the) right ( and) up ( neighbors) | cr
$f ( tests the) right ( and) down ( neighbors)

{block 484}
# 2001 ( port tests with 2*) | cr
( creeper) reclaim 0 node 1344 load $1b org ]
: release = $1b @p ! ; ( /) ] ; ( /)
: bit = $1d ( n-nn) @p ! dup dup ( /) @p 2* !p .. ( /) | cr
! 2* @ or ;
: walk = $21 ( n) 17 for bit if pop !b pop | cr
release ; ] then drop 2* next drop ; | cr
= $2a 4 org | -cr : ftst a $1ff and $13400 or
: tst = $8 ( cport) dup a! ! | cr
$15554 dup walk dup - walk release dup or !b ;
: trd = $f | -cr leap ( tr)
: td = $10 @p tst ; ] -d--
: tdr = $12 td | -cr : tr = $13 then @p tst ; ] r---
: tdl = $15 td | -cr : tl = $16 @p tst ; ] --l-
: tru = $18 tr | -cr : tu = $19 @p tst ; ] ---u | cr
= $1b [ 2001 bin

{block 485}
( port tests)
: bit ( send and receive 1 bit pattern via port)
: walk ( test with pattern shifted left) # 18 ( times)
: tst ( focus neighbor with a call then) | cr
( walk with) # 1 ( bit set and) # 1 ( bit clear)
: release ( causes node under test to return .) | cr
( error code) # 0 ( for success ,) | cr
( loop index for failure) | cr
parameter ( is ignored) | br

tests ( on single neighbor and on pairs) | cr
[ address $4 ( tests the) tfocused ( neighbor) | cr
$13 ( tests the) right ( neighbor) | cr
$10 ( tests the) down ( neighbor) | cr
$16 ( tests the) left ( neighbor) | cr
$19 ( tests the) up ( neighbor) | cr
$15 ( tests the) down ( and) left ( neighbors) | cr
$12 ( tests the) down ( and) right ( neighbors) | cr
$18 ( tests the) right ( and) up ( neighbors) | cr
$f ( tests the) right ( and) down ( neighbors)

{block 486}
# 2002 ( extensive ram test jeff) | cr
( creeper) reclaim 0 node 1344 load $28 org ]
: err [ 4 org ]
: test ( n1) @p ! @p dup ( ') $3f push dup dup | cr
! @p ! ( ') or dup a! . | cr
@p ! ( ') begin dup !+ unext .. = $b ( erased) | cr
for | br

$19999 @p ! dup ( ') @p ! @ . | cr
! @p ! . ( ') !b @p ! | cr
@ or if = $12 pop err ; ] then = $13 ( test1) | cr
$cccc dup ! @p ( ') @ !b dup dup | cr
! @ or if = $18 pop err ; ] then = $19 ( 0 test2) | cr
@p ! . ( ') or ! . ( erased) | br

drop @p ! @p ( ') dup ( 0 0) - # $3ffff ! $3e | cr
! @p ! ( ') @+ !b push # $0 | cr
@ - if = $21 pop err ; ] then = $22 ( test3) | cr
drop @p ! ( ') begin @+ !b unext . # $0 | cr
$3e for @ if pop pop
: err = $28 1 + !b ; ] then = $2a ( test4) | cr
drop next | cr
@p ! . . ( ') dup !+ . next ( erased) | cr
dup dup or !b ; = $30 2002 bin

{block 487}
( test tests neighbor's memory) | br

( tests the tfocused node node's ram.) | cr
apocryphal documentation follows | br

( 19999 cccc test shorts to bits two bits away) | cr
( 3ffff) # $0 ( test shorts to bits one bit away) | cr
( tests for shorts between two addresses) | cr
( by reading) # 64 ( words after each) # $3ffff ( !) | cr


{block 488}
# 2003 ( testing t and s) | cr
( creeper) reclaim 0 node 1344 load $20 org ]
: echo = $20 ( n-n) @p ! dup .. ( /) @p - dup .. ( /) | cr
! @p ! .. ( /) drop !p .. ( /) - @ or ; 4 org ]
: test = $4 ( n) 17 for dup echo | cr
if pop 1 . + !b ; ] then drop 2* next | cr
dup or !b ; = $e 2003 bin

{block 489}
( testing t and s) | br

( intended to isolate testing to t and s) | cr
( non-zero return value identifies bad bit) | br

address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) | cr
( loop index for failure)

{block 490}
# 2004 ( testing t and r) | cr
( creeper) reclaim 0 node 1344 load $20 org ]
: echo = $20 ( n-n) @p ! dup .. ( /) @p - push .. ( /) | cr
! @p ! .. ( /) pop !p .. ( /) - @ or ; 4 org ]
: test = $4 ( n) 17 for dup echo | cr
if pop 1 . + !b ; ] then drop 2* next | cr
dup or !b ; = $e 2004 bin

{block 491}
( testing t and s) | br

( intended to isolate testing to t and r) | cr
( non-zero return value identifies bad bit) | br

address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) | cr
( loop index for failure)

{block 492}
# 2005 ( testing stack registers) | cr
( creeper) reclaim 0 node 1344 load 6 org ]
: put ( n) @p ! ! ; ( /) ] @p .. ( /)
: get ( -n) @p ! @ ; ( /) ] !p .. ( /)
: stack = $a 1 9 for dup put 2* next | cr
9 for 2/ get over or if pop 1 . + !b | cr
pop ; ] then drop next ; = $18 4 org ]
: start ( n) stack dup or !b ; = $6 2005 bin

{block 493}
( testing stack registers) | br

( fill the stack registers with unique) | cr
( numbers and read them back. error code) | cr
( identifies the register that failed the test.) | br

address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) | cr
( loop index for failure)

{block 494}
# 2006 ( testing return stack registers) | cr
( creeper) reclaim 0 node 1344 load = $4 ] ahead
: !error ( n) 1 !b ;
: put = $7 ( n) @p ! ! ; ( /) ] @p push .. ( /)
: get = $9 ( -n) @p ! @ ; ( /) ] pop !p .. ( /)
: fill = $b ( n-n) 8 for - dup put next ;
: check = $11 ( n-f) leap - then fill - | cr
9 for - get over or .. if !error pop ; | cr
] then drop next ;
: test ( n) then 0 check $15555 check | cr
( ..) $19999 check $33333 check | cr
( ..) dup or !b ; | cr
= $26 2006 bin

{block 495}
( testing return stack registers) | br

( fill neighbor return stack with alternating) | cr
( inverted patterns , then read back and verify each pattern ; relies on) ] s ( and) t ( of uut) | cr
( and instructions) @p !p push pop ( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) # 1 ( for failure) | br

( comment) - ( after) fill ( to force failure)

{block 496}
# 2007 ( mark ram test) # 200 ( node) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: store @p ! ; ] .. ( /) !+ .. ( /)
: fetch ( -n) @p ! @ ; ( /) ] @+ !b drop .. ( /)
: /neighbor 4 for @p ! unext ;
: /stack = $c $15555 # $2aaaa dup - over over over | cr
over over over over over over .. = $11 ; | br


: go ( entry) = $12 then /neighbor /stack
: testmem = $14 3 # 65535 for | cr
@p ! drop .. ( /) dup or a! .. ( /) | cr
$3f for store next $3f for fetch or if | indent
     pop pop 3 # 65535 or 1 . + !b ; | cr
] then drop next next | cr
( good) $0 # $12345 !b ; = $29 2007 bin

{block 497}
( worst case ram test looking for store failures when driving weak inverter high.) this test preserves b, a, and p. | br


: store ( makes target store next value in next wd)
: fetch ( makes target return next word in ram)
: /stack ( executed in either node sets stack to alternating) # $15555 ( and) # $2aaaa ( with) # $15555 ( on top.)
: /neighbor ( feeds) /stack ( to target node. doesn't pass the last word - return.) | br


: go ( sets both nodes' stacks that way then begins the) testmem
: testmem ( runs test cycles, must do at least 2. each cycle switches polarity) # $15555 ( or) # $2aaaa ( for first word stored, then stores alternating values into all ram in target. reads back and compares. if all cycles run ok, returns zero status. otherwise returns the) # 1 ( relative cycle number in which the failure occurred.)

{block 498}
# 2008 ( mark r d stack test) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: store dup ! dup ! dup ! ! ;
: fetch ( -n) @p ! @ ; ( /) ] !b .. ( /)
: /neighbor @p ! ! .. @p .. | cr
3 for @p ! unext ; ] ..
: /stack dup - over .. ( /) over over ( -) | cr
over .. ( /) over over over .. ( /) over .. ( /) ;
: t-stk = $14 | cr
dup /neighbor /stack = $16 | cr
# $fffe 8 for | cr
@p .. push push push .. store | cr
fetch drop @p .. pop pop pop .. store | cr
| cr
9 for fetch or .. if pop pop $ffff and pop drop !b ; ] then drop | cr
next next ; | cr
] then = $2b [ $2b org ]
: full = $2b $2aaaa t-stk dup or t-stk $33333 t-stk $19999 t-stk dup or t-stk # $0 dup or !b ; | cr
= $36 2008 bin

{block 499}
( testing return and data stacks registers) | cr
( also mulitple overs pops and pushes in the port) | br

( fill neighbor return stack with alternating) | cr
( inverted patterns , then push to return stack then pop to data stack then read back and verify each pattern ; relies on) ] b s t r r-stack ( and) d-stack ( of uut) | cr
( and instructions) @p !b over push pop ( in the port) | br

[ address $2b ]
: full ( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success , next count for failure) | br

( comment) - ( in) [ /stack ( after) ] over ( to force failure)

{block 500}
# 2009 ( +* a shift test) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: !error ( n) 1 !b ;
: init ( s) @p ! ! ; ( /) ] @p .. ( /)
: check ( an-a) over or if !error pop pop ; | cr
] then drop ;
: step ( tan-t'a') push .. | cr
@p ! ! .. ( /) @p a! @p .. ( /) | cr
! @p ! . ( /) +* !p a !p ( /) @ @ pop check ;
: start then | cr
1 init 0 $15555 $2aaaa step $15555 step | cr
( ......) 0 $19999 $2cccc step $16666 step | cr
2 init 0 $15555 $aaaa step $25555 step | cr
( ......) 0 $19999 $cccc step $26666 step | cr
dup or !b ; | cr
= $35 2009 bin

{block 501}
( testing a shifts by) ] +* | br

( tests the) # 4 ( combinations of shifting 1/0) | cr
( from t for add/notadd behavior of +* . the) | cr
# $19999 ( group checks the double shift error seen previously ; relies on) s ( and) t ( of uut) | cr
( and instructions) @p !p +* a a! ( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) # 1 ( for failure) | br

( replace pattern before) step ( with) 0 | cr
( to force failure)

{block 502}
# 2010 ( t s a and r data path tests) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: check or if pop !b pop ; ] then drop ;
: -t- ( n) dup @p ! .. ( /) @p !p .. ( /) ! @ ( 2*) check ;
: -s- ( n) dup @p ! dup ( /) @p @p !p !p ( /) | cr
! ! @ drop @ ( 2*) check ;
: t-a ( n) dup @p ! .. ( /) @p a! a !p ( /) | cr
! @ ( 2*) check ;
: t-r ( n) dup @p ! .. ( /) @p push pop !p ( /) | cr
! @ ( 2*) check ;
: start then = $19 $3ffff dup - $2aaaa | cr
dup - $33333 dup - $6666 dup - dup dup drop | cr
256 for drop -t- = $24 -s- = $25 | cr
( ............) t-a = $26 t-r = $27 next dup or !b ; = $29 2010 bin

{block 503}
( testing t s a and r data paths) | br

( does) # 32 ( reps of) # 8 ( patterns between t and) | cr
( the other registers; relies on instructions) | cr
] @p !p a! a push pop ( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success, address after) | cr
( test for failure) | br

( uncomment) 2* ( in each test to force failure)

{block 504}
# 2011 ( gpio pin test) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: !it ( n) = $5 @p drop !p ;
: its ( n-n) = $6 0 and ;
: ++ = $8 -1 | -cr : !io its ! ; | -cr : -- $2aaaa !io ;
: 500ns ( n) = $e 199 for unext ;
: .hi ( -n) = $11 15 for @ its if | cr
drop pop ; ] then drop next dup dup or ;
: .lo = $18 for @ $2aaaa and its while drop next | cr
dup dup or ; ] then drop pop ;
: start ( n) = $20 then !it io a! | cr
++ 500ns ( wpd) $15555 !io 8191 .lo | cr
-16 -- and 500ns ++ .hi or 500ns | cr
2* -- 2* 2* 2* 15 .lo or !b ; | cr
= $34 2011 bin

{block 505}
( drive test of a single gpio pin whose control bits are nonzero in the argument.) | br

( while testing a pin any other pins are set at high impedance so we can prove all three drive transistors work for this pin and detect any opens. other tests look for shorts between pins)

{block 506}
# 2012 ( mark d stack test) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: fetch ( -n) @p ! @ ; ( //) ] !b .. ( /)
: /neighbor @p ! ! .. @p .. | cr
3 for @p ! unext ; ] ..
: /stack = $c dup - over .. ( /) over over | cr
over .. ( /) over over over .. ( /) over ( -) . .. ( /) ;
: d-stack = $11 $8 for dup - /neighbor /stack = $16 next | cr
12 # $0 for drop fetch or if pop pop $ffff and ( !b) pop ( and) drop !b ; ] then | cr
next ; | cr
= $21 $2a org ] then
: full = $2a $2aaaa d-stack dup or d-stack $33333 d-stack $19999 d-stack dup or d-stack | cr
!b ; = $35 2012 bin

{block 507}
( testing data stack registers) | cr
( also overs in the port) | br

( fill neighbor return stack with alternating) | cr
( inverted patterns , then read back and verify each pattern ; relies on) ] b s t ( and) d-stack ( of uut) | cr
( and instructions) @p !b over ( in the port) | br

[ address $2a ]
: full ( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success , next count for failure) | br

( comment) - ( in) [ /stack ( after) ] over ( to force failure)

{block 508}
# 2013 ( io data path tests) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: check ( nn) or if pop !b pop ; ] then drop ;
: t-io ( mn-m) $15555 or dup @p ( /) @p ! @ !p ( /) | cr
! ! @ or over and over check ;
: start ( m) then = $e if 0 for | cr
io @p ! .. ( /) @p a! .. ( /) ! | cr
dup t-io = $16 0 t-io = $18 next then dup or !b ; = $1a 2013 bin

{block 509}
( testing io data path) | br

( checks that the masked bits return their) | cr
( inverse ; relies on) ] a ( of uut) | cr
( and instructions) @p !p ! @ ( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is a mask for the io bits) | cr
( to be tested . error code) # 0 ( for success,) | cr
( test's return address for failure) | br

( include unwritable bits in the mask) | cr
( to force failure)

{block 510}
# 2014 ( set/clear carry test) | cr
( creeper) reclaim 0 node 1344 load | br

$2a org ( test tools)
: +c = $2a ( n-c) a $200 or !
: +@ = $2d ( n-c) @p ! dup . ( /) . . . @p ( /) | cr
( ..) = $2f ! @p ! . ( /) @p . + !p ( /) ! @ a ! ;
: ?t = $33 ( c) or if pop !b pop then drop ; = $36 | br

$4 org ( test start) | cr
= $4 ( post args) ] push $20000 $0 begin | cr
= $7 ( clr nxt) dup +c ( ign was) drop .. | cr
= $9 ( set nxt) over +c ( tst clr) over ?t | cr
= $b ( set nxt) over +c ( tst set) $1 ?t | cr
= $e ( clr nxt) dup +c ( tst set) $1 ?t | cr
= $11 ( clr nxt) dup +c ( tst clr) over ?t | cr
= $13 ( nop nxt) over +@ ( see nop) over ?t | cr
= $15 ( set nxt) over +c ( tst clr) over ?t | cr
= $17 ( nop nxt) dup +@ ( see nop) over ?t | cr
= $19 ( clr nxt) dup +c ( tst set) $1 ?t | cr
= $1c next ( pass) !b drop ; | cr
= $1e 2014 bin

{block 511}
( test) ] p9 ( control of carry) | br

( verify that neighbor carry can be set or) | cr
( cleared under control of p9 and that carry is preserved when p9 is zero.) | br

( depends upon uut) p9 cry s ( and) t ( as well as) | cr
( uut) jump @p !p . + ( in port.) | cr
( test starts at) = $4 ( with loop count input.) | cr
# 12 ( words of ram are unused.) | cr
( error code is) ?t ( return address.) | cr
( verify by defeating any) ?t ( parameter.) | br


: +@ ( calculate n+n in test node, returning c) | cr
( then clear tested's p9.)
: +c ( set p9 in test node prior to add.)
: ?t ( match result to expected and abort with) | cr
( call address as return code in case of error.) [ note ( that loop count will clear high) ] r ( bits.)

{block 512}
# 2015 ( mark @p test) | cr
( creeper) reclaim 0 node 1344 load = $4 ] ahead | cr

: seq ( -n) = $5 63 .. a push 6 a! | cr
if dup -1 . + ! pop a! ; | cr
] then drop 63 ! pop a! ( @p!bunext;) $5b75 ;
: init = $11 @p ! @p .. ( /) @p a! .. ( /) [ 1 , ] ! | cr
63 for seq @p ! ! .. ( /) @p !+ .. ( /) next | cr
@p ! a .. ( /) @p push .. ( /) | cr
! @p ! @p ( /) @p push .. ( /) [ 63 , | cr
] ! @p ! ; ( /) ] dup or push ; ( /)
: /@p ( n) = $21 then init | cr
63 for @ seq ( -) or .. if pop !b ; | cr
] then drop next dup or !b ; | cr
= $2a 2015 bin

{block 513}
( testing @p) | br

( does) # 64 ( reps of @p on target covering all ram addresses; relies on target port instructions;) ] @p a! !+ dup or push ; | cr
( relies on target ram instructions;) | cr
] @p !b unext ; | br

address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success, target address) | cr
( for failure) | br

( uncomment) - ( to force failure)

{block 514}
# 2016 ( test i-ad and r-ad data paths) | cr
( creeper) reclaim 2 node 1344 load | br

( test start) | cr
= $4 ( @p;) ] $5500 63 for .. | cr
= $7 pop dup push dup @p ! ! .. ( /) @p dup a! @p = $a over or @p .. ( /) ! b! @b !p ( /) | cr
= $c over ! ! @ ( -) or .. if pop $40 or !b ; | cr
= $12 ] then drop next | cr
= $13 a @p ! .. ( /) @p b! .. ( /) ! .. ( dup or !b ;) | cr
= $16 ( call) $12000 63 for .. | cr
= $19 dup ! 1 @p ( /) !p .. ( /) ! . + dup | cr
= $1d @ ( -) or $3f and if pop $80 or !b ; | cr
= $23 ] then drop next ( dup or !b ;) | cr
= $24 ( ex) # $12040 dup 63 for .. | cr
= $26 @p ! ! @p ( /) @p push ex ( /) [ 1 , | cr
= $29 ] @p ! . + ( /) !p .. ( /) @ over ( -) or $3f | cr
= $2d and if pop drop $c0 or !b ; | cr
= $31 ] then drop dup .. next dup or !b ; | br

= $34 2016 bin

{block 515}
( test 8,5-0 of) ] i ( and) r ( to adrs bus) | br

( verify adrs drivers for above bits in uut.) | cr
( 1. using) a ( set) [ @p ; n ( in ram, where) n ( is) | cr
( -- loc of same word. chk ram via) ] b ( and) | cr
( -- return error code) [compile] 40+n ( if fail.) | cr
( 2. for) [ n ( of) [compile] 0-3f ( store) call-n ( /) !p .. ( into) | cr
( -- port and read back and confirm that data) | cr
( -- have the same low order) # 6 ( bits as the next -- call we are to send. return error code) | cr
( --) [compile] 80+n ( if fail.) | cr
( 3. same as test) # 2 ( using) ex ( instead of) call | cr
( -- return error code) [compile] c0+n ( if fail.) | br

( test starts at) = $4 ( with ignored input.) | cr
( depends upon uut) ] a b r s t ( and) ram ( as well as uut) call ex ; ] @p !p . push dup a! b! ! @b ( in ram or port.) | br

( failure is forced by uncommenting) [ - ( in) | cr
( each test)

{block 516}
# 2017 ( rom checksum) | cr
( creeper) reclaim 0 node 1344 load ]
: start ( n) = $4 0 63 for pop dup push $80 . + | cr
@p .. ( /) @p a! @ !p ( /) ! ! @ or next | cr
or if 1 then !b ; | cr
= $11 2017 bin

{block 517}
( rom check sums) | br

( does an xor checksum of the) # 64 ( target node rom locations ; relies on instructions) | cr
] @p !p a! a ( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is expected checksum) | cr
( error code) # 0 ( for success,) # 1 ( for failure) | br

[ 0 test ( to force failure)

{block 518}
# 2100 ( parallel port pin test) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: return ( n) pop dup b! push !b ;
: chk ( nn) = $7 or | cr
if pop pop drop pop drop return ; | cr
] then drop ;
: write ( n) = $c ( out) $15555 !b ! ;
: 50ns ( -n) = $e 18 for unext ( ;)
: sample ( -n) = $11 ( in) $14555 !b .. @ ( out) $15555 !b ;
: 300ns ( -n) = $15 124 # 87 for unext sample ;
: once ( n-n') = $18 | cr
dup write 50ns 0 chk = $1c 300ns over chk = $1e | cr
0 write 50ns over chk = $22 300ns 0 chk = $25 2* ;
: start ( n) = $26 then | cr
0 data a! io b! write 300ns 0 chk = $2e | cr
1 17 for once next drop !b dup or return ; | cr
= $35 2100 bin

{block 519}
( parallel port pin test) | br

( walking ones test of parallel port pins in) | cr
( nodes) # 7 ( and) # 9 ( , detects opens shorts and weak drive transistors .) | br

address $4 ( tests active node given arg which is ending io value.) note purpose is to control wr bit setting and if the bit does not work in either node the test will fail in one of em. | cr
( error code) # 0 ( for success,) | cr
( test's return address for failure) | br

( force an 'open pad' failure by running) | cr
( the test on node) # 9 ( of a chip with sram) | cr
( connected) | br

( force a 'short' failure by temporarily) | cr
( connecting a pin to power ground or a) | cr
( neighbor pin)

{block 520}
# 2101 ( mark @b !b test) | cr
( creeper) reclaim 0 node 1344 load ] ahead
: /t = $5 ( n) dup - .. ( /) @p ! ! ; ( /) ] @p .. ( /)
: /b! = $8 ( n) @p ! ! ; ( /) ] @p b! .. ( /)
: /!b = $a ( n) @p ! ! ; ( /) ] @p !b .. ( /)
: /@b = $c ( -n) @p ! @ ; ( /) ] @b !p .. ( /)
: end @p ! a . ( /) @p b! .. ( /) ! !b ;
: init = $11 then @p ! @p .. ( /) dup or a! . [ 63 , | cr
= $14 ] @p ! ! .. ( /) = $15 @p push .. = $16 ( /) | cr
@p ! .. ( /) = $17 begin a - !+ unext .. = $18 ( / ;) | cr
1 dup # $3e $3f for over . + /t dup /b! dup /!b next ( ;)
: chk-a = $21 1 dup $3f for over . + /t dup /b! dup /@b or .. if pop -1064 . + - !b pop drop ; ] then drop next
: b-adr 0 end ; | cr
= $32 2101 bin

{block 521}
( b-adr-data test; b-reg adr paths to ram and data path from t to ram and ram to t using b-reg) | br

( uses !+ to fill ram with -1 to -40) | cr
( next uses b to change ram to) # 0 ( to 3f) | cr
( next checks to see if ram successfully changed ; relies on instructions) | cr
] @p ( /) @p b! ( /) @b !p ( /) @p push ( /) dup or a! ( /) | cr
a - !+ unext ( / in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
( address +) # 1000 ( of failure for failure) | br

( uncomment) # $3e ( and comment) $3f ( in)
: init ( to force failure)

{block 522}
# 2102 ( mark t to b reg test) | cr
( creeper) reclaim 0 node 1344 load ( ahead) # $12 $14 org ]
: end = $14 @p ! a . ( /) @p b! .. ( /) ! !b ;
: /t = $17 ( n) dup - .. ( /) @p ! ! .. ( /) @p .. ( /) ;
: /b! = $1b ( n) @p ! ! .. ( /) @p b! .. ( /) ;
: /!b = $1e ( n) @p ! ! .. ( /) @p !b .. ( /) ;
: /@b = $21 ( -n) @p ! @ .. ( /) @b !p .. ( /) ;
: chk-a = $24 $3f and dup dup /t /b! /@b or ( -) .. if drop 1000 . + end pop pop pop ; ] then ;
: 2chk dup dup chk-a drop drop - chk-a drop drop chk-a ; = $36 $4 org ]
: init ( then) @p ! .. ( /) dup or a! .. ( /) | cr
$3f .. ( /) = $8 @p ! ! .. ( /) = $9 @p push .. = $a ( /) | , @p ! .. ( /) = $b begin a !+ unext .. = $c ( /)
: b-reg = $c dup or 2chk $aa 2chk $33 2chk $19 2chk | cr
= $14 ( end ;) | cr
[ 2102 bin

{block 523}
( b-reg testing t to b-reg) | br

( uses !+ to fill ram with) # $0 ( to) # $3f | cr
( next puts) # $0 ( on t and -1 on s) | cr
( next puts the) # $0 ( into b and does a @b with -1 on t) | cr
( next checks if t contains) # $0 | cr
( then does this for) # $3f ( ,) # $0 ( and other numbers ; relies on instructions) | cr
] @p ( /) @p b! ( /) @b !p ( /) @p push ( /) dup or a! ( /) | cr
( /) a !+ unext ( / in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
( address +) # 1000 ( of failure for failure) | br

( uncomment - in)
: chk-a ( to force failure)

{block 524}
# 2103 ( mark port to i-reg test) | cr
( creeper) reclaim 0 node 1344 load $1a org ]
: chk = $1a or if pop 1000 !b ; ] then ;
: rets @p ! a . ( /) @p dup push . ( /) | cr
( /) ! @p ! @p ( /) dup dup or . ( /) push push . . ( /) !
: init = $24 $15555 dup - over over ( -) over over | cr
( . 2/ .) over .. @p ! ! . ( /) @p a! @p @p ( /) | cr
.. ! ! @p . ( /) @p @p . . ( /) ! ( .) ! ! ;
: code = $2d @p - dup . ( /) begin a! !p drop unext ( /) - over ! ! @ push ( /) ! pop ; ( ; - @p dup) | cr

: -code = $32 @p dup - dup ( /) a! - @p dup ( /) push ! ! ! pop ! ; ( / ; !p drop unext) | br

= $36 $4 org ]
: i-reg = $4 rets ( ;) code over chk drop | cr
= $408 .. ( /) @p ! @ . ( /) a !p !p .. ( /) | cr
= $a - chk drop @ - chk ( / end first check) | cr
= $d rets .. ( /) @p ! @p . ( /) pop pop drop . ( /) push .. ( /) ! dup dup -code | cr
= $13 ( /) @p ! @ ( .) .. ( /) !p !p !p .. ( /) | cr
chk drop @ chk drop @ chk ( end second check) | cr
!b ; = $1a 2103 bin

{block 525}
( port testing port to i-reg) | br

( uses the instruction /) ] a! !p drop unext ( /) | cr
( first the inverse instruction is sent then the instruction then the inverse instruction again) [ note ( the inverse of) ] a! ( is) ; | cr
( next the inverse of instruction /) ] a! - @p dup ( is used, except for the) a! ( /) | cr
[ note ( the pre and post instructions begin with) ] ; ( and don,t effect the stack) | cr
( after each triplet the stack is checked;) | cr
( relies on instructions) | cr
] @p dup push . ( /) dup dup or . ( /) push push .. ( /) @p a! @p @p ( /) @p @p . . ( /) a !p !p . ( /) | cr
pop pop drop . ( /) push .. ( /) | cr
( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: init ( to force failure)

{block 526}
# 2104 ( mark port to i-reg-bit-short test) | cr
( creeper) reclaim 0 node 1344 load # $13 $17 org ]
: chk = $17 or if pop pop 1000 # $1000 !b ; ] then drop ;
: init = $1c $3807 dup 2* dup 2* dup dup | cr
2* dup dup 2* dup dup | cr
.. @p ! @p . ( /) @p @p @p . ( /) [ $12345 , ( . 2/ .) ] ! ! ! ;
: read = $25 ( /) @p ! @ . ( /) !p !p !p . ( /) @ @ ; | br


: code = $28 ( /) @p ; ( /) ] and @b and @p ( /)
: -code = $2a ( /) @p ; ( /) ] @b and @b + ( /) | br


: run = $2c -code ! ( .) ! ! ( .) code ! ( .) ! ! ( .) | cr
-code ! ( .) ! ! ( .) ; | cr
| br

= $32 $4 org ]
: i-reg = $4 init run read $12345 chk $10020 chk $1502a chk | cr
dup or !b ; = $e 2104 bin # $9813

{block 527}
( i-reg-bits testing port to i-reg for) | cr
( shorted adjacent bits) | br

( uses the instructions /) ] and @b and + ( /) | cr
( and) @b and @b + ( checked;) | cr
( relies on instructions) | cr
@p dup push . ( /) dup dup or . ( /) push push .. ( /) @p a! @p @p ( /) @p @p . . ( /) a !p !p . ( /) | cr
pop pop drop . ( /) push .. ( /) | cr
( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: init ( to force failure)

{block 528}
# 2105 ( mark port to i-reg-bit-short test) | cr
( creeper) reclaim 0 node 1344 load $1a org ]
: chk = $1a or if pop pop 1000 # $1000 !b ; ] then drop ;
: init = $1f | cr
dup or - dup 2* dup 2* dup 2* dup 2* dup 2* dup 2* ( /) | cr
.. ( /) @p ! a . ( /) @p push @p @p ( /) | cr
( /) ! ! ! @p ( /) @p @p @p @p ( /) ! ( . 2/ .) ! ! ! ! ; | cr

: 3code = $29 ( /) @p dup dup . ( /) - - - . ( / !p !p !p ;)
: run = $2b push ! - ! @ @ @ pop ! | cr
.. ( /) @p ! @ . ( /) !p !p !p . ( /) @ @ ; | br

= $31 $4 org ]
: i-reg = $4 init 3code $3ffc0 chk $3ffe0 chk $f chk $3fff8 chk $3fffc chk $1 ( -) chk | cr
| cr
dup or !b ; = $13 2105 bin

{block 529}
( i-reg-bits testing port to i-reg for) | cr
( shorted adjacent bits) | br

( uses the instructions /) ] - - - . ( /) !p !p !p ; ( / relies on instructions) | cr
( /) ] !p !p !p . ( /) @p @p @p @p ( /) @p push @p @p ( / . in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: init ( to force failure)

{block 530}
# 2106 ( mark port to i-reg-bit-short test) | cr
( creeper) reclaim 0 node 1344 load $18 org ]
: chk = $18 or if pop pop 1000 !b ; ] then drop ;
: init = $1d dup or - dup 2* dup 2* dup 2* | cr
dup 2* dup 2* dup 2* dup 2* dup 2* dup 2* | cr
.. ( /) @p ! a . ( /) @p dup push . ( /) | cr
.. ( /) ! @p ! . ( /) push @p a! @p ( /) | cr
= $27 ! ! @p . ( /) @p @p @p @p ( /) ! ( . 2/ .) ! ! ! ! ; | cr

: 2code = $2b ( /) @p - dup . ( /) !p - a! . ( / - !p ; ;)
: run = $2d - over push push ! @ pop ! @ pop ! @ | cr
.. ( /) @p ! @ . .. ( /) a !p !p . ( /) @ .. ; | br

= $35 $4 org ]
: i-reg = $4 init 2code $3ff00 chk $3f chk $7f chk $3ffe0 chk $f chk | cr
dup or !b ; = $11 2106 bin

{block 531}
( i-reg-bits testing port to i-reg for) | cr
( shorted adjacent bits) | br

( uses the instructions) | cr
( /) ] !p - a! . ( /) - !p ; ] ; ( /) | cr
( relies on instructions) | cr
( / /) ] @p dup push . ( /) push @p a! @p ( /) | cr
( /) @p @p @p @p ( /) a !p !p . ( /) | cr
( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: init ( to force failure)

{block 532}
# 2107 ( mark port to i-reg-bit-short test) | cr
( creeper) reclaim 0 node 1344 load # $18 $17 org ]
: chk = $17 or if pop pop 1000 # $1000 !b ; ] then drop ;
: init = $1c | cr
dup or - dup 2* dup 2* dup 2* dup 2* ( /) | cr
.. ( /) @p ! a . ( /) @p dup push . ( /) | cr
( /) ! @p ! . ( /) push @p a! . ( /) | cr
= $23 ! @p ! . ( /) @p @p @p @p ( / . 2/ .) ! ! ! ! ; | cr

: 1code = $27 ( /) @p - dup . ( /) - a! - . ( / !p ; !p ;)
: run = $29 ! @ ( ;) push dup - ! ! pop @ | cr
.. ( /) @p ! @ . ( /) !p a !p . ( /) @ ;
: 0code = $2f ( /) @p - dup . ( /) a! - . . ( / ; !p c c)
: 0run = $31 - over ! ! ! | cr
.. ( /) @p ! @ . ( /) a !p !p !p ( /) @ @ ; | br

= $36 $4 org ]
: i-reg = $4 init 1code $1 chk $3fff8 chk 3 chk $3ffff chk | cr
= $e init 0code $3fffc chk $1 chk $3ffff chk | cr
dup or !b ; = $17 2107 bin

{block 533}
( i-reg-bits testing port to i-reg for) | cr
( shorted adjacent bits) | br

( uses the instructions) | cr
( /) ] a! - . . ( /) ; ] !p c c ( /) | cr
( /) - a! - . ( /) !p ; ] !p ; ( /) | cr
] @p dup push . ( /) dup dup or . | cr
( relies on instructions) | cr
( /) a !p !p !p ( /) !p a !p . ( /) @p @p @p @p | cr
( /) push @p a! . ( /) @p dup push . ( /) | cr
( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: init ( to force failure)

{block 534}
# 2108 ( mark port to i-reg-bit-short test) | cr
( creeper) reclaim 0 node 1344 load $15 org ]
: chk = $15 or if pop pop 1000 # $1000 !b ; ] then drop ;
: init = $1a | cr
dup or - dup 2* dup 2* dup 2* dup 2* ( /) | cr
.. ( /) @p ! a . ( /) @p dup push . ( /) | cr
( /) ! @p ! . ( /) push @p a! . ( /) | cr
= $21 ! @p ! . ( /) @p @p @p @p ( /) ! ( . 2/ .) ! ! ! ; | cr

: +code = $25 ( /) @p - dup . ( /) a! a! a! . ( / ; ; ; ;)
: +run = $27 - over ! ! ! | cr
.. ( /) @p ! @ . ( /) a !p !p . ( /) @ ; | br

= $2c $4 org ]
: i-reg = $4 init +code $3fff8 chk $3fffc chk | cr
= $a dup or !b ; = $b 2108 bin

{block 535}
( i-reg-bits testing port to i-reg for) | cr
( shorted adjacent bits) | br

( uses the instructions) | cr
( /) ] a! a! a! . ( / ; ; ; ; /) | cr
( relies on instructions) | cr
( /) @p dup push . ( /) push @p a! . ( /) | cr
( /) @p @p @p @p ( /) a !p !p . ( /) | cr
( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: init ( to force failure)

{block 536}
# 2109 ( mark port to i-reg-bit-short test) | cr
( creeper) reclaim 0 node 1344 load $15 org ]
: chk = $15 or if pop pop 1000 !b ; ] then drop ;
: init = $1a dup or - dup 2* dup 2* dup 2* | cr
dup 2* dup 2* dup 2* dup 2* dup 2* ( /) | cr
.. ( /) @p ! a . ( /) @p dup push . ( /) | cr
( /) ! @p ! . ( /) push @p a! @p ( /) | cr
= $23 ! ! @p . ( /) @p @p @p @p ( /) ! ( . 2/ .) ! ! ! ! ; | cr

: -code = $27 ( /) @p ; ( /) ] @p @p @p ; ( /)
: +code = $29 ( /) @p ; ( /) ] a! a! a! . ( / ; ; ; ;)
: -run = $2b +code ! -code ! ( .) ! ! ! ( .) +code ! | cr
.. ( /) @p ! @ . ( /) a !p !p !p . ( /) @ @ ; | br

= $33 $4 org ]
: i-reg = $4 init -run $3ff80 chk $3ffc0 chk $3fffc chk | cr
dup or !b ; = $d 2109 bin

{block 537}
( i-reg-bits testing port to i-reg for) | cr
( shorted adjacent bits) | br

( uses the instructions) | cr
( /) ] @p @p @p ; ( /) ] a! a! a! . ( /) ; ] ; ] ; ] ; ( /) | cr
( relies on instructions) | cr
( /) ] @p dup push . ( /) push @p a! @p ( /) | cr
( /) @p @p @p @p ( /) a !p !p !p . ( /) | cr
( /) | cr
( in the port) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: init ( to force failure)

{block 538}
# 2110 ( mark prp-call test) | cr
( creeper) reclaim 0 node 1344 load # $d # $c $9 org ]
: p-r-p dup $1 . + $7e for
: init # $2 # $3 dup ( 3) push over a | cr
# $3 ( .) # $2 ( a) pop ( 3) a push dup push $1 . + | cr
# $3 ( .) # $2 ( a) # $4 dup a! - # $3f $7f and | cr
# $3 ( .) # $2 ( a) # $3b dup push $13000 or pop | cr
# $3 ( .) # $2 ( a) # $1303b # $3b pop # $3 ( .) # $2 ( a) # $3b # $3 | cr
a # $4 pop a! # $4 push | cr
( /) .. @p ! ! . ( //) @p @p @p @p ( /) | cr
( /) ! ! ! @p ( //) @p .. ( /) ! ! | cr
8 for @p ! unext | cr
( /) # $2 a! @p !+ . ( /) !b pop !b . ( /) | cr
( a) push !+ @p .. ( /) ; ( /) | cr

: forcefail !+ dup .. ( /) # $3b a! # $3b ( . 2/ .) @p @p .. !b pop !b . ( /) pop dup push ; | cr
] !+ !+ push .. ( /) | cr
| cr

: calls = $2a # $3 pop # $4 over # $3 $11000 or ! ( ? @ ; ?) | cr
( /) .. @p ! @ .. ( //) !p .. a | cr
( chk) or if pop pop 1000 !b ; ] then drop | cr
| cr
next ; = $35 $4 org ]
: p-r $0 p-r-p $200 p-r-p dup or !b ; | cr
= $9 2110 bin

{block 539}
( prp-call testing p to r to p using) ] call ( and) ; ( also test) ] jump ( from port to ram.) ; ( returns to port and to ram) | br

( uses the instructions in ram) | cr
( /) ] pop dup push ; ( /) ] call ( /) ; ( /) | br

( to insure failure on fail, fills ram with) | cr
( /) ] !b pop !b . ( /) | br

( relies on instructions in the port) | cr
( /) a! @p !+ . ( /) push !+ @p .. ( /) | cr
( /) !+ dup .. ( /) a! @p @p .. ( /) | cr
( /) !+ !+ push .. ( /) | cr
| br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: forcefail ( to force failure) | cr
( uncomment) [ @ ; ( in)
: calls ( and removing) [ for next ( structure) | cr
( might help debuging chip.)

{block 540}
# 2111 ( mark prp-ex test) | cr
( creeper) reclaim 0 node 1344 load $d org ]
: p-r-p dup $1 . + $7e for
: init # $2 # $3 dup ( 3) push over a | cr
# $3 ( .) # $2 ( a) pop ( 3) a push dup push $1 . + | cr
# $3 ( .) # $2 ( a) # $4 dup a! - $7f and | cr
# $3 ( .) # $2 ( a) # $3b pop # $3 ( .) # $2 ( a) # $3b # $3 | cr
a # $4 pop a! # $4 push | cr
( /) .. @p ! ! . ( //) @p @p @p @p ( /) ! ! ! | cr
| cr
10 for @p ! unext | cr
( /) # $2 a! @p !+ . ( /) !b pop !b . ( /) | cr
( a) push @p @p .. ( /) ; ( /) ] ex .. ( /) | cr
!+ !+ dup dup .. ( /) # $3b a! # $3b push @p @p ( /) | cr
( /) !b pop !b . ( /) pop dup ( . .) push ( .) ; ( /) | cr

: forcefail !+ !+ .. ( / . 2/ .) push drop .. ( /) | cr
| cr

: calls = $2b # $3 pop # $4 over # $3 $11000 or ! ( ? ; ?) | cr
( /) a .. @p ! @ .. ( //) !p .. | cr
( chk) or if pop pop 1000 !b ; ] then drop | cr
next ; = $36 $4 org ]
: p-r 0 p-r-p $200 p-r-p dup or !b ; | cr
= $9 2111 bin

{block 541}
( prp-ex testing p to r to p using) ] ex ( and) ; | cr
( also test) ] jump ( from port to ram.) ; ( returns to port and to ram) | br

( uses the instructions in ram) | cr
( /) ] pop dup push ; ( /) ] ex .. ( /) ; ( /) | cr
( to insure failure on fail, fills ram with) | cr
( /) ] !b pop !b . ( /) | cr
( relies on instructions in the port) | cr
( /) a! @p !+ . ( /) push @p @p .. ( /) | cr
( /) !+ !+ dup dup .. ( /) a! push @p @p ( /) | cr
( /) !+ !+ .. ( /) push drop .. ( /) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) [ 2/ ( in)
: forcefail ( to force failure) | cr
( uncomment) [ @ ; ( in)
: calls ( and removing) [ for next ( structure) | cr
( might help debuging chip.)

{block 542}
# 2112 ( serdes 001 slave test) | cr
( creeper) reclaim 1 node 1344 load ] ahead
: s-lis = $5 ( rip) -1 !b .. cold ;
: lis = $8 io a! $15555 ! data a! $3fffe dup ! ;
: m-lis ( arg) = $f then a push lis pop a! .. 0 !b ; = $14 | br


: ran ( n-n) = $14 -if 2* $2cd81 or ; ] then 2* ;
: rcv ( -n) = $18 $3fffe @ ( nip) over or or ;
: dly = $1b 50 for unext ;
: one = $1e up a! 0 rcv dup for | cr
ran dup push rcv or over - and or pop next | cr
drop dly | cr
data a! $31416 or dup ! io a! $20000 ! | cr
up a! ! dly lis warm ; | br

= $36 2112 bin

{block 543}
( basic serdes test. this package is loaded into node 001 and location) # 5 ( executed, returning negative status to rip the creeper out and placing the node in its cold configuration to execute anything node) # 701 ( sends it. the location) # 4 ( entry point is used in node) # 701 ( on the way to 001 to place) # 701 ( in listen mode first.) | br


: s-lis ( is used from node) # 101 ( to start 001 listening for instructions from node 701.)
: one ( is called by master thru serdes to run the test. receives count, nominally 250,000, and then receives one more than that words of data. compares each word with prn sequence generated off the initial count. ors all error bits together, then xors that result with) # 31416 ( and returns two copies after turning line around. finally goes back to receive and warm so it's rdy for the next test.)

{block 544}
# 2113 ( serdes) # 701 ( master test) | cr
( creeper) reclaim 1 node 1344 load ] ahead | br


: ran ( n-n) = $5 -if 2* $2cd81 or ; ] then 2* ;
: dly = $9 # 10 12 for unext ;
: lis = $c io a! $15555 ! data a! $3fffe dup ! ;
: go ( arg) = $13 then data a! io $1201e | cr
! a! up $20000 ( .) ! a! dup ! dup for | indent
     dly ran dup ! next drop | cr
( result) . .. . .. lis dly dly lis up a! @ @ | cr
$31416 or over $31416 or over - and or | cr
dup 2/ over - and or $1ffff and .. !b ; | br

= $31 2113 bin exit

{block 545}
( basic serdes test. single package used in two modes on path) # 1 ( for the two nodes.) | br


: s-lis ( is used from node) # 101 ( to start 001 listening for instructions from node 701.)

{block 546}
# 2114 ( basic analog checks) | cr
( creeper) reclaim 0 node 1344 load | br


: !dac = $4 ( n) io a! ! dup dup or !b ;
: ladc = $7 ( n) io a! ! ldata
: .adc = $a a! ! @ dup 1000 for unext .. | cr
( ----) = $e ! @ - 1 . + . + $1ffff and !b ;
: uadc = $13 ( n) io a! ! data .adc ; | br

= $17 2114 bin exit | br


: !dac = $19 ( n) dup @p ! dup ( /) @p a! @p . ( /) | cr
( ----) = $1b io ! ! @p ( /) ! . . . ( /) ! or !b ;

{block 547}
( basic analog control) | br

( this code is intended to run in the active) | cr
( node, not the target node.) | br


: !dac ( sets dac value into io and returns zero.)
: ladc ( sets up dac and io then reads back raw) | cr
( adc value when used in a left analog node.)
: uadc ( does the same for an up analog node.)

{block 548}
# 2115 ( mark 2* test) | cr
( creeper) reclaim 0 node 1344 load $13 org ]
: t! ( n) @p ! ! ; ( //) ] @p .. ( /)
: t2* @p ! ; ( //) ] 2* .. ( /)
: t@ ( -n) @p ! @ ; ( //) ] !p .. ( /)
: t2*3 @p ! .. ( //) 2* 2* 2* .. ( /) | cr
@p ! @ ; ( //) ] dup !p .. ( /)
: chk over or .. if pop pop pop 1000 !b ; ] then drop ;
: h2* dup t! 18 for | cr
dup . + t2* t@ dup t! chk | cr
next ;
: h2*3 dup t! 6 for | cr
dup . + dup . + dup . + t2*3 chk next ;
: forcefail = $36 [ $4 org ]
: tst-2* = $4 $15555 h2* $1 h2* - # $3ffff h2*3 # $0 h2*3 $15555 h2*3 $33333 h2*3 $71c7 h2*3 $1 h2*3 !b ; | cr
= $13 2115 bin

{block 549}
( tst-2* testing 2*) | cr
| br

( relies on instructions in the port) | cr
] @p . . . ( /) 2* . . . ( /) !p . . . ( /) 2* 2* 2* . ( /) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( first comment) dup ( in)
: h2*3 ( to force failure) | cr
( then comment) dup ( in)
: h2* ( to force failure)

{block 550}
# 2116 ( mark 2/ test) | cr
( creeper) reclaim 0 node 1344 load # $13 $19 org ]
: t2/ ( n-n) dup . + @p ( //) @p 2/ !p .. ( /) ! dup ! over @ ;
: t2/3 ( n-n) dup . + dup . + | cr
.. ( /) dup . + @p ( //) @p .. ( /) | cr
( /) ! dup ! @p ( //) 2/ 2/ 2/ !p ( /) | cr
( /) ! over @ ;
: chk or .. if pop pop pop 1000 !b ; ] then drop ;
: h2/ 12 for dup t2/ chk next ;
: h2/3 3 for dup t2/3 chk next ; = $36 $4 org ]
: tst-2/ = $4 $f h2/ $5 h2/ $3 h2/ $c h2/ $f h2/3 $5 h2/3 $3 h2/3 $c h2/3 $7 h2/3 $9 h2/3 dup or !b ; | cr
= $19 2116 bin

{block 551}
( tst-2/ testing 2/) | cr
| br

( relies on instructions in the port) | cr
] @p 2/ !p . ( /) @p . . . ( /) 2/ 2/ 2/ !p ( /) | cr
| br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( first comment) dup ( in)
: h2/ ( to force failure) | cr
( then comment) dup ( in)
: h2/3 ( to force failure)

{block 552}
# 2117 ( mark 2/ test) | cr
( creeper) reclaim 0 node 1344 load $22 org ]
: t2/ ( n-n) dup . + @p ( //) @p 2/ !p .. ( /) ! ! @ ;
: t2/3 ( n-n) dup . + dup . + | cr
.. ( /) dup . + @p ( //) @p .. ( /) | cr
( /) ! ! @p .. ( //) 2/ 2/ 2/ !p ( /) | cr
( /) ! @ ;
: chk or .. if pop pop pop 1000 !b ; ] then drop ;
: h2/ dup t2/ chk ;
: h2/3 dup t2/3 chk ; = $36 $4 org ]
: tst-2/b = $4 $30000 h2/ $3aaaa h2/ $35555 h2/ $3fffe h2/ $33333 h2/ $3cccc h2/ | cr
$3c000 h2/3 $3eaaa h2/3 $3d555 h2/3 $3fff8 h2/3 $3f333 h2/3 $3cccc h2/3 $3c0f0 h2/3 $3c1c3 h2/3 dup or !b ; | cr
= $21 2117 bin

{block 553}
( tst-2/b testing 2/) | cr
| br

( relies on instructions in the port) | cr
] @p 2/ !p . ( /) @p . . . ( /) 2/ 2/ 2/ !p ( /) | cr
| br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( first comment) dup ( in)
: h2/ ( to force failure) | cr
( then comment) dup ( in)
: h2/3 ( to force failure)

{block 554}
# 2200 ( tst+ mark testing +) | cr
( creeper) reclaim 0 node 1344 load $2a org | cr

: chk or if pop pop 1000 !b ; ] then drop ;
: t+ ( nnn-n) push .. | cr
( /) @p ! ! @p ( //) @p ( . - .) .. ( //) @p . + !p ( /) | cr
( /) ! ! @ pop chk ; | cr
= $35 $4 org | cr

: tst+ $15555 dup dup $2aaaa t+ | cr
dup dup - $3ffff t+ - dup - dup $2aaaa $3ffff t+ dup - $3ffff t+ | cr
dup or - dup dup $3fffe t+ $2aaaa $cccc $37776 t+ $19999 $15555 $2eeee t+ $33333 $8888 $3bbbb t+ | cr
dup or !b ; | cr
= $27 2200 bin

{block 555}
( tst+ mark testing +) | cr
| br

( relies on) ] s ( and) t ( of uut) | cr
( relies on instructions in the port) | cr
( /) @p .. ( /) @p . + !p ( /) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( fail mode;) | cr
( uncomment) - ( in)
: t+ ( to force failure) | cr
| cr


{block 556}
# 2201 ( mark r d stack test v2) | cr
( creeper) reclaim 0 node 1344 load $e org ]
: store dup ! dup ! dup ! ! ;
: fetch ( -n) @p ! @ ; ( /) ] !b .. ( /)
: /neighbor @p ! ! .. @p .. | cr
3 for @p ! unext ; ] ..
: /stack dup - over .. ( /) over over ( . - .) | cr
over .. ( /) over over over .. ( /) over .. ( /) ;
: t-stk = $1d | cr
dup /neighbor /stack = $1f | cr
# $fffe 8 for | cr
@p .. push push push .. store | cr
fetch drop @p .. pop pop pop .. store | cr
| cr
11 for fetch or .. if pop pop - 10 . + !b pop ; ] then drop | cr
next drop fetch drop next ; | cr
= $35 $4 org ]
: full = $4 $2aaaa t-stk dup or # $0 t-stk $33333 t-stk $19999 t-stk dup or !b ; | cr
= $d 2201 bin

{block 557}
( rdstk mark testing return and data stacks registers) | cr
( also mulitple overs pops and pushes in the port) | br

( fill neighbor return stack with alternating) | cr
( inverted patterns , then push to return stack then pop to data stack then read back and verify each pattern ; relies on) ] b s t r r-stack ( and) d-stack ( of uut) | cr
( and instructions) | cr
( /) !b .. ( /) @p .. dup - over .. ( /) | cr
( /) over over over .. ( /) over .. ( /) | cr
( /) push push push .. ( /) pop pop pop .. ( /) | cr
( /) @p .. ( /) !b .. ( /) over push pop .. ( /) | cr
( in the port) | br


: full ( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success , next count for failure) | br

( uncomment) - ( in)
: /stack ( after) over ( to force failure)

{block 558}
# 2202 ( mark d stack test v2) | cr
( creeper) reclaim 0 node 1344 load $18 org ]
: fetch ( -n) @p ! @ ; ( //) ] !b .. ( /)
: /neighbor @p ! ! .. @p .. | cr
3 for @p ! unext ; ] ..
: /stack = $1f dup - over .. ( /) over over | cr
over .. ( /) over over over .. ( /) over .. ( /) ;
: d-stack = $24 $8 for dup ( . - .) /neighbor /stack ( .) 11 for fetch or if pop pop - 10 . + !b pop ; ] then drop | cr
next next ; | cr
= $33 $4 org ]
: full = $4 $2aaaa d-stack dup or # $0 d-stack $15555 d-stack dup or - # $3ffff d-stack $33333 d-stack $19999 d-stack $cccc d-stack $26666 d-stack dup dup or | cr
!b ; = $16 2202 bin | cr


{block 559}
( stk mark testing data stack registers) | cr
( also overs in the port) | br

( fill neighbor return stack with alternating) | cr
( inverted patterns , then read back and verify each pattern ; relies on) ] b s t ( and) d-stack ( of uut) | cr
( and instructions) | cr
( /) dup - over .. ( /) over over over .. ( /) | cr
( /) over .. ( /) @p .. ( /) !b .. ( /) | cr
( in the port) | br


: full ( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success , next count for failure) | br

( uncomment) - ( in)
: d-stack ( after) dup ( to force failure)

{block 560}
# 2203 ( mark test + v2) | cr
( creeper) reclaim 0 node 1344 load $18 org | cr

: h+ over over ( . - .) . + push
: t+ ( nn-n) @p ! ! @p ( //) @p .. ( //) @p . + !p ( /) ! ! @ | cr
pop over ( chk) or if pop pop 1000 !b ; ] then drop ; | cr

: first ( x) leap $23225 . + dup
: xstr @p drop !p ; | -cr : x then $0 ; = $2a
: sec ( y) leap $1f9a9 . + dup
: ystr @p drop !p ; | -cr : y then $0 ;
: thr ( z) leap $1be29 . + dup
: zstr @p drop !p ; | -cr : z then $0 ; | cr
| cr
= $36 $4 org | cr

: tst+ dup or # $3ffff $3ff for first h+ sec over h+ thr h+ x - h+ over h+ z - h+ - y h+ dup h+ h+ next dup or !b ; | cr
= $18 2203 bin

{block 561}
( tst+b mark testing +) | cr
| br

( relies on) ] s t ( and) d-stack ( of uut) | cr
( relies on instructions in the port /) | cr
@p .. ( /) @p . + !p ( /) | br

[ address $4 ( tests the) tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success,) | cr
# 1000 ( for failure) | br

( uncomment) - ( in)
: h+ ( to force failure) | cr


{block 562}
# 2204 ( mark testing and) | cr
( creeper) reclaim 0 node 1344 load $1e org ]
: chk ( nn) or if pop pop pop $1000 !b ; ] then ( drop) ;
: tand ( nn-n) @p ! ! .. ( //) @p @p and !p ( /) ! @ ;
: ttand over over ( . - .) and push tand pop chk ;
: first ( x) leap $23225 . + dup
: xstr @p drop !p ; | -cr : x then $0 ;
: sec ( y) leap $1f9a9 . + dup
: ystr @p drop !p ; | -cr : y then $0 ; | cr
= $35 $4 org ]
: tstand # $3ffff $100 for first sec ttand x - y ttand x y - ttand x - y - ttand y - x ttand y x - ttand y - x - ttand next dup or !b ; | cr
= $1d 2204 bin | cr
| cr


{block 563}
( tst-and mark testing and) | br

( relies on) ] s t ( and) d-stack ( of uut) | cr
( relies on instructions) | cr
( /) @p @p and !p ( /) | cr
( in the port) | br


: full ( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) [ 1000 ( for failure) | br

( uncomment) ] - ( in)
: ttand ( after) over ( to force failure)

{block 564}
# 2205 ( mark test and) | cr
( creeper) reclaim 0 node 1344 load $25 org ]
: chk ( nn) or if pop pop $1000 !b ; ] then ;
: tand ( nn-n) @p ! ! .. ( //) @p @p and !p .. ( /) ! @ ; | cr

: tand3 ( nnnn-n) @p ! ! .. ( //) @p @p @p @p ( /) | cr
( /) ! ! ! @p ( //) and and and !p .. ( /) ! @ ;
: tsa tand chk ;
: tsa3 tand3 chk ; | cr
= $36 $4 org ]
: tstand # 0 $2222 $17777 $2aaaa $3faff $33333 tsa3 $30a5c $3ffff over tsa $30a5c - $3ffff over tsa $a00 $3ff00 $fff $3ffff $3fa55 tsa3 - tsa $15555 tsa dup $2aaaa tsa $15555 $2aaaa tsa !b ; | cr
= $25 2205 bin | cr
| cr


{block 565}
( tst-andb mark testing and) | cr
| br

( relies on) ] s t ( and) d-stack ( of uut) | cr
( relies on instructions) | cr
( /) @p @p and !p .. ( /) @p @p @p @p ( /) | cr
( /) and and and !p ( /) | cr
( /) | cr
( in the port) | br


: full ( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) [ 1000 ( for failure) | br

( first fail mode;) | cr
( uncomment) ] and ( in)
: tand ( to force failure) | cr
| cr
( second fail mode;) | cr
( uncomment) and ( in)
: tand3 ( to force failure) | cr


{block 566}
# 2206 ( mark testing or) | cr
( creeper) reclaim 0 node 1344 load $1e org ]
: chk ( nn) or if pop pop pop $1000 !b ; ] then ;
: tor ( nn-n) @p ! ! .. ( //) @p @p or !p ( /) ! @ ;
: ttor over over ( . - .) or push tor pop chk ;
: first ( x) leap $23225 . + dup
: xstr @p drop !p ; | -cr : x then $0 ;
: sec ( y) leap $1f9a9 . + dup
: ystr @p drop !p ; | -cr : y then $0 ; | cr
= $35 $4 org ]
: tst-or # $3ffff $100 for first sec ttor x - y ttor x y - ttor x - y - ttor y - x ttor y x - ttor y - x - ttor next dup or !b ; | cr
= $1d 2206 bin | cr
| cr


{block 567}
( tst-or mark testing and) | br

( relies on) ] s t ( and) d-stack ( of uut) | cr
( relies on instructions) | cr
( /) @p @p and !p ( /) | cr
( in the port) | br


: full ( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) [ 1000 ( for failure) | br

( uncomment) ] - ( in)
: ttand ( after) over ( to force failure)

{block 568}
# 2207 ( mark test or v2) | cr
( creeper) reclaim 0 node 1344 load $25 org ]
: chk ( nn) or if pop pop pop $1000 !b ; ] then ;
: tor ( nn-n) @p ! ! .. ( //) @p @p or ( . - .) !p .. ( /) ! @ ; | cr

: tor3 ( nnnn-n) @p ! ! .. ( //) @p @p @p @p ( /) | cr
( /) ! ! ! @p ( //) or or or ( . - .) !p .. ( /) ! @ ;
: tso tor chk ;
: tso3 tor3 chk ; | cr
= $36 $4 org ]
: tstor $3e372 $35fa9 $3f57f $25733 $11e97 tso3 $3f555 $3ff00 $fff $3ffff $3fa55 tso3 $15555 $3ffff over - tso $2aaaa $3ffff over - tso dup or dup - dup tso dup or - dup dup - tso $15555 over - over - tso !b ; | cr
= $25 2207 bin | cr
| cr


{block 569}
( tst-orb mark testing and) | cr
| br

( relies on) ] s t ( and) d-stack ( of uut) | cr
( relies on instructions) | cr
( /) @p @p and !p .. ( /) @p @p @p @p ( /) | cr
( /) and and and !p ( /) | cr
( /) | cr
( in the port) | br


: full ( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) # 0 ( for success ,) [ 1000 ( for failure) | br

( first fail mode;) | cr
( uncomment) ] and ( in)
: tand ( to force failure) | cr
| cr
( second fail mode;) | cr
( uncomment) and ( in)
: tand3 ( to force failure) | cr


{block 570}
# 2208 ( mark test -) | cr
( creeper) reclaim 0 node 1344 load $26 org ]
: chk ( nn) ! @ or if pop pop $1000 !b ; ] then ;
: t- ( n-n) @p ! .. ( //) @p - !p .. ( /) chk ;
: t-2 ( n-n) dup @p ! .. ( //) @p - - !p .. ( /) chk ; | cr

: t-3 ( n-n) @p ! ! @p ( //) @p .. ( /) | cr
( //) - - - !p .. ( /) chk ; | cr
= $36 $4 org ]
: tstor $1c8d $3e372 t- $2aaaa $15555 t- $15555 $2aaaa t- $3ffff dup dup or t- dup dup or $3ffff t- | cr
dup dup or t-2 $3ffff t-2 $2aaaa t-2 $15555 t-2 $3ffff dup dup or t-3 $2aaaa $15555 t-3 !b ; | cr
= $26 2208 bin | cr
| cr


{block 571}
( tst- mark testing) ] - | cr
| br

( relies on) s t ( and) d-stack ( of uut) | cr
( relies on instructions) | cr
( /) @p - !p .. ( /) @p - - !p .. ( /) | cr
( /) @p .. ( /) - - - !p .. ( /) | br

( in the port) | br

( tests the) [ tfocused ( neighbor) | cr
] parameter ( is ignored) | cr
( error code) [ 0 ( for success ,) 1000 ( for failure) | br

( first fail mode;) | cr
( uncomment) ] - ( in)
: t- ( to force failure) | br

( second fail mode;) | cr
( uncomment) - ( in)
: t-2 ( to force failure) | br

( second fail mode;) | cr
( uncomment) - ( in)
: t-3 ( to force failure)

{block 572}


{block 573}


{block 574}


{block 575}


{block 576}


{block 577}


{block 578}


{block 579}


{block 580}


{block 581}


{block 582}


{block 583}


{block 584}


{block 585}


{block 586}


{block 587}


{block 588}


{block 589}


{block 590}


{block 591}


{block 592}


{block 593}


{block 594}


{block 595}


{block 596}


{block 597}


{block 598}


{block 599}


{block 600}
( res for more ats test pkgs ---)

{block 601}


{block 602}


{block 603}


{block 604}


{block 605}


{block 606}


{block 607}


{block 608}


{block 609}


{block 610}


{block 611}


{block 612}


{block 613}


{block 614}


{block 615}


{block 616}


{block 617}


{block 618}


{block 619}


{block 620}


{block 621}


{block 622}


{block 623}


{block 624}


{block 625}


{block 626}


{block 627}


{block 628}


{block 629}


{block 630}
# 1900 ( ats analog) | cr
reclaim 717 node 0 org ]
: sam ( n-k) = $0 io b! data a! @b - $1ff and or | cr
!b dup ! @ 1000 for unext dup ! @ - . + ;
: vdd = $c $2000 sam ; | -cr : vss = $e $6000 sam ;
: vpin = $10 $0 sam ;
: u* ( nn-hl) = $12 dup a! dup or 17 for +* unext | cr
push drop pop a ;
: m/ ( dn-q) --u/mod push drop pop ;
: mv ( -n) = $19 vss vdd over - . + push | cr
vpin - . + -if dup or then 1800 u* pop m/ ;
: !mv ( n) = $23 io b! 511 u* -1800 m/ $155 or !b ; | cr
= $2b 1900 bin

{block 631}
( ide mode code.)
: mv ( returns approx pad voltage in mv using contemporaneous cal values from our own rails assuming said rails at) # 0 ( and 1800. no linearization. dac output remains unchanged.)
: !mv ( sets dac output to a voltage in mv. this is most bogus since no linearization is done; the actual voltage will be much higher than what we are setting.)

{block 632}
# 1901 ( ats sync boot master) | cr
reclaim 300 node 0 org ]
: dly = $0 ( b) !b 40 # 31 for unext ;
: 1bt = $3 ( wb-w') dup dly $10000 or dly ;
: 18o = $6 ( w) $30000 dly 8 for begin | cr
= $a -if ( 1-) $30003 1bt [ swap | -cr : rise | cr
= $d 2* -if ( 1+) $20003 1bt 2* *next drop ; | cr
= $12 ( .) ] then ( 0+) $20002 1bt 2* *next drop ; | cr
= $16 ( .) ] then ( 0-) $30002 1bt rise ; | cr

: off = $19 io b! $20002 dly $10001 !b ; | cr
= $1f 1901 bin

{block 633}
( this code is loaded into tb001 test chip node) # 300 ( to boot node) # 300 ( of the uut. the ide uses) ] 18o ( to form a boot stream to load the link) | cr
( routine into the remote node. once remote) | cr
( is started ide sets the local pins to low) | cr
( tri-state and weak-low before loading the) | cr
( link code into the local node and starting it. at this time both of these nodes remain off of the grid until both the test and uut chip have been reset.)

{block 634}
# 1902 ( boot frame for master testing) | cr
reclaim 300 node 0 org | cr
host | -cr : 3- $fffffffd + ; target | br


: frame ser-exec -d-- [ 0 , ]
: portex @p !b . . ( /) [ $30000 , ( /) | cr
= $5 here here 3- 2 org , | cr
org = $5 1902 bin

{block 635}
( boot frame which commands uut node) # $200 ( to set its pin 200.17 high.)

{block 636}
# 1903 ( boot frame for master testing) | cr
reclaim 300 node 0 org | cr
host | -cr : 3- $fffffffd + ; target | br


: frame ser-exec -d-- [ 0 , ]
: portex @p !b . . ( /) [ $20000 , ( /) | cr
= $5 here here 3- 2 org , | cr
org = $5 | cr
$20 org ]
: misc ---u @p - !p ; 1903 bin

{block 637}
( boot frame which commands uut node) # $200 ( to set its pin 200.17 low.)

{block 638}
# 1904 ( ats sync bridge) | cr
reclaim 300 node # 3 8 org | cr
host | -cr : hd- # -3 -8 + ; target | br


: dly = $8 ( b) !b 40 for unext ; ( 88ns)
: 1bt = $b ( wb-w') dup dly $10000 or dly ;
: zro = $e $10001 dly ; | -cr : wpd = $10 $10001 !b ;
: 18o = $12 ( w) zro 17 for begin | cr
= $15 -if $30003 1bt 2* *next drop wpd ; | cr
= $1a ] then $30002 1bt 2* next drop wpd ; | br


: 18i = $1e ( x) drop dup or !b 17 for | cr
= $21 ( ..) begin @b -until | cr
= $22 ( ..) begin @b - -until | cr
= $23 ( ..) - 2 and 2/ a 2* or a! next | cr
= $27 a up a! ! | br


: idl = $2a $165 ( --lu) a! . @ @b -if drop 18i ; | cr
= $2e ] then zro drop 18o idl ; | cr

: ent = $31 io b! wpd begin @b - -until idl ; | cr
= $36 here here hd- # 0 5 org ]
: frame ent dly [ , | cr
org = $36 1904 bin

{block 639}
] shadow out of date. | cr
( this code is loaded into nodes) # 300 ( of both) | cr
( the test and uut chips of the tb001 board.) | cr
( the transmitter controls the clock and data is sampled on the falling edge. the clock is set to low tri-state and data to weak-low one half bit time from the end of word. the code idles reading from a neighbor and the clock pin.) | cr
( data from the neighbor are transmitted and) | cr
( receive data are writen to the neighbor. no) | cr
( attempt is made to be able to terminate either of these serial linked nodes except reset.) | cr
( terminating the remote node would require) | cr
( an enhanced protocol. also we see no need) | cr
( to impliment flow control at this time. on) | cr
( entry the code waits for the clock to drop) | cr
( to facilitate transition from the old boot) | cr
( protocol.) | cr
[ origin moved to 5 so boot frame header can be laid down without affecting slot 2 jumps.

{block 640}
# 1905 ( uut bridge debug) | cr
reclaim 300 node # 3 8 org | cr
host | -cr : hd- # -3 -8 + ; target | br


: dly = $8 ( b) !b # 40 400 for unext ; ( 88ns)
: 1bt = $b ( wb-w') dup dly $10000 or dly ;
: zro = $e $10001 dly ;
: wpd = $10 $10001 !b ;
: 18o = $12 ( w) zro 17 for begin | cr
= $15 -if $30003 1bt 2* *next drop wpd ; | cr
= $1a ] then $30002 1bt 2* next drop wpd ;
: 18i = $1e ( x) drop dup or !b 17 for | cr
= $21 ( ..) begin @b -until | cr
= $22 ( ..) begin @b - -until | cr
= $23 ( ..) - 2 and 2/ a 2* or a! next | cr
= $27 a ( up a! !) # 1 ( and) # 2 ( or !b) zro 12345 . + 18o | br


: idl = $2b $165 ( --lu) a! .. | cr
= $2d @ @b -if drop 18i ; ] then | cr
= $2f zro drop 18o ( idl ;) | cr

: ent = $31 io b! wpd | cr
begin @b - -until idl ; | cr
= $36 here here hd- # 0 5 org ]
: frame ent dly [ , | cr
org = $36 1905 bin

{block 641}
] shadow out of date. | cr
( this code is loaded into nodes) # 300 ( of both) | cr
( the test and uut chips of the tb001 board.) | cr
( the transmitter controls the clock and data is sampled on the falling edge. the clock is set to low tri-state and data to weak-low one half bit time from the end of word. the code idles reading from a neighbor and the clock pin.) | cr
( data from the neighbor are transmitted and) | cr
( receive data are writen to the neighbor. no) | cr
( attempt is made to be able to terminate either of these serial linked nodes except reset.) | cr
( terminating the remote node would require) | cr
( an enhanced protocol. also we see no need) | cr
( to impliment flow control at this time. on) | cr
( entry the code waits for the clock to drop) | cr
( to facilitate transition from the old boot) | cr
( protocol.) | cr
[ origin moved to 5 so boot frame header can be laid down without affecting slot 2 jumps.

{block 642}
# 1906 ( tester bridge debug) | cr
reclaim 300 node # 3 8 org | cr
host | -cr : hd- # -3 -8 + ; target ]
: dly = $8 ( b) !b # 40 400 for unext ; ( 88ns)
: 1bt = $b ( wb-w') dup dly $10000 or dly ;
: zro = $e $10001 dly ;
: wpd = $10 $10001 !b ;
: 18o = $12 ( w) io b! zro 17 for begin | cr
= $17 -if $30003 1bt 2* *next drop wpd ; | cr
= $1c ] then $30002 1bt 2* next drop wpd ;
: 18i = $20 ( x) drop dup or !b 17 for | cr
= $23 ( ..) begin @b -until | cr
= $24 ( ..) begin @b - -until | cr
= $25 ( ..) - 2 and 2/ a 2* or a! next | cr
= $2a a ( up a! !) ;
: joe = $2b ( w) 18o 18i ;
: idl = $2d $165 ( --lu) a! .. | cr
= $2f @ @b -if drop 18i ; ] then | cr
= $31 zro drop 18o ( idl ;) | cr

: ent = $33 io b! $10001 !b | cr
begin @b - -until ( idl) ; | cr
= $3a here here hd- # 0 5 org ]
: frame ent dly [ , | cr
org = $3a 1906 bin

{block 643}
] shadow out of date. | cr
( this code is loaded into nodes) # 300 ( of both) | cr
( the test and uut chips of the tb001 board.) | cr
( the transmitter controls the clock and data is sampled on the falling edge. the clock is set to low tri-state and data to weak-low one half bit time from the end of word. the code idles reading from a neighbor and the clock pin.) | cr
( data from the neighbor are transmitted and) | cr
( receive data are writen to the neighbor. no) | cr
( attempt is made to be able to terminate either of these serial linked nodes except reset.) | cr
( terminating the remote node would require) | cr
( an enhanced protocol. also we see no need) | cr
( to impliment flow control at this time. on) | cr
( entry the code waits for the clock to drop) | cr
( to facilitate transition from the old boot) | cr
( protocol.) | cr
[ origin moved to 5 so boot frame header can be laid down without affecting slot 2 jumps.

{block 644}


{block 645}


{block 646}


{block 647}


{block 648}
# 1400 ( ats cs master0 n108) | cr
reclaim 108 node # 742 ( load) = $aa 0 org ]
: sam ( n-k) = $0 | cr
= $1 [ 1400 bin

{block 649}
( code for node) # 108 ( in ats.) | cr


{block 650}
# 1401 ( ats cs wire) | cr
reclaim 109 node 0 org ]
: sam ( n-k) = $0 | cr
= $2b [ 1401 bin

{block 651}


{block 652}
# 1402 ( ats cs digital) | cr
reclaim 717 node 0 org ]
: sam ( n-k) = $0 | cr
= $2b [ 1402 bin

{block 653}
( pf mode code for digital nodes.)

{block 654}
# 1403 ( ats cs analog) | cr
reclaim 717 node 0 org ]
: sam ( n-k) = $0 io b! data a! @b - $1ff and or | cr
!b dup ! @ 1000 for unext dup ! @ - . + ;
: vdd = $c $2000 sam ; | -cr : vss = $e $6000 sam ;
: vpin = $10 $0 sam ;
: u* ( nn-hl) = $12 dup a! dup or 17 for +* unext | cr
push drop pop a ;
: m/ ( dn-q) --u/mod push drop pop ;
: mv ( -n) = $19 vss vdd over - . + push | cr
vpin - . + -if dup or then 1800 u* pop m/ ;
: !mv ( n) = $23 io b! 511 u* -1800 m/ $155 or !b ; | cr
= $2b 1403 bin

{block 655}
( pf mode code.)
: mv ( returns approx pad voltage in mv using contemporaneous cal values from our own rails assuming said rails at) # 0 ( and 1800. no linearization. dac output remains unchanged.)
: !mv ( sets dac output to a voltage in mv. this is most bogus since no linearization is done; the actual voltage will be much higher than what we are setting.)

{block 656}


{block 657}


{block 658}
( xxxx smtm mem-random converted) | cr
reclaim 0 node 0 ] 3 [ org
: rnd ( n-n') = $0 -if 2* $2cd81 or ; ] then 2* ;
: run = $4 @p @p a! dup ( /) [ $12155 , $a9 , ( /) | cr
] @ $b a! .. or $3 $3fff8 .. rnd dup ! and .. | cr
push $8 begin 2* . . unext and if or ahead | cr
[ swap ] then run ; = $14 ] . .. . ..
: go = $16 then @ over a! @p ( /) @p dup push dup | cr
a ! ! $e push dup ! begin @p ! . unext ( /-) | cr
= $1c push dup push dup push dup push dup | cr
= $1e push dup push dup push push pop dup | cr
= $20 pop pop pop pop pop pop pop pop $3f dup | cr
= $24 push push or dup a! or or or or or or or . = $28 begin dup !+ . unext begin @+ or . unext | cr
= $2a @p a! ! . ( -/) a ! @ or if warm ; ] then
: migrate $1557f !b $1556a . $1f for . . . unext | cr
= $34 !b $4 @p . ( /) @p dup 2/ . ( /) | cr
= $37 a ! ! $43 push begin @p !+ . unext ( /-) | cr
= $3b [ $3f , ] 2* a! push begin @p !+ . unext | cr
= $3e @p push ; ( -/) ] ! warm ; | cr
= $40 ( xxxx bin)

{block 659}
( this is steven's) | cr
( g144-smtm-self-tet-mem-random)

{block 660}
( tb001 ide pretest) empty compile serial load | br

( customize) -canon 660 orgn ! | cr
a-com sport ! a-bps bps ! !nam | br


: mv ( -n) [ $19 ] call $3f lit' ra! !a $3f r@ ;
: !mv ( n) lit' [ $23 ] call ;
: +a ( nn) 2 swap hook 0 64 1900 boot ; | br


: !vdc ( mv) [ 709 ] +a !mv ; | -cr : vdc ( -mv) [ 709 ] +a mv ;
: !vdi ( mv) [ 713 ] +a !mv ; | -cr : vdi ( -mv) [ 713 ] +a mv ;
: !vda ( mv) [ 717 ] +a !mv ; | -cr : vda ( -mv) [ 717 ] +a mv ;
: !bus ( mv) [ 117 ] +a !mv ; | -cr : bus ( -mv) [ 117 ] +a mv ;
: drain 2 [ 617 ] hook $aa io r! $155 io r! ;
: set ( n nn) 2 swap hook [ 2 ] + [ $10000 ] * io r! ;
: rst ( n) [ 417 ] set ;
: 1.8 ( n) [ 715 ] set ; | -cr : 1.475 ( n) [ 517 ] set ;
: hivd [ 1 ] 1.8 [ 0 ] 1.475 ; | -cr : lovd [ 1 ] 1.475 [ 0 ] 1.8 ;
: novd [ 0 ] 1.8 [ 0 ] 1.475 drain ; | br

( functions) 662 4 loads | cr
( automate) talk pre

{block 661}
( these defns are used in ide on ats master to simulate actions later run by polyforth.) | br


: !vdx ( and) vdx ( drive and read uut power bus) [ x ( in nonlinear millivolts.)
: !bus ( and) bus ( do the same with analog bus.)
: rst ( sets uut reset line low if) [ n 0 ( or high) 1 ]
: drain ( used only when no power enabled to short out the supply rails briefly.)
: rst ( controls uut reset line) [ 0 ( is low.)
: 1.8 ( and) 1.475 ( control power supplies) [ 1 ( enables) 0 ( disables.)
: hivd lovd ( and) novd ( select high, low, and zero voltage power supply to uut.)

{block 662}
( - pre powerup tests) 662 list | br

( preliminary tests) | .pok :var vval [0x1] | cr
:var vcop [0x1] :var vcsh [0x1] :var viop [0x1] :var vish [0x1] :var vaop [0x1] :var vash [0x1] | br


: init 0 [ vcop ] ! 0 [ vcsh ] ! 0 [ viop ] ! 0 [ vish ] ! | cr
0 [ vaop ] ! 0 [ vash ] ! 0 [ vval ] ! pause
: -pwr 0 rst 0 !vdc 0 !vdi 0 !vda novd ; | br

exit ( test procedure...)
: - no chip in socket
: - 'compile'
: - '280 load talk'
: - insert chip
: - 'pre'
: - will stop here if pretests fail
: - else runs creeper tests in 250
: - [ always say ] -pwr [ before removing chip!!!

{block 663}

: -pwr ( removes all power from uut socket and leaves it) safe ( for inserting or removing chip. puts chip in reset, disables both power supplies, removes drive from power rail test dacs, and drains the rails.)
: ?open ( checks each supply rail for enough loading to believe there's a chip in the socket.)

{block 664}
( - power opens and shorts)
: sam ( -n) mv mv + mv + mv + 2/ 2/ ;
: -sam ( x-mv) drop sam ;
: lt ( nn-t) less if drop drop 1 ; | cr
] then drop drop 0 ;
: -sht ( n.mv.mv-t) max 2* swap lt ; | br


: ?cop [ 75 ] !vdc sam ( dup) [ 500 ] lt [ vcop ] ! 0 !mv ;
: ?iop [ 75 ] !vdi sam ( dup) [ 500 ] lt [ viop ] ! 0 !mv ;
: ?aop [ 75 ] !vda sam ( dup) [ 850 ] lt [ vaop ] ! 0 !mv ;
: ?open ?cop pause ?iop pause ?aop pause ; | br


: ?csht [ 75 ] !vdc sam vdi -sam vda -sam | cr
-sht [ vcsh ] ! 0 !vdc ;
: ?isht [ 75 ] !vdi sam vdc -sam vda -sam | cr
-sht [ vish ] ! 0 !vdi ;
: ?asht [ 75 ] !vda sam vdi -sam vdc -sam | cr
-sht [ vash ] ! 0 !vda ;
: ?short ?csht pause ?isht pause ?asht pause ;

{block 665}


{block 666}
( - results)
: chs ( ...n) for emit next ;
: ?good ( -t) [ vcop ] @ [ vcsh ] @ and [ viop ] @ and [ vish ] @ and [ vaop ] @ and [ vash ] @ and ;
: .pf ?good drop if | cr
green 42 36 3 3 chs space ; | cr
] then red 42 12 7 5 14 5 chs space ;
: .pok blu [ vval ] @ 0 + drop if .pf ; | cr
] then silver 11 8 22 19 4 chs space ;

{block 667}

: .pok ( shows how to make a blue word display variable text strings.)

{block 668}
( - port bridge) | br


: !sync 0 [ 300 ] hook 0 64 [ 1901 ] boot [ $19 ] call ; | br


: pt@ ( a-n) @ $15555 or ;
: frame ( a nd) nn-n 2* 32768 + block + dup 2 + pt@ 3 + for dup pt@ lit' 6 call [ 1 ] + next drop ;
: !hitst 0 [ 1902 ] frame ;
: !lotst 0 [ 1903 ] frame ;
: !his 5 [ 1904 # 1905 ] frame ; | br


: !ours ( off) [ $19 ] call 0 64 [ 1904 ] boot | cr
( ent) [ $30 ] call ( testing) $0 [ 400 ] hook focus ; | br


: setup ?good drop if -pwr !sync hivd 1 rst | cr
[ 300 ] node ( !hitst) !his !ours then ; | br


: pre [ 662 ] list pause init | cr
?open ?short 1 [ vval ] ! 123 pause | cr
?good drop if setup | cr
2 -hook 1 -hook 0 -hook drop pause | cr
[ 670 ] load ; ] then ;

{block 669}
( set up port bridge.) | br


: first ( we load sync boot master in our) # 300 ( done by) !sync
: second ( we load bridge in uut node) # 300 ( using) frame ( which sends a boot frame starting at location) [ a ( compiled for bin) nd's ( ram)
: third ( we load bridge into our node) # 300 | br


: setup ( does all this and loads new ide for the bridged 2-chip system.)
: pre ( runs full set of pre-tests)

{block 670}
( tb001 ide creepers) empty serial load | , ( customize) -canon 670 orgn ! | , a-com sport ! a-bps bps ! !nam | , ( functions) 674 5 loads | , | , ( test status is) | .pok | , | , ( details) :var ph [0x3] :var id [0x7d2] :var tgt [0x3e8] :var pos [0x9a] | , ( -------) :var ans :var rval [0x8c8a] | , ( -------) :var nrun [0x3345] :var vval [0x1] | , | ,
: init 0 [ tgt ] ! 0 [ pos ] ! 0 [ nrun ] ! 0 [ id ] ! 0 [ rval ] ! | , | .. 0 [ ans ] ! 0 [ vval ] ! -1 [ ph ] ! ; | , ( runner) 684 9 loads 672 load | ,
: run 670 list !p0 !p1 init pause | , | .. -buses 0 1000 hook 0 -hook ana0 ( ;) | , 0 [ ph ] ! 0 path z t911 t917 ta00 t913 | , 1 [ ph ] ! 1 path z !p1a | , 2 [ ph ] ! 1 path z !p1 ser70 !p1b ser07 !p1 | , 3 [ ph ] ! lovd 500 ms ( actually) # 50 ( on moo) | , | .. 0 path 2007 runall 2002 runall | , 1 [ vval ] ! -pwr ; run

{block 671}
( ide environment to run ide and creepers in the uut. path) # 2 ( reaches right side controls. paths) # 0 ( and) # 1 ( are mutually exclusive reaching into the uut.) | br


: !vdx ( and) vdx ( drive and read uut power bus) [ x ( in nonlinear millivolts.)
: !bus ( and) bus ( do the same with analog bus.)
: rst ( sets uut reset line low if) [ n 0 ( or high) 1 ]
: drain ( used only when no power enabled to short out the supply rails briefly.)
: rst ( controls uut reset line) [ 0 ( is low.)
: 1.8 ( and) 1.475 ( control power supplies) [ 1 ( enables) 0 ( disables.)
: hivd lovd ( and) novd ( select high, low, and zero voltage power supply to uut.) | br

[ needing special runners - 913 911

{block 672}
( - all tests) | br


: z ( lov-ram) [ 2007 ] runall | cr
( port) [ 2000 ] runall ( port2*) [ 2001 ] runall | cr
( ram) [ 2002 ] runall ( t,s) [ 2003 ] runall | cr
( t,r) [ 2004 ] runall ( stack) [ 2005 ] runall | cr
( return) [ 2006 ] runall ( ms-rdst) [ 2008 ] runall | cr
( shifta) [ 2009 ] runall ( tsar-data) [ 2010 ] runall | cr
( ms-stk) [ 2012 ] runall ( carry) [ 2014 ] runall | cr
( ms-@p) [ 2015 ] runall ( i,r-ad) [ 2016 ] runall | cr
( @b!b) [ 2101 ] runall ( b-reg) [ 2102 ] runall | cr
( i-reg) [ 2103 ] runall ( i-reg) [ 2104 ] runall | cr
( i-reg) [ 2105 ] runall ( i-reg) [ 2106 ] runall | cr
( i-reg) [ 2107 ] runall ( i-reg) [ 2108 ] runall | cr
( i-reg) [ 2109 ] runall ( prp-call) [ 2110 ] runall | cr
( prp-ex) [ 2111 ] runall ( tst-2*) [ 2115 ] runall | cr
( tst-2/) [ 2116 ] runall ( tst-2/b) [ 2117 ] runall | cr
( tst+) [ 2200 ] runall ( rdstkv2) [ 2201 ] runall | cr
( dstkv2) [ 2202 ] runall ( +v2) [ 2203 ] runall | cr
( and) [ 2204 ] runall ( andv2) [ 2205 ] runall | cr
( or) [ 2206 ] runall ( orv2) [ 2207 ] runall | cr
( -) [ 2208 ] runall | cr
;

{block 673}


{block 674}
( - multichip ide)
: mwall ( nn-i) [ 1000 ] mod swap [ 1000 ] mod | cr
over over or drop if swall ; | cr
] then drop drop ( up) 3 ; ' mwall 'wall ! | br


: uup0 align create [ 708 , 707 , 706 , 705 , 704 , 703 , 702 , 701 , 700 , 600 , 500 , 400 , | cr
1400 , 1500 , 1600 , | cr
1700 , 1701 , 1702 , 1703 , 1704 , 1705 , | cr
1706 , 1707 , 1708 , 1709 , 1710 , 1711 , | cr
1712 , 1713 , 1714 , 1715 , 1716 , 1717 , | cr
1617 , 1616 , 1615 , 1614 , 1613 , 1612 , | cr
1611 , 1610 , 1609 , 1608 , 1607 , 1606 , | cr
1605 , 1604 , 1603 , 1602 , 1601 , | cr
1501 , 1502 , 1503 , 1504 , 1505 , 1506 , | cr
1507 , 1508 , 1509 , 1510 , 1511 , 1512 , | cr
1513 , 1514 , 1515 , 1516 , 1517 , | cr
1417 , 1416 , 1415 , 1414 , 1413 , 1412 , | cr
1411 , 1410 , 1409 , 1408 , 1407 , 1406 , | cr
1405 , 1404 , 1403 , 1402 , 1401 , | cr
1301 , 1302 , 1303 , 1304 , 1305 , 1306 , | cr
1307 , 1308 , 1309 , 1310 , 1311 , 1312 , | cr
1313 , 1314 , 1315 , 1316 , 1317 , | cr


{block 675}

: mwall ( discards chip id portion of node number and in the special case of two consecutive nodes of same number forces up port to be the wall between them. thus a path going from) # 400 ( to) # 1400 ( uses up to make the connection via the) # 300 ( to) # 300 ( sync bridge.) | br


: uup0 ( is the primary path for pass/fail testing in the uut. it reaches all nodes but the bridge in) # 300
: uup1 ( is secondary path which passes thru most of the ports skipped by uup1. it does not include nodes 000) # 100 # 200 ( and leaves) # 4 ( ports that have not been exercised.)
: up1a ( is a quick path that is substituted for path) # 1 ( to catch the four remaining ports.) | br

when all three have been done, only node 300 and its right and down ports have not been exercised.

{block 676}
( -- paths 0,1) | cr
1217 , 1216 , 1215 , 1214 , 1213 , 1212 , | cr
1211 , 1210 , 1209 , 1208 , 1207 , 1206 , | cr
1205 , 1204 , 1203 , 1202 , 1201 , 1200 , | cr
1100 , 1101 , 1102 , 1103 , 1104 , 1105 , | cr
1106 , 1107 , 1108 , 1109 , 1110 , 1111 , | cr
1112 , 1113 , 1114 , 1115 , 1116 , 1117 , | cr
1017 , 1016 , 1015 , 1014 , 1013 , 1012 , | cr
1011 , 1010 , 1009 , 1008 , 1007 , 1006 , | cr
1005 , 1004 , 1003 , 1002 , 1001 , 1000 , -1 , | br


: uup1 align create [ 708 , 707 , 706 , 705 , 704 , 703 , 702 , 701 , 700 , 600 , 500 , 400 , | cr
1400 , 1500 , 1600 , 1700 , | cr
1701 , 1601 , 1501 , 1401 , 1301 , 1201 , | cr
1101 , 1001 , 1002 , 1102 , 1202 , 1302 , | cr
1402 , 1502 , 1602 , 1702 , | cr
1703 , 1603 , 1503 , 1403 , 1303 , 1203 , | cr
1103 , 1003 , 1004 , 1104 , 1204 , 1304 , | cr
1404 , 1504 , 1604 , 1704 , | cr


{block 677}


{block 678}
( -- paths 1) | cr
1705 , 1605 , 1505 , 1405 , 1305 , 1205 , | cr
1105 , 1005 , 1006 , 1106 , 1206 , 1306 , | cr
1406 , 1506 , 1606 , 1706 , | cr
1707 , 1607 , 1507 , 1407 , 1307 , 1207 , | cr
1107 , 1007 , 1008 , 1108 , 1208 , 1308 , | cr
1408 , 1508 , 1608 , 1708 , | cr
1709 , 1609 , 1509 , 1409 , 1309 , 1209 , | cr
1109 , 1009 , 1010 , 1110 , 1210 , 1310 , | cr
1410 , 1510 , 1610 , 1710 , | cr
1711 , 1611 , 1511 , 1411 , 1311 , 1211 , | cr
1111 , 1011 , 1012 , 1112 , 1212 , 1312 , | cr
1412 , 1512 , 1612 , 1712 , | cr
1713 , 1613 , 1513 , 1413 , 1313 , 1213 , | cr
1113 , 1013 , 1014 , 1114 , 1214 , 1314 , | cr
1414 , 1514 , 1614 , 1714 , | cr
1715 , 1615 , 1515 , 1415 , 1315 , 1215 , | cr
1115 , 1015 , 1016 , 1116 , 1216 , 1316 , | cr
1416 , 1516 , 1616 , 1716 , | cr
1717 , 1617 , 1517 , 1417 , 1317 , 1217 , | cr
1117 , 1017 , -1 ,

{block 679}


{block 680}
( -- paths 1a) | cr

: up1a align create [ 708 , 707 , 706 , 705 , 704 , 703 , 702 , 701 , 700 , 600 , 500 , 400 , | cr
1400 , 1401 , 1501 , 1500 , 1600 , 1601 , | cr
1602 , 1502 , 1402 , 1302 , 1202 , | cr
1201 , 1200 , 1100 , 1000 , -1 , | br


: up1b align create [ 708 , 707 , 706 , 705 , 704 , 703 , 702 , 701 , 700 , 600 , 500 , 400 , | cr
1400 , 1401 , 1301 , 1201 , 1101 , 1001 , | cr
1002 , 1102 , 1202 , 1302 , 1402 , 1502 , | cr
1602 , 1702 , 1701 , 1700 , -1 , | br


: !p0 uup0 [ 'pths ] ! ;
: !p1 uup1 [ 'pths ] 1 + ! ;
: !p1a up1a [ 'pths ] 1 + ! ;
: !p1b up1b [ 'pths ] 1 + ! ;

{block 681}

: path1a ( catches the port walls that are left) | cr
( after using paths) # 0 ( and 1.)
: path1b ( reverses path) # 1 ( swapping serdes roles.)

{block 682}
( - control lines) | br


: mv ( -n) [ $19 ] call $3f lit' ra! !a $3f r@ ;
: !mv ( n) lit' [ $23 ] call ;
: +a ( nn) 2 swap hook 0 64 1900 boot ; | br


: !vdc ( mv) [ 709 ] +a !mv ; | -cr : vdc ( -mv) [ 709 ] +a mv ;
: !vdi ( mv) [ 713 ] +a !mv ; | -cr : vdi ( -mv) [ 713 ] +a mv ;
: !vda ( mv) [ 717 ] +a !mv ; | -cr : vda ( -mv) [ 717 ] +a mv ;
: !bus ( mv) [ 117 ] +a !mv ; | -cr : bus ( -mv) [ 117 ] +a mv ;
: drain 2 [ 617 ] hook $aa io r! $155 io r! ;
: set ( n nn) 2 swap hook [ 2 ] + [ $10000 ] * io r! ;
: rst ( n) [ 417 ] set ;
: 1.8 ( n) [ 715 ] set ; | -cr : 1.475 ( n) [ 517 ] set ;
: hivd [ 1 ] 1.8 [ 0 ] 1.475 ; | -cr : lovd [ 1 ] 1.475 [ 0 ] 1.8 ;
: novd [ 0 ] 1.8 [ 0 ] 1.475 drain ; | br


: -pwr 0 rst 0 !vdc 0 !vdi 0 !vda novd drain ;

{block 683}
( these defns control and interrogate the uut.)
: !vdx ( and) vdx ( drive and read uut power bus) [ x ( in nonlinear millivolts.)
: !bus ( and) bus ( do the same with analog bus.)
: rst ( sets uut reset line low if) [ n 0 ( or high) 1 ]
: drain ( used only when no power enabled to short out the supply rails briefly.)
: rst ( controls uut reset line) [ 0 ( is low.)
: 1.8 ( and) 1.475 ( control power supplies) [ 1 ( enables) 0 ( disables.)
: hivd lovd ( and) novd ( select high, low, and zero voltage power supply to uut.)

{block 684}
( - all-nodes runner) | br


: pt@ ( -a) paths [ pos ] @ + ;
: active ( -nn) pt@ @ ;
: nxt ( -nn) pt@ 1 + @ ;
: -us ( nn-nn) dup paths @ or drop ;
: -end ( nn-nn) dup -1 or drop ; | br

:var 'arg [0x10303318]
: -try ( n-t) 1 [ nrun ] +! test dup [ ans ] ! 0 or drop ;
: ecch ( fail) $bad $bad rip 1 [ vval ] ! abort ;
: pass [ 'arg ] xqt -try if ecch then ; | br


: /all ( n) [ id ] ! targets @ [ pos ] ! pause | cr
0 64 [ id ] @ boot ( ?ram) pfocus ( punchout ;)
: hike key? active nxt -us if -end if | cr
dup [ tgt ] ! ( pause) wall port tfocus pass | cr
creep 1 [ pos ] +! hike ; | cr
] then then drop drop rip ;
: /zero [ 'arg ] assign 0 ;
: runall ( n) /zero /all rip ;

{block 685}

: tgt ( current target node)
: pos ( posn of current active node in path)
: nrun ( number of tests run on current chip)
: id ( puka number for test being run)
: ans ( most recent answer from a test) | br


: pt@ ( addresses path table for active node.)
: active ( returns active node no. yxx format)
: nxt ( returns next target node in path.)
: -us ( true if node given is not current boot)
: -end ( true if node given is not end path marker)
: -pass ( runs current test, true if failed) | br


: runall ( runs the test whose puka number is given on all nodes using the selected path. this path must be empty, selecting a node adjacent to the boot in use.)
: hike ( starts with active node selected. runs test against next node then creeps into it and repeats. aborts on test fail. returns with path ripped and ready to load new test after all remaining nodes in path have been tested ok.)

{block 686}
( - incremental runner) | br


: some ( n) [ id ] ! targets @ [ pos ] ! pause | cr
0 64 [ id ] @ boot ( ?ram) pfocus ;
: adv active nxt -us if -end if dup [ tgt ] ! | cr
( pause) wall port tfocus creep 1 [ pos ] +! ; | cr
] then then ecch ;
: kreep ( nn) begin key? active dup [ tgt ] ! | cr
over or drop while adv end then drop ;
: uno ( nn) kreep 0 pass ;

{block 687}
( runner components for tests that do not apply to all nodes and for tests that work on the active rather than the target node.) | br


: some ( starts work on current path given test in given bin.)
: adv ( steps to the next node in path.)
: kreep ( advances to make the given node active.)
: uno ( kreeps if necessary to the given node and runs the test there.) | br

( usage...) [ 906 some | cr
1500 kreep 1 pass 1600 uno rip

{block 688}
( - build table of valid io w/r bits)
: iom [ nns aray $201ff 0 iom nns fill ]
: iom! ( nm) push nn-n iom dup @ pop or swap ! ;
: c0, ( n) $1e00 iom! ; | -cr : l0, ( n) $1800 iom! ;
: u0, ( n) $600 iom! ; | -cr : !l ( nn) over l0, iom! ;
: !u ( nn) over u0, iom! ; | -cr : l1, ( n) $20000 !l ;
: u1, | -cr : us, | -cr : u18, ( n) $20000 !u ;
: l2, ( n) $20003 !l ; | -cr : u2, ( n) $20003 !u ;
: u4, ( n) $2003f !u ; | -cr : la, ( nn) l1, l1, ;
: ua, ( nn) u1, u1, ; | br

( single) 100 l1, 317 l1, 417 l1, 500 l1, 600 l1, ( serdes) 1 us, 701 us, ( spi) 705 u4, | cr
( async) 708 u2, ( 1wire) 200 l1, ( sync) 300 l2, | cr
( parallel) 7 u18, 8 u4, 9 u18, | cr
( analog) 709 715 ua, 713 715 ua, 717 715 ua, | cr
117 217 la, 617 517 la, | cr
( no pins) 0 c0, 2 u0, 3 u0, 4 u0, 5 u0, 6 u0, | cr
10 u0, 11 u0, 12 u0, 13 u0, 14 u0, 15 u0, | cr
16 u0, 17 c0, 400 l0, 700 c0, 702 u0, 703 u0, 704 u0, 706 u0, 707 u0, 710 u0, | cr
711 u0, 712 u0, 714 u0, 716 u0,

{block 689}
( notes-) | br

( this took the bulk of the code from softsim)

{block 690}
( - build table of rom checksums)
: sums [ nns aray 0 0 sums nns fill ]
: !sum ( n) dup push 2* $8000 + block $80 + $0 | indent
     63 for over i + @ or -next | indent
     pop sums ! drop ;
: !sums [ nns -1 + ] for i !sum -next ; !sums | cr


{block 691}


{block 692}
( - results)
: chs ( ...n) for emit next ;
: .pf [ ans ] @ 0 + drop if | cr
red 42 12 7 5 14 5 chs space ; | cr
] then green 42 36 3 3 chs space ;
: .pok blu [ vval ] @ 0 + drop if .pf ; | cr
] then silver 11 8 22 19 4 chs space ; | br


: -buses 0 1009 hook ( ou) $15555 io r! $0 data r! | cr
0 1007 hook ( in) $14555 io r! $0 data r! ;

{block 693}

: .pok ( shows how to make a blue word display variable text strings.) | br


: -buses ( quiets test chip parallel buses by setting) # 7 ( to read and) # 9 ( to write. this facilitates later creeper test using path 0. easily burns hundreds of ma if not done due to cross coupling of output mode buses on powerup.)

{block 694}
( - runner for) # 911 ( pin test) | br


: atest ( arg-ans) 1 [ nrun ] +! test dup [ rval ] ! ;
: within ( nlh-t) push less drop pop if drop 0 and ; ] then less if drop -1 +or ; ] then drop 0 and ;
: pinok ( ans) 16 /mod 16 /mod 16 200 within | cr
push 4 13 within push 4 13 within pop and | cr
pop and ( ;) drop if ; ] then 2011 [ ans ] ! ecch ; | br


: p17 $30000 ;
: p5 $30 ; | -cr : p3 $c ; | -cr : p1 $3 ;
: a911 ( p) atest pinok ;
: n911 ( np) swap kreep a911 ;
: t911 0 path 2011 some | cr
[ 1500 ] p17 n911 [ 1600 ] p17 n911 | cr
[ 1705 ] p1 n911 [ p3 ] a911 [ p5 ] a911 | cr
( 1k pullup) [ p17 ] atest [ $7000 ] +or pinok | cr
( no-caps) # 1708 ( p17 n911 p1 a911) | cr
[ 1715 ] p17 n911 [ 1517 ] p17 n911 [ 1417 ] p17 n911 | cr
[ 1317 ] p17 n911 [ 1217 ] p17 n911 rip ;

{block 695}


{block 696}
( - runner for) # 917 ( rom checksum) | br


: /917 [ 'arg ] assign [ tgt ] @ 1000 mod nn-n sums @ ;
: t917 /917 2017 /all rip ;
: /913 [ 'arg ] assign [ tgt ] @ 1000 mod nn-n iom @ ;
: t913 /913 2013 /all rip ; | br


: na00 ( np) swap kreep -try if ecch then ;
: ta00 0 path 2100 some | cr
[ 1009 ] $14555 na00 [ 1007 ] $14555 na00 rip | cr
1 path 2100 some | cr
[ 1007 ] $14555 na00 [ 1009 ] $15555 na00 rip 0 path ;

{block 697}

: t917 ( needs arg of expected xor checksum value.)
: t913 ( needs arg of io latch bit mask.)
: ta00 ( needs arg of state to leave in io at end.)

{block 698}
( - runner for) # 2113 ( serdes test) | br


: /many [ 'arg ] assign 250000 ;
: stest ( arg-ans) /many pass ; | br


: ser70 1 path [ 2112 ] some /zero | cr
[ 1701 ] kreep pass | cr
[ 1001 ] kreep 0 [ 5 ] vtest drop | cr
1 path [ 2113 ] some [ 1701 ] kreep stest rip ; | br


: ser07 1 path [ 2112 ] some /zero | cr
[ 1001 ] kreep pass | cr
[ 1701 ] kreep 0 [ 5 ] vtest drop | cr
1 path [ 2113 ] some [ 1001 ] kreep stest rip ;

{block 699}


{block 700}
( - runner for) # 2114 ( analog test) | br

:var 'side [0x103026a6]
: tops [ 'side ] assign [ $13 ] ;
: rights [ 'side ] assign [ $7 ] ;
: stest ( arg-ans) /many pass ;
: atest ( arg.ent-ans) 1 [ nrun ] +! vtest dup [ rval ] ! ;
: !da ( n) [ $4 ] atest drop ;
: @ad ( n-n) $155 or [ 'side ] xqt atest ;
: @vdd ( -n) [ $2000 ] @ad ; | -cr : @vss ( -n) [ $6000 ] @ad ;
: @off ( -n) [ $4000 ] @ad ; | -cr : @pad ( -n) [ $0 ] @ad ; | br


: a? ( nlhk) push within if drop pop drop ; ] then | cr
pop [ ans ] ! ecch ;
: /vlo 12450 14700 ; | -cr : /vhi 7800 9350 ;
: aok ( nn) kreep pause @off 0 1 [ 1 ] a? | cr
@vdd /vhi [ 2 ] a? | cr
@vss /vlo [ 3 ] a? [ $aa ] @ad /vhi [ 4 ] a? | cr
@pad /vlo [ 5 ] a? 1800 !bus 0 path | cr
@pad /vhi [ 6 ] a? 0 !bus 0 path ;
: ana0 0 path [ 2114 ] some | cr
tops [ 1709 ] aok [ 1713 ] aok [ 1717 ] aok | cr
rights [ 1617 ] aok [ 1117 ] aok rip ;

{block 701}


{block 702}


{block 703}


{block 704}


{block 705}


{block 706}


{block 707}


{block 708}
( selftest a chip, port on stack) empty stp ! | br

compile serial load -canon :var usb [0x3] | cr
stp @ dup sport ! usb ! a-bps bps ! !nam | cr
( functions) 674 4 loads ( exit) | br

( test status is) | .pok | br

( details) :var ph [0x3] :var id [0x7dd] :var tgt [0x2bd] :var pos [0x7] | cr
( -------) :var ans :var rval | cr
( -------) :var nrun [0x2d00] :var vval [0x1] | br


: init 0 [ tgt ] ! 0 [ pos ] ! 0 [ nrun ] ! 0 [ id ] ! 0 [ rval ] ! 0 [ ans ] ! 0 [ vval ] ! -1 [ ph ] ! ; init | cr
( runner) 684 7 loads 672 load 710 load | br


: run [ 708 ] list init pause talk | indent
     2pa [ 'pths ] 2 + ! | indent
     2 708 hook 2 -hook !p0 !p1 !p2 ( ;) | cr
0 [ ph ] ! 0 path z t917 t913 | cr
1 [ ph ] ! 1 path z t917 t913 | cr
2 [ ph ] ! 2 path z t917 t913 !p1a | cr
3 [ ph ] ! 1 path z t917 t913 | cr
1 [ vval ] ! ; run

{block 709}
( this code runs selected creeper tests directly on a chip using the ide. use with a-com/c-com or a literal port number.) | br


: tgt ( current target node)
: pos ( posn of current active node in path)
: nrun ( number of tests run on current chip)
: id ( puka number for test being run)
: ans ( most recent answer from a test)

{block 710}
( - paths)
: line ( ncd) swap push swap | indent
     begin dup , over + -next drop drop ;
: count ( nc-ncd) dup [ 100 ] mod [ 0 ] + if | cr
( horz) swap drop [ 1 ] ; ( vert) ] then drop [ 100 ] / [ 100 ] ;
: to ( nn) over negate + -if | cr
( back) negate count negate line ; | cr
( forw) ] then count line ; | br


: stp2 align create [ 708 717 to 617 600 to | cr
500 517 to 417 400 to 300 317 to 217 200 to | cr
100 117 to 17 0 to -1 , ]
: stp1 align create [ 708 8 to 7 707 to | cr
706 6 to 5 705 to 704 4 to 3 703 to | cr
702 2 to 1 701 to 700 0 to -1 , ]
: stp1a align create [ 708 701 to -1 , ]
: stp0 align create [ 708 8 to 9 709 to 710 10 to 11 711 to 712 12 to 13 713 to 714 14 to | cr
15 715 to 716 16 to 17 717 to -1 , | br


: !p0 stp0 [ 'pths ] ! ; | -cr : !p1 stp1 [ 'pths ] 1 + ! ;
: !p1a stp1a [ 'pths ] 1 + ! ;
: !p2 stp2 [ 'pths ] 2 + ! ;

{block 711}

: line ncd ( comma nodes into a table starting at node) n ( for) c ( nodes incrementing by) d | cr

: /left ( extend line toward the left)
: /right ( extend line toward the right)
: /up ( extend line upward)
: /down ( extend line downward)
: path ( make a default path table that) | cr
( covers the whole chip)

{block 712}
( ats target test given host port) empty stp ! | br

compile serial load -canon :var usb [0x3] | cr
stp @ dup sport ! usb ! a-bps bps ! !nam | cr
( functions) 674 4 loads ( exit) | br

( test status is) | .pok | br

( details) :var ph [0x3] :var id [0x841] :var tgt [0x3e9] :var pos [0x17] | cr
( -------) :var ans :var rval | cr
( -------) :var nrun [0x3344] :var vval [0x1] | br


: init 0 [ tgt ] ! 0 [ pos ] ! 0 [ nrun ] ! 0 [ id ] ! 0 [ rval ] ! 0 [ ans ] ! 0 [ vval ] ! -1 [ ph ] ! ; init | cr
( runner) 684 7 loads 672 load 710 load | cr
714 3 loads | br


: run [ 712 ] list init pause talk | cr
( ..) 2pa [ 'pths ] 2 + ! 2 708 hook 2 -hook | cr
( ..) !p0 !p1 !p2 setup ( ;) | cr
0 [ ph ] ! 0 path z t917 t913 | cr
1 [ ph ] ! 1 path z t917 t913 !p1a | cr
2 [ ph ] ! 1 path z t917 t913 !p1 | cr
3 [ ph ] ! serht serth talk 1 [ vval ] ! ; run

{block 713}
( this code runs selected creeper tests directly on a chip using the ide. use with a-com/c-com or a literal port number.) | br


: tgt ( current target node)
: pos ( posn of current active node in path)
: nrun ( number of tests run on current chip)
: id ( puka number for test being run)
: ans ( most recent answer from a test)

{block 714}
( - paths)
: atp2 align create | cr
[ 708 700 to 600 300 to -1 , | cr

: atp0 align create [ 708 408 to 407 400 to | cr
1400 1700 to 1701 1717 to 1617 1601 to | cr
1501 1517 to 1417 1401 to 1301 1317 to | cr
1217 1200 to 1100 1117 to 1017 1000 to -1 , ]
: atp1 align create [ 708 408 to 407 400 to | cr
1400 1700 to 1701 1001 to 1002 1702 to | cr
1703 1003 to 1004 1704 to 1705 1005 to | cr
1006 1706 to 1707 1007 to 1008 1708 to | cr
1709 1009 to 1010 1710 to 1711 1011 to | cr
1012 1712 to 1713 1013 to 1014 1714 to | cr
1715 1015 to 1016 1716 to 1717 1017 to -1 , ]
: atp1a align create [ 708 408 to 407 400 to | cr
1400 1401 to 1501 1500 to 1600 1602 to | cr
1502 1202 to 1201 1200 to 1100 1000 to -1 , | br


: !p0 atp0 [ 'pths ] ! ; | -cr : !p1 atp1 [ 'pths ] 1 + ! ;
: !p1a atp1a [ 'pths ] 1 + ! ;
: !p2 atp2 [ 'pths ] 2 + ! ;

{block 715}
( these paths are used by host chip to test the target chip via sync node 300.) | br


: atp2 ( runs from) # 708 ( to the) # 700 ( corner and down to) # 500 ( which controls target reset, accessing) # 701 ( for) [ serdes ( testing along the way. includes) # 300 ( so it may be used to boot both chips' 300.)
: atp0 atp1 ( and) atp1a ( steer clear of path two on their way to node 300's up port where they duplicate the paths used on tb001 for ats testing)

{block 716}
( - build port bridge)
: set ( n nn) 2 swap hook [ 2 ] + [ $10000 ] * io r! ;
: rst ( n) [ 500 ] set ; | br


: !sync 2 [ 300 ] hook 0 64 [ 1901 ] boot [ $19 ] call ; | br


: pt@ ( a-n) @ $15555 or ;
: frame ( a nd) nn-n 2* 32768 + block + dup 2 + pt@ 3 + for dup pt@ lit' 6 call [ 1 ] + next drop ;
: !hitst 0 [ 1902 ] frame ;
: !lotst 0 [ 1903 ] frame ;
: !his 5 [ 1904 # 1905 ] frame ; | br


: !ours ( off) [ $19 ] call 0 64 [ 1904 ] boot ( ent) [ $30 ] call ; | cr

: setup 0 rst !sync 1 rst | cr
2 [ 300 ] hook ( !hitst) !his !ours 2 -hook | cr
( testing) $0 [ 400 ] hook focus ( ;) | cr
2 -hook 1 -hook 0 -hook ;

{block 717}

: setup ( resets target chip and sets up the port bridge for ide and creeper use.) | br


: first ( we load sync boot master in our) # 300 ( done by) !sync
: second !his ( loads bridge in uut node) # 300 ( using) frame ( which sends a boot frame starting at location) [ a ( compiled for bin) nd's ( ram)
: third !ours ( loads bridge into our node) # 300 | br


: setup ( does all this and leaves ide set to node) # 400 ( which may talk to) # 1400 ( through its up port for testing of the bridged 2-chip system.)

{block 718}
( - runner for) # 2113 ( serdes test) | br


: /many [ 'arg ] assign 250000 ;
: stest ( arg-ans) /many pass ; | br


: serht 2 path [ 2112 ] some /zero | cr
( ..) [ 701 ] kreep pass rip | cr
1 path [ 2112 ] some /zero | cr
( ..) [ 1001 ] kreep 0 [ 5 ] vtest drop | cr
2 path [ 2113 ] some [ 701 ] kreep stest rip ; | br


: serth 1 path [ 2112 ] some /zero | cr
( ..) [ 1001 ] kreep pass rip | cr
2 path [ 2112 ] some /zero | cr
( ..) [ 701 ] kreep 0 [ 5 ] vtest drop | cr
1 path [ 2113 ] some [ 1001 ] kreep stest rip ;

{block 719}

: serht ( transmits 250k words from host) # 701 ( into tgt 001 with success feedback.)

{block 720}
( 10baset ethernet cluster mk1) | , | , ( tx) 8 fh 24 fh thru | , ( dma) # 28 26 fh 32 fh thru | , | .. ( tx ctl) 34 fh load | , ( rx) 36 fh 52 fh thru | , | , ( monitor) 54 fh 56 fh thru

{block 721}
( software-defined / bitbanged dma controller) | , ( for full duplex) # 10 ( megabit ethernet.)

{block 722}
( - load descriptor) | , | , ( rx) 117 +node 117 /ram io /b left /a | , | .. | .. $5555 $5d55 left down $5555 $5d55 left down | , | .. | .. $5555 $5d55 10 /stack 5 /p | , | .. 17 +node 17 /ram $200 /p | , | .. 116 +node 116 /ram down /a up /b 0 /p | , | .. 216 +node 116 /ram up /a right /b 0 /p | , | .. 217 +node 217 /ram right /a io /b 0 /p | , ( tim) 16 +node 16 /ram right /a io /b $3c /p | , ( prs) 15 +node 15 /ram left /b right /a left /p | , ( frm) 14 +node 14 /ram right /a left /b 4 /p | , ( crc) 13 +node 13 /ram left /a right /b $212 /p | , ( pak) 12 +node 12 /ram right /a left /b 0 /p | , ( swp) 11 +node 11 /ram left /a right /b 0 /p | , ( ctl) 10 +node 10 /ram right /a down /b $23 /p | , | .. 110 +node 110 /ram down /a left /b $15 /p | , | .. 109 +node 109 /ram left dup /p /a right /b | , | .. 108 +node 1801 /ram right dup /p /a left /b | , | , ( tx) 4 fh load

{block 723}


{block 724}
( - residual paths) exit | , | ,
: afeth align create [ 708 701 to 700 0 to | , 1 6 to 106 101 to 201 208 to 108 109 to | , 209 210 to 110 10 to 11 17 to 117 111 to | , 211 217 to 317 301 to 401 417 to 517 501 to | , 601 617 to 717 709 to -1 ,

{block 725}
( it is not clear that there actually exists a) | , ( single path based on) # 708 ( that can reach the) | , ( rest of the chip after pf and ether have been loaded.)

{block 726}
( - tx load descriptor) | , | , ( tx) 417 +node 417 /ram $2 /p | , | .. 317 +node 317 /ram $20000 $30000 over over | , | .. | .. over over over over over over 10 /stack | , | .. | .. io /b up /a 4 /p | , | .. 316 +node 316 /ram left /a right /b 0 /p | , | .. 315 +node 315 /ram left /b $c /p | , | .. 215 +node 215 /ram up /a down /b $c /p | , | .. 115 +node 115 /ram down /a io /b 7 /p | , | .. 314 +node 314 /ram down /a right /b $d /p | , | .. 214 +node 214 /ram up /a down /b $27 /p | , | .. 114 +node 114 /ram left /a up /b $20a /p | , | .. 113 +node 113 /ram right /a left /b $a /p | , | .. 112 +node 112 /ram left /a right /b 0 /p | , | .. 111 +node 111 /ram right /b left /a $16 /p | , exit | , ( mon) 517 +node 517 /ram io /b $200 /p | , | .. 516 +node 516 /ram left dup /a /p right /b

{block 727}


{block 728}
# 417 ( tx osc) 417 node 0 org | , | ,
: drive = $0 ( 4n) !b !b for unext drop ;
: init = $2 up a! @ drop | . io b! left a! | , 8 dup 0 $20000 9 dup $800 $30000 | , | ... dup dup drop drop 9 for drive drive next | , $15555 up 0 $20000 | . $15555 up $800 $30000 | , | ... dup dup drop drop = $422 ( go ;)
: go = $22 . @ drop . !b !b a push a! ! pop a! go ; = $26 reclaim exit ]
: go = $26 ( -if) | , . @ ( drop) . . | , drop -if !b !b a push a! ! pop a! go ; | , | .. = $2c ] then ( then) push a push $30 a! pop !+ | , | .. | .. pop !+ !+ !+ !+ !+ !+ !+ !+ !+ !+ warm ; | , = $34 reclaim exit

{block 729}
# 10 ( mhz ceramic resonator drive.) | , ( each) # 50 ( ns edge sends a return instruction) | , ( thru up port to tx pin node) # 317 ( which waits) | , ( for the edge by simply calling the port.) | , | , ( node) # 317 must ( wait faithfully for) every ( edge) | , ( to keep this oscillator running reliably.) | , | ,
: note ( that after starting, the resonator decays in about) # 10 ( us; so node) # 317 ( starts us when it is ready to go by writing to the port.) | , | , ( timing is actually quite tight in here; had to fight to keep duty cycle lt) # 100 ( to prevent) | , ( creep. also the resonator enthusiastically) | , ( responds to pumping; rings have phase jitter) | , ( so for this app with) # 20 ( mhz stimuli we must) | , ( pump on every edge. ring code would be...) | , ( ring) = $22 @ drop drop !b a push a! ! pop a! ..

{block 730}
( 317/316 tx pin) 317 node 0 org | , | ,
: 0bit = $0 @ drop !b @ drop !b ;
: 1bit = $2 drop 0bit drop ;
: init = $4 0 dup ! ( ...)
: sil ( 1/2bt) = $6 push 0 .. @ drop !b .. | , | .. | .. = $9 begin @ drop unext .. | , | .. = $a dup 15 for = $c 19999 for | , | .. | .. = $e @ drop drop . | , | .. | .. = $f @b 2* 2* . -if drop r--- | , | .. = $13 then next next drop ( ... slp) | ,
: slp = $16 @ drop dup !b @ drop 81 sil ;
: goose = $1a begin drop @ drop dup !b
: idle = $1c @b -until | , | ... drop 4 for @ drop unext 83 sil ;
: flp = $22 1249 sil ; = $24 | , | , # 316 ( wires instructions from) # 315 ( to) # 317 | , 316 node 0 org ]
: wir = $0 begin begin @ !b unext unext wir ; = $2

{block 731}
( manchester encoding transmitter. instructions executed in right port.) | , | , ] bit ( sends a) [ zero ( hi-lo.) | , ] over bit ( sends) [ one ( lo-hi.) once transmission is started bits must be ready before needed. | , ] idle ( ends transmit with) [ tp-idl ( waveform, high for) # 3 ( bit times then sil-ent.) | , ] sil ( -ent sets hi-z, forces silence for 1/2 the number of bit times given, then polls for work to do while keeping the oscillator happy.) | , ( counts cycles, generating a) [ slow link pulse ( if there have been) 16ms ( / 320,000 stimuli since) | , ( last transmit or link pulse.) | , ] slp ( sends the) [ link pulse ( and resumes timing.) | , ( called thru the right port for) flp sequences | , ( during auto-negotiation.) | , ] flp ( delays 62.5us to time interbit interval.)

{block 732}
# 315 ( tx sel) 315 node | , host | *
: 'rd-- $12195 lit ; | *
: '-d-- $12115 lit ; | , | * | .. | ..
: 'r--- $121d5 lit ; target 0 org | , | ,
: /slp = $0 @p !b ; ] .. slp ;
: /flp = $2 @p !b ; ] .. flp ;
: /-lnk = $4 ( 1.25 sec) 20000 for /flp next ; | , | ,
: kall = $9 ( a) dup a! push ex ;
: run = $c 'rd-- a! @ drop io a! @ dup push = $c11 | , | .. $2000 and if '-d-- kall then = $15 | , | .. pop 2* 2* -if 'r--- kall then run ; = $1a
: /wd ( n) 15 for /slp /flp | , | ... dup 1 and if /slp then drop | , /flp 2/ next /slp 223 for /flp next ; | , | ,
: /idle = $2a @p !b ; ] .. idle ;
: /one = $2c @p !b ; ] .. 1bit
: /zer = $2e @p !b ; ] .. 0bit | , = $30

{block 733}
( node) # 315 ( may be commanded by) # 314 ( or 215.) | , ( to claim the node write two words of zero back to back then you own it, no focus needed,) | , ( return when done.)

{block 734}
( 115/215 autonegot) 215 node 0 org | , | ,
: !link ( n) = $0 @p drop !p ; | *
: link ( -n) = $1 -1 ;
: attn = $3 @p dup .. . .. = $5 !b !b ;
: -attn = $6 @p !b ; ] .. ; | ,
: -lnk = $8 @p !b ; ] .. /-lnk
: wd ( n) = $a @p !b !b ; ] .. @p /wd
: auto = $c begin @ dup !link | , | .. | .. dup # $41 $4041 and # $41 $4041 or until | ,
: neg = $12 attn -lnk 4 for $41 wd next | , | .. | .. 7 for $4041 wd next -attn | , | .. 60000 # 20000 ( n.n ms) for | , | .. | .. 41664 for unext next auto ; = $25 | , | , 115 node 0 org ]
: !link ( n) = $0 @p drop !p ; | *
: link ( -n) = $1 -1 ;
: pass a up a! link ! a! ;
: done = $7 @ !link begin | , | .. @b $400 or dup $400 and if pass done ; | , | .. ] then drop $2000 and until done ; | , = $12

{block 735}
( node) # 115 ( passes new link states from 015 to) # 215 ( without blocking 015 ever. suspends till new state is available then spins on io to deliver it to 215. new state may be received while) | , ( spinning and this simply replaces the state we are trying to deliver.) | , | , ( node) # 215 ( takes latest state from) # 115 ( and makes node 315 do the thing about it.) # 215 ( is) | , ( not required to be timely in reading from) # 115

{block 736}
# 314 ( tx framing) 314 node 0 org | , | ,
: attn = $0 @p dup .. . .. = $2 !b !b ;
: -attn = $3 @p !b ; ] .. ; | ,
: -lnk = $5 @p !b ; ] .. /-lnk ; | , | ,
: +one = $7 @p !b ; ] .. /one
: +zer = $9 @p !b ; ] .. /zer
: +idle = $b @p !b .. /idle ; ( ...)
: run = $d @ -if attn -lnk run ; ] then attn
: pre = $12 30 for +one +zer next +one +one
: pkt = $19 @ -if +idle then | , | .. = $1b if +one pkt then | , | .. = $1e +zer pkt | , = $20 [ reclaim

{block 737}
# 315 ( passes commands and packets, converting to bit commands, adding preamble and idle pulse) | , ( to frame packets. stimuli begin with the t.xn field value as follows...) | , | , | .. $ -1 ( force renegotiation of link.) | , | , | .. n ( packet of n bytes, in n*8 words.) | , | .. | .. 0/1 ( data bits, multiple of 8,) # 1 ( per word) | , | .. | .. 1x xxxx xxxx xxxx xxxx ( end marker) | , | ,

{block 738}
# 214 ( tx delay) 214 node 0 org reclaim | , | , = $0 ( buffer) # 32 ( words) $20 org | , | ,
: @!+ ( an-a'n') = $20 a push push dup a! | , | .. $1 . + 31 and @ pop ! pop a! ; | , | ,
: run = $27 begin @ dup !b - -until dup or
: fill ( a-a) = $2a 31 for @ @!+ drop next | ,
: pass ( a-a) = $2e @ -if | * | , | ..
: purge ( a-a) = $2f push 31 for dup @!+ !b next | * | , | ..
: crc ( a-a) = $33 31 for @ !b unext pop !b run ;
: body ( a-a) = $38 then @!+ !b pass ; | , = $3a reclaim

{block 739}
# 214 ( buffers bits out from crc, holding) # 32 ( bit times of data to keep the packet flowing while calculating final crc. see crc for incoming.) | , | , ( outgoing data...) | , | .. $ -1 ( force renegotiation of link.) | , | , | .. n ( packet of n bytes follows in n*8 words) | , | .. | .. 0/1 ( data bits, multiple of 8,) # 1 ( per word) | , | .. | .. 0/1 ( crc bits,) # $32 ( words) | , | .. | .. 1x xxxx xxxx xxxx xxxx | , | , ( we start a packet by notifying framer to send preamble. this gives us) # 64 ( bit times during) | , ( which we prime our) # 32 ( bit fifo. thereafter we send one bit for each new bit received. upon) | , ( receiving end packet indicator we empty the) | , ( fifo while crc node generates the final) # 32 | , ( bits that we pass through.)

{block 740}
# 114 ( tx crc) reclaim 114 node 0 org +cy | ,
: +crc ( mhlb-mhl) = $200 push dup . + pop or push | , | .. dup . + over over and .. = $204 if ( ** then) | , | .. | .. = $205 or $130 or pop $11db7 or ; | , | .. = $209 ( **) ] then drop pop ;
: run = $20a begin @ dup !b - -until | , | .. = $20c $4000 clc dup dup or dup 31 for | , | .. | .. = $211 @ dup !b 1 or +crc next | , | .. ahead begin dup !b +crc [ swap ] then @ -until
: trail = $219 !b 31 for 0 +crc next | , | .. = $21e 3 for dup . + push dup . + pop next | , | .. = $223 31 for dup . + push dup . + pop | , | .. | .. dup dup or dup . + 1 or !b next run ; | , = $22d reclaim

{block 741}
# 114 ( calculates and attaches crc.) | , | ,
: +crc ( inserts one bit. hl is 32-bit crc packed) | .. ( into a) # 36 ( bit number, 14/18. m tests the bit) | .. ( shifted out of high order.)
: run ( passes link-down msg and starts crc when) | , | .. ( packet arrives. the packet) [ must ( be longer) | , | .. ( than) # 32 ( bits due to loop structure.)
: trail ( ends pkt by running) # 32 ( zeroes into the) | , | .. ( crc and then clocking it out, whole word) | , | .. ( msb first.) | , | .. [ trail takes on the order of 2.5us ( or) # 25 ( bit) | , | .. ( times before it sends the first crc bit down) | .. ( the pipeline.) hence the special delay node. | , | , ( outgoing data...) | , | .. $ -1 ( force renegotiation of link.) | , | .. n ( packet of n bytes follows) | , | .. | .. 0/1 ( data bits, n*8 words) | , | .. | .. $ 20000 ( end data marker) | , | .. | .. 0/1 ( crc bits,) # 32 ( words)

{block 742}
# 113 ( tx unpack) 113 node 0 org reclaim | ,
: hi ( 1n-1) = $0 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ = $803 ( ...)
: lo ( 1n-1) 7 for over over and !b 2/ next drop ;
: done = $8 $20000 !b ( ...)
: run = $a begin @ dup !b - -until | , | .. = $c - push 1 zif then | , | .. = $f begin @ over over hi drop zif done | , | .. | .. = $13 then lo ( drop) next done ; | , | , = $16 reclaim

{block 743}
# 113 ( passes force-down and packets. unpacks packets to bit strings.) | , | , ( incoming data...) | , | .. $ -1 ( force renegotiation of link.) | , | , | .. n ( packet of n bytes follows in n/2 words) | , | .. | .. $ 00 aaaa aaaa bbbb bbbb ( a 1st octet b 2nd) | , | , ( outgoing data...) | , | .. $ -1 ( force renegotiation of link.) | , | , | .. n ( packet of n bytes follows in n*8 words) | , | .. | .. 0/1 ( data bits, multiple of 8,) # 1 ( per word) | , | .. | .. 1x xxxx xxxx xxxx xxxx ( end marker)

{block 744}
# 112 ( tx wire) 112 node 0 org reclaim | ,
: wire = $0 @ !b wire ; = $1 | , | , = $1 reclaim

{block 745}
# 112 ( is just a wire, we think.)

{block 746}
# 108 ( sram master) reclaim host | ,
: t.cm $8000 lit ; | *
: t.pf $8001 lit ;
: t.rx $8002 lit ; | *
: t.ep $8003 lit ;
: t.lk $8004 lit ; | *
: t.dp $8005 lit ; ( double)
: t.sk $8007 lit ; | *
: t.wk $8008 lit ;
: t.xa $8009 lit ; | *
: t.xn $800b lit ;
: t.pp $800c lit ; | *
: t.tt $800d lit ;
: rxdm $ff7f lit ; target | , | , 108 node $39 org 278 load = $40 0 org ]
: .ex! ( paw) = $0 push @ push @ pop pop ex! ;
: .ex@ ( pa-w) = $3 push @ pop ex@ ! ; | , | ,
: stm = $6 @b ! ;
: inc ( n-n) = $7 1 . + ;
: +des = $9 4 t.rx x@ + rxdm and t.rx x! ( temp ;)
: +tsk = $11 t.wk x@ t.sk x@ x! ;
: ?rxb ( -p,a) = $16 t.rx x@ t.ep x@ over or if | , | .. drop dup inc x@ over x@ then ! ! ;
: 2tal ( a) = $20 @ dup inc dup x@ inc dup push | , | .. $ffff and over x! pop 2* -if | , | .. | .. drop drop dup x@ inc over x! | , then ; | , = $2e 1801 bin ( ...)

{block 747}
( node) # 108 ( is the actual sram master.) | , ( it supports passthru memory ops and is) | , ( capable of being programmed for other slave) | , ( operations. registers are) | , | , ] a ( and) p ( right for instructions from) # 109 | , b ( left for sram controller.) | , | ,
: .ex@ ( and) | *
: .ex! ( are port called to effect our) | , ( instructor's) x@ x! ( etc words.)
: stm ( waits for stimulus and informs master.)
: inc ( increments a number.)
: +tsk ( awakens our task.)
: +des ( circularly increments next rxd pointer.)
: ?rxb ( returns next rx buffer address, p zero if none available for use.)
: 2tal ( increments a double number at given addr.)

{block 748}
# 109 ( dma nexus slave) 109 node 0 org | ,
: x! ( wa) = $0 dup dup or
: ex! ( wap) = $1 @p !b !b .. @p .ex! .. !b !b ;
: x@ ( a-w) = $4 dup dup or
: ex@ ( ap-w) = $5 @p !b !b .. @p .ex@ .. !b @b ;
: .ex! ( p.aw) = $8 push @ push @ pop pop ex! ;
: .ex@ ( p.a-w) = $b push @ pop ex@ ! ; | , | , | ,
: /stm = $e @p !b .. stm .. @b ! ;
: /?cm ( -n) = $11 t.cm x@ if | , | .. dup dup or t.cm x! then ! ; | ,
: /rxb ( -a,p) = $18 @p !b @b .. ?rxb .. @b ! ! ;
: /2t ( a) = $1b @p !b .. 2tal .. @ !b ;
: /des = $1e @p !b ; ] .. +des | , = $20 ( ...) | ,

{block 749}
( node) # 109 ( connects dma nexus with 108, the) | , ( actual sram master.) | , | , ( supports passthru memory ops and supports the) | , ( nexus with some other overflow operations.) | , ( registers are) | , | , ] a ( and) p ( left for instructions from) # 110 | , b ( right for instructions to 108.) | , | ,
: x@ | *
: x! ( etc command slave node's) .ex@ ( and) .ex!
: .ex@ ( and) | *
: .ex! ( are port called to effect our) | , ( instructor's) x@ x! ( etc words.)
: /stm ( stim wait by) # 108
: /?cm ( poll cmd)

{block 750}
# 110 ( dma nexus) 110 node 0 org | ,
: x! ( wa) = $0 dup dup or
: ex! ( wap) = $1 @p !b !b .. @p .ex! .. !b !b ;
: x@ ( a-w) = $4 dup dup or
: ex@ ( ap-w) = $5 @p !b !b .. @p .ex@ .. !b @b ;
: /ex! ( paw) = $8 @ push @ push @ pop pop ex! ;
: /ex@ ( pa-w) = $b @ push @ pop ex@ ! ; | , | ,
: stm = $e 0 @p !b .. /stm ( fallthru...)
: !live = $11 @p drop !p ; | *
: live -1 ;
: sel = $14 a! @ push ;
: -dma = $15 stm
: ?cmd = $16 live if @p !b @b .. /?cm .. if | , | .. = $1b dup push 2* 2* ex then | , | .. = $1d t.pp x@ 2* 2* push then
: poll = $20 begin io a! $a800 dup | , = $23 begin drop zif ?cmd then | , = $25 | .. @ over and until | , = $27 2* 2* ( ..) -if ( tx) right sel = $2a then | , = $2a 2* 2* ( ..) -if ( rx) down sel poll ; = $2e ] then | , = $2e 2* 2* -until @b !live ?cmd ( ;) | ,
: +tx ( x) = $32 right a! ! ; | , = $34 ( ...)

{block 751}
( node) # 110 ( is continually active, polling its) | , ( clients 010 and) # 111 ( as well as monitoring) # 109 ( for stimuli.)
: poll ( polling dispatcher for rx/tx nodes and) | , ( stimulus from pf. these functions must protect the top of stack.) dma functions are...
: /ex@ ( and) | *
: /ex! ( sram ops.)
: /live ( returns state.) | , | , ( polls at t.pp period for t.cm commands from pf) pf commands are...
: !live ( sets) # 0 ( no dma,) # 1 ( no traffic,) # -1 ( all up.)
: -dma ( cmd to state) # 0 [ don't use !live for this! ]
: +tx ( alert tx node of new function in) t.xn | ,

{block 752}
# 110 ( continued) | ,
: /live ( -n) = $34 live ! ;
: ,rxb ( -a,p) = $36 @p !b @b .. /rxb .. ! @b ! ;
: ,2t ( a) = $39 @p !b .. /2t .. @ !b ;
: ,des = $3c @p !b ; ] .. /des | , = $3e ( ...)

{block 753}


{block 754}
# 111 ( tx ctl) 111 node 0 org ]
: x! ( wa) = $0 dup dup or
: ex! ( wap) = $1 @p !b !b .. /ex! .. !b !b ;
: x@ ( a-w) = $4 dup dup or
: ex@ ( ap-w) = $5 @p !b !b .. /ex@ .. !b @b ; | , | ,
: !pg = $8 @p drop !p ; | *
: pg $31416 ;
: inc ( n-n) = $b 1 . + ;
: done = $d 0 t.xn x! | , | .. ( wake) = $11 t.wk x@ t.sk x@ x! ( ...)
: run = $16 begin @b drop t.xn x@ until | , | .. | .. = $1a dup 2* 2* -if ! drop done then | , | .. = $1e drop dup ! - inc - 2/ push | , | .. t.xa dup x@ !pg inc x@ begin | , | .. | .. = $26 dup pg ex@ ! inc next drop done ; | , = $2b ( ...)

{block 755}
# 111 ( is xmit dma control.) note that b points to dma and a to tx chain, reverse of normal. | , | , ] +tx ( command from pf alerts us to new function found in) t.xn ( ...) | , | , | .. [ $ -1 ( force autonegotiation) | , | .. 0 ( invalid, ignored) | , | .. +n ( transmit packet of n octets starting at) | , | .. | .. ( double address in) ] t.xa. [ data guaranteed | , | .. | .. not to cross page boundary. | , | , ( when any of these functions complete, t.xn is set zero to show done and pf task is awakened.) a new tx command may not be stored and +tx cmd sent until ] t.xn [ is zero. dma controller will | , lock up if this protocol is violated.

{block 756}
( 010 rx ctl) 10 node 0 org | ,
: x! ( wa) = $0 dup dup or
: ex! ( wap) = $1 @p !b !b .. /ex! .. !b !b ;
: x@ ( a-w) = $4 dup dup or
: ex@ ( ap-w) = $5 @p !b !b .. /ex@ .. !b @b ;
: ?live ( -n) = $8 @p !b @b ; ] /live ; | ,
: ?rxb ( a,p-ap) = $a @p !b .. ,rxb .. @b @b ;
: 2tal ( a) = $d @p !b !b ; ] ,2t
: +des = $f @p !b ; ] .. ,des | , | ,
: !pg = $11 @p drop !p ; | *
: pg 0 ;
: x!+ ( an-a') = $14 over pg ex! $1 . + ;
: !lk = $18 @ ?live -if drop -if | , | .. t.wk x@ t.tt x@ x! ahead [ swap | , | .. | .. ] then t.lk x! then then ( ...)
: run = $23 @ if !lk ; ] then ?live -if | , | .. ?rxb if !pg dup 2 . + | , | .. | .. begin @ -if push drop pop x!+ @ x!+ | , | .. | .. | .. +des run then x!+ end | , | .. then ( no buffs) t.dp 2tal then
: toss = $36 begin @ -until @ run ; | , = $38 reclaim exit

{block 757}
# 10 ( is xmit dma control. incoming...) | , | , | .. $ -1 ( status msg, next word one of two formats) | , | .. | .. 0xxxx ( new link state x is) # 0 ( down,) # 1 ( 10hd,) | , | .. | .. | .. ( else last active code word received.) | , | .. | .. $ -1 ( signal to prod timer task.) | , | , | .. 0 ( packet as follows) | , | .. | .. $ 00 aaaa aaaa bbbb bbbb ( a 1st octet b 2nd) | , | .. | .. 10 $ 8000 $ 0000 0crl 0ddd ( where) | , | ... | ... ] c ( crc-error) | , | ... | ... r ( runt; lt) # 64 ( octets.) | , | ... | ... l ( too long; gt) # 1518 ( octets.) | , | ... | ... d ( number of dribble bits.) | , | .. | .. [ length ( received in octets without dribble)

{block 758}
( 011 rx byteswap) 11 node 0 org reclaim | , | ,
: idl = $0 @ -if !b @ !b idl ; ] then !b
: pkt = $4 $ffff dup dup or 759 push begin
: word ( msk) # 0 = $8 @ -if
: sts ( w) = $9 push @ dup push 2/ 2/ 2/ | , | .. pop 7 and pop or | , | .. over -64 . + -if drop $20 or dup then drop | , | .. over -1519 . + - .. -if drop $10 or dup then | , | .. | .. drop !b !b idl then | ,
: bswap = $1b a push dup 2* 2* a! | , | .. | .. 9 for +* unext drop over a and | , | .. !b pop a! next | ,
: lng = $23 begin @ -until sts ; | , = $25 reclaim exit

{block 759}
( node) # 11 ( byteswaps packet data from node) # 12 | , ( to avoid inter-bit latency. also checks length and framing, enforcing stored size limits.) | , ( output messages...) | , | , | .. $ -1 state ( new link state) # 0 ( down,) # 1 ( 10hd,) | , | .. | .. ( else last active code word received.) | , | , | .. 0 ( packet as follows) | , | .. | .. $ 00 aaaa aaaa bbbb bbbb ( a 1st octet b 2nd) | , | .. | .. 10 $ 8000 $ 0000 0crl 0ddd ( where) | , | ... | ... ] c ( crc-error) | , | ... | ... r ( runt; lt) # 64 ( octets.) | , | ... | ... l ( too long; gt) # 1518 ( octets.) | , | ... | ... d ( number of dribble bits.) | , | .. | .. [ length ( received in octets without dribble) | , | , 759 ( limits packet size stored to) # 1518 ( octets) | , ( plus one word of dribble.)

{block 760}
( 012 rx pack) 12 node 0 org reclaim | , | ,
: idl = $0 @ -if !b @ !b idl ; ] then !b
: pkt = $4 $10000 dup
: bit ( w) = $6 @ -if push ahead
: flush begin drop 2/ | , | .. | .. [ swap ] then dup 1 and until drop 2/ !b | , | .. pop !b @ !b idl then | ,
: shift push dup 1 and if | , | .. | .. drop 2/ !b dup dup then drop | , | .. pop if drop 2/ over or bit ; | , | .. | .. ] then drop 2/ bit ; | , = $19 reclaim

{block 761}
( node) # 12 ( packs framed data into 16-bit pairs of octets, little-endian, last word padded if odd output messages...) | , | , | .. $ -1 state ( new link state) # 0 ( down,) # 1 ( 10hd,) | , | .. | .. ( else last active code word received.) | , | , | .. 0 ( packet as follows) | , | .. | .. $ 00 bbbb bbbb aaaa aaaa ( a 1st octet b 2nd) | , | .. | .. 10 $ 8000 $ 0000 0c00 $ 0000 ( where) | , | ... | ... ] c ( crc-error) | , | .. | .. [ length ( in bits after preamble including) | , | ... | ... ( any dribble bits.)

{block 762}
( 013 rx crc) reclaim 13 node 0 org +cy | , | ,
: +crc ( mhlb-mhl) = $200 push dup . + pop or push | , | .. dup . + over over and .. = $204 if ( ** then) | , | .. | .. = $205 or $130 or pop $11db7 or ; | , | .. = $209 ( **) ] then drop pop ; | ,
: check ( mhls) = $20a push push $3c000 or pop | , | .. and - if $40 then pop or !b @ !b ( ...)
: run = $212 @ -if !b @ !b run ; ] then !b | , | .. | .. $4000 clc dup dup or dup | , | .. = $219 31 for @ -if check | , | .. | .. = $21d then dup !b 1 or +crc next ahead | , | .. = $222 begin dup !b +crc [ swap ] then @ -until | , ( done) check ; | , = $226 reclaim exit | , | ,
: wire = $231 @ !b wire ; = $232 | ,
: !hi = $20a @p drop !p ; | *
: high $31416 ;
: !lo = $20d @p drop !p ; | *
: low $31416 ; | ,
: debug ( mhls) push push dup !hi pop dup !lo pop

{block 763}
( node) # 13 ( passes framed data, calculating crc on packets and setting crc error bit as needed.) | , ( output messages...) | , | , | .. $ -1 state ( new link state) # 0 ( down,) # 1 ( 10hd,) | , | .. | .. ( else last active code word received.) | , | , | .. 0 ( packet as follows) | , | .. | .. 0/1 ( data bits, multiple of 8,) # 1 ( per word) | , | .. | .. 10 $ 8000 $ 0000 0c00 $ 0000 ( where) | , | ... | ... ] c ( crc-error) | , | .. | .. [ length ( in bits after preamble including) | , | ... | ... ( any dribble bits.) | , | ,
: +crc ( inserts one bit. hl is 32-bit crc packed into a) # 36 ( bit number, 14/18. m tests the bit) | , ( shifted out of high order.)
: check ( sets c status if crc is not all 1's.) | , debug ( and variables are for testing.) | , ** then ( swap comments to force worst) | , ( case when measuring timings.)

{block 764}
( 014 rx frame) 14 node 0 org reclaim | , | ,
: runt = $0 # $28040 $28000 !b $0 !b
: idl = $4 @ -if !b @ !b idl ; ] then !b | ,
: pre 7 for @ -if runt then next | , | .. 55 for @ -if runt then | , | .. | .. over over and ( 1-1) if ( end preamble) dup or
: pkt @ -if $28000 !b drop !b idl then | , | .. !b 1 . + pkt ;
: -pkt then drop | , | .. over over or while drop next then runt ; | , = $1f reclaim

{block 765}
( node) # 14 ( frames packets by stripping preamble) | . ( appending two words at end.) | , ( output messages...) | , | , | .. $ -1 state ( new link state) # 0 ( down,) # 1 ( 10hd,) | , | .. | .. ( else last active code word received.) | , | , | .. 0 ( packet as follows) | , | .. | .. 0/1 ( data bits, multiple of 8,) # 1 ( per word) | , | .. | .. 10 $ 8000 $ 0000 $ 0000 $ 0000 | , | .. | .. length ( in bits after preamble including) | , | ... | ... ( any dribble bits.)

{block 766}
( 015 rx parse) 15 node 0 org reclaim | , | ,
: !prv ( n) = $0 @p drop !p ; | *
: prv ( -n) = $1 0 ;
: !link ( n) = $3 @p drop !p ; | *
: link ( -n) = $4 $ffff ; | , | ,
: negot ( n-n) = $6 a down a! over ! a! ;
: report ( n) = $9 a io a! @ 2* -if drop a! drop ; | , | .. ] then drop a! -1 ! ! ; | , | ,
: ldown = $10 1 0 | *
: slp ( nw)
: ?link ( nw) over if 2/ if 2* 2* .. -while then | , | .. ( wx) = $17 drop prv over or if drop !prv ; ] then | , | .. ( wx) drop link over or .. if drop dup !link | , | .. | .. negot # -1 ( ! !) report ; | , | .. ] then - report then then drop ;
: -flp ( -nw) = $23 $10000 link if ; ] then drop 1 ;
: flp1 ( n-n) = $29 $10000 or
: flp0 ( n-n) = $2b 2/ push 2/ pop ; | , | ,
: sdata = $2d dup or begin ! @b -until ! ; | , = $30

{block 767}
( node) # 15 ( parses incoming events from node 15,) | , ( maintaining link state and sending refined) | , ( events to) # 115 ( for negotiation and 014 for) | , ( packet data and state changes.) | , ] b [ left ( for incoming,) ] a [ right ( for outgoing...) | , | .. nz state ( new link state) # 0 ( down,) # 1 ( 10hd,) | , | .. | .. ( else last active code word received.) | , | .. zero ( packet follows...) | , | .. | .. 0 ( data bit zero) | , | .. | .. 1 ( data bit 1) | , | .. | .. negative ( end of packet.) | ,
: link ( most recent link state, changed when)
: prv ( shows two consecutive same states.) [ we need | .. a better noise filter than this. ]
: negot ( sends link state value to node) # 115
: report ( reports link change to host.)
: ?link ( updates link, sends to negot and sends) | , | .. ( to node) # 14 ( if state has changed. prods timer) | .. ( task on 16ms link pulses or 100ms timeouts.) | , | ,
: ldown | *
: -flp | *
: flp0 | *
: flp1 | *
: slp ( and) | *
: sdata | , ( are called thru the port by node) # $16

{block 768}
( 016 rx timing) 16 node 0 org | , = $0 0 org ]
: yank = $0 a down a! dup ! a! ;
: ?lp ( us-us) = $3 dup for ( 1us) 48 for ( 20.7ns) | , | .. @b 2* 2* -if drop @ = $809 if drop | , | .. | .. pop drop pop - . + ; ] then then | , drop next next ( nada) dup or ;
: send ( n) = $f a left a! over ! a! drop ;
: pkt = $13 @p .. sdata = $15
: !data send ( 1bt) 4 for @b 2* 2* -if @ !data ; | , | .. ] then next - yank ( idle) ahead
: lkp ( us-us) = $1e ?lp if 0 ?lp if pkt | , | .. then drop then yank ;
: idle = $26 then send 100000 lkp if @p .. -flp
: flps = $2c send 150 lkp if -100 . + -if | , | .. = $33 100 lkp drop .. @p flps ; ] flp1 | , | .. = $38 then @p flps ; ] flp0 | , = $3a then @p idle ; ] slp | ,
: ent = $3c then yank @p idle ; ] ldown | , = $3f [ reclaim

{block 769}
( node) # 16 ( times events from the receiver, dis-) | , ( criminating data, flp, slp and link-down) | , ( timeout. events passed to node) # 15 ( are) | , | ... ldown call ( link down, always sent first.) | , | ... -flp call ( start of flp word) | , | ... | ... flp0 call ( flp) # 0 ( bit) | , | ... | ... flp1 call ( flp) # 1 ( bit) | , | ... | ... slp call ( slow link pulse or end word) | , | ... sdata call ( packet follows...) | , | ... | ... 0 ( data bit zero) | , | ... | ... 1 ( data bit 1) | , | ... | ... negative ( end of packet.) | ,
: yank ( messages node) # 116 ( to enable) # 217 ( yank-down) | .. ( of pin if it stays high several bit times.)
: ?lp ( waits for a link pulse up to given number) | .. ( of usec. returns us waited,) # 0 ( if no pulse.)
: send ( passes an event word to node 015.)
: pkt ( sends) [ sdata ( followed by) 0/1 ( events till) | , | .. end of packet. ]
: idle ( is the non-stateful observer.)
: !data ( has used) # 100 ( ns by the time) | , | .. ( loop starts so) # 5 ( iterations gets) | , | .. ( us) # 2 ( bit times, plenty for idle) | , | .. ( w/o dribbling.)

{block 770}
( 217/216/116 rx active pull-down) | , | , 217 node 0 org reclaim ]
: init = $0 $25555 # $5555 $15555 over over over over | , | .. over over over over ( hi z) !b
: yanker = $6 @ | , | .. 9 for = $8 drop @b -while . . next = $a | , drop !b !b yanker ; | , ] then drop yanker ; = $d | , | , ( minimal latency a-b wire) | , 116 node 0 org ]
: wir = $0 begin begin @ !b unext unext wir ; | , = $2 reclaim

{block 771}
( when a device sends only the positive going) | , ( half of a link pulse, we must yank the pin low ourselves to reset the schmitt so we can see) | , ( the next positive going link pulse.) | , | , ( node 016 sends a word of garbage 116-216-217 after seeing a link or end packet pulse.) | , | , ( node) # 217 ( responds by waiting) # 2 ( bit times to) | , ( let an idle pulse finish, then yanking the pin if it has remained high all that time. the delay loop is nominally 18.1 ns/cycle.) | , | , ] note that [ $ 15555 is used in init to leave the | , pin in weak pulldown as a measure to reduce | , incoming noise. ideally that is taken care of outside and more symmetrically so that we can leave the pin at high z.

{block 772}
( 117/017 rx pin) 117 node 0 org reclaim ]
: edge ( rise fall) = $0 push @b -if | , | ... | .. pop !b ! . drop . . ; | , ] then over !b ! . pop drop drop ; | , | ,
: run = $5 edge a! @b ! 4 push a! | , | ... begin unext run ; = $a | , | , # $17 ( buffers for) # 16 ( and converts bits to 1/0) | , 17 node 0 org +cy | ,
: wire = $200 down a! right b! $20000 clc
: pass = $206 @ over and dup . + dup . + !b pass ; = $20a reclaim

{block 773}
( the ethernet rx pin node acts as a continuous manchester decoder, recovering and passing) | , ( each data bit to an adjacent buffering node) | , ( to eliminate jitter in its timing sequence.) | , ( this code automatically acquires bit sync) | , ( during frame preambles. when a link pulse is) | , ( positive only it decodes as a single '1' in) | , ( which case another node must drive the pin low momentarily to reset the schmitts; this may) | , ( produce a spurious '0'.) | , | ,
: edge ( samples pin and waits for opposite state.)
: run ( waits for the edge at the center of a bit cell, writes the value of io with the data bit in position) # 17 ( to the buffering node, then) | , ( delays long enough that the next) edge ( call) | , ( will be well centered in the first half of the next bit cell, maximizing margins for sampling and waiting. it is paramount that the delay) | , ( never be too long since that means loss of bit sync. duty cycle is always lt) # 100 ( pct.)

{block 774}
# 517 ( tx osc monitor) 517 node reclaim | , 0 org +cy ]
: run = $200 left a! 0 dup
: spin = $203 0 !b @ drop | , | .. | .. = $606 push 1 . + pop 0 . + $3fff and | , | .. = $e0b $800 !b @ drop @b 2* 2* -if | , | .. | .. = $20f drop r--- spin ; ] then drop spin ; | , | ,
: -clk ( -00) = $213 dup or dup ( ...)
: ask ( lh-lh) = $214 a push right a! | , | .. over ! dup ! pop a! ; | , = $218 ( ...)

{block 775}
( this node maintains a 32-bit free running) | , ( count of cycles seen on an incoming signal.) | , ( as used here this is a 10mhz clock.) ability to jumpstart the oscillator removed; it can't be done safely without polling. | , | , ( receives requests through the) right ( port as jump instructions. always returns two 16-bit) | , ( words...) | , | ,
: ask ( queries the clock, returning low and high halves in that order.)
: -clk ( zeroes the clock for time since boot.)

{block 776}
# 516 ( tx osc agent) 516 node 0 org +cy | , | ,
: @tfre = $200 @p .. ask ; | * | , | ..
: ans = $202 !b @b @b .. ( lh) | , | .. = $203 over push 1 for | , | .. | .. = $206 push dup . + pop dup . + next | , | .. = $209 ( h) ! pop ( l) ! ; # $210 ( org)
: -fre = $20a @p .. -clk ; | , | .. = $20c ] ans ; | , = $20d reclaim

{block 777}
( this node translates ganglion transactions) | , ( into the port timing protocol used to get the attention of node 517. the ganglion messages, coming through) left ( port in) ] a, ( deliver focus) | , ( and call to one of these routines, which talk to node) # 517 ( through) [ right ( port in) ] b. | , ( each produces two 16-bit words in reply...) | , | ,
: @tfre ( queries the clock, returning high and) | , ( low halves in that order for storage as a dbl number in pf memory.) | , | ,
: -fre ( zeroes the clock for coherent time since boot. returns two words of zero.)

{block 778}


{block 779}


{block 780}
( ether test ide) empty compile | br

serial load | cr
( customize) -canon 0 fh orgn ! | cr
a-com sport ! a-bps bps ! !nam | ,
: tstp2 align create [ 708 508 to 509 517 to -1 , ]
: tstp2 align create [ 708 715 to 716 516 to -1 , | , ( select) tstp2 'pths 2 + ! | br


: dac ( n) $155 and io r! ; | br

( canon load)

{block 781}
( this load block compiles and configures the) | cr
( ide for the host chip on the eval board. it's also an example of configuring and customizing the ide without hacking it and breaking other uses of the ide.) | br

( this block starts by loading the serial ide in its standard form.) -canon ( forgets the mapping of canonical words like) ] @ ( and) dup ( onto the f18 so that we may interact with x86 code and ram.) | cr
( we then set) [ orgn ( so that the ide) ] compile ( will reload this block, and we set) [ sport ( to usb port a for normal ide operations on host chip.) !nam ( updates pathname for that com port.) | br


: dac ( is defined to illustrate extending the ide) | cr
[ canon load ( restores mapping of canonical words onto the f18. comment this if you wish to use the 'r-words' for all f18 operations.)

{block 782}
( flakey) # 517 ( tx osc monitor) 517 node reclaim | , 0 org +cy ]
: run = $200 @p a! @p dup [ ' r-l- ] , [ 0 ] ,
: spin = $203 0 !b @ drop .. | , | .. | .. = $206 push 1 . + pop 0 . + $3fff and | , | .. = $a0c $800 !b @ .. drop @b 2* 2* -if | , | .. | .. = $210 drop r--- spin ; ] then drop spin ; | , | ,
: -clk ( -00) = $214 dup or dup ( ...)
: ask ( lh-lh) = $215 a push right a! | , | .. over ! dup ! pop a! ; | , | ,
: drive = $219 ( 4n) !b !b for unext drop ;
: jump ( lh-lh) = $21b push push a push left a! | , | .. 8 dup 0 $20000 9 dup $800 $30000 | , | .. | .. dup dup drop drop 9 for drive drive next | , | .. pop a! pop pop ask ; | , = $22e ( ...)

{block 783}
( this node maintains a 36-bit free running) | , ( count of cycles seen on an incoming signal.) | , ( as used here this is a 10mhz clock.) | , | , ( receives requests through the) right ( port with a protocol that requires three words sent by) | , ( consecutive slots of a single instruction) | , ( word for detectable timing. the first two) | , ( words are all nops and the third is a call to one of these functions, always returning two) | , ( 16-bit words...) this is flakey because node | , 516 can write the right port when we are | , already in process of ending a read, resulting in hang and crash. | , | ,
: ask ( queries the clock, returning low and high halves in that order.)
: -clk ( zeroes the clock for time since boot.) | , | ,
: jump ( jumpstarts the resonator. returns clock) | , ( count as does) ask

{block 784}
( flakey) # 516 ( tx osc agent) 516 node 0 org +cy | , | ,
: @tfre = $200 @p @p dup .. ask ; ] . .. | * | , | ..
: ans = $203 !b !b !b @b @b .. ( lh) | , | .. = $205 over push 1 for | , | .. | .. = $208 push dup . + pop dup . + next | , | .. = $20b ( h) ! pop ( l) ! ;
: +osc = $20c @p @p dup .. jump ; ] . .. | , | .. = $20f ans ;
: -fre = $210 @p @p dup .. -clk ; ] . .. | , | .. = $213 ans ; | , = $214 reclaim

{block 785}
( this node translates ganglion transactions) | , ( into the port timing protocol used to get the attention of node 517. the ganglion messages, coming through) left ( port in) ] a, ( deliver focus) | , ( and call to one of these routines, which talk to node) # 517 ( through) [ right ( port in) ] b. | , ( each produces two 16-bit words in reply...) | , [ uses flakey version of node 517 and can crash as a result. | , | ,
: @tfre ( queries the clock, returning high and) | , ( low halves in that order for storage as a dbl number in pf memory.) | , | ,
: -fre ( zeroes the clock for coherent time since boot.) | , | ,
: +osc ( jumpstarts the resonator. returns clock) | , ( as does) @tfre.

{block 786}


{block 787}


{block 788}


{block 789}


{block 790}


{block 791}


{block 792}


{block 793}


{block 794}


{block 795}


{block 796}


{block 797}


{block 798}


{block 799}


{block 800}


{block 801}


{block 802}


{block 803}


{block 804}


{block 805}


{block 806}


{block 807}


{block 808}


{block 809}


{block 810}


{block 811}


{block 812}


{block 813}


{block 814}


{block 815}


{block 816}


{block 817}


{block 818}


{block 819}


{block 820}


{block 821}


{block 822}


{block 823}


{block 824}


{block 825}


{block 826}


{block 827}


{block 828}


{block 829}


{block 830}


{block 831}


{block 832}


{block 833}


{block 834}


{block 835}


{block 836}


{block 837}


{block 838}


{block 839}


{block 840}
( uncommitted/user code)

{block 841}
( this index page of) # 120 ( blocks is available for user code.) | br

( any code delivered in this area is provided to facilitate working with examples presented in the user's guide. it may be deleted if you no longer have use for it.) | br

( when deleting examples here, be sure to remove references in load blocks such as 200.)

{block 842}
( pwm demo) 600 node 0 org | br


: pol = $0 @b $2000 ( dw) and if | cr
( ...) = $3 ( ...) down b! @b push ex | cr

: rtn = $6 ( ...) io b! then = $8 drop | br

( cyc ie-) $1ffff and over . + -if | cr
( ...) = $c ( ...) $20000 !b pol ; | cr
( ...) = $f ] then $10000 # $0 !b pol ; | br


: upd = $12 ( xex-) drop push drop $100 | cr
( ...) = $14 pop pop ( iex-) rtn ; = $16

{block 843}
( pwm demo for host node) # 600 | br


: pol ( checks for ide inputs and calls) down | cr
( when noticed.)
: rtn ( is the return point from a) down ( call) | cr
( and is used by) [ upd ( as an re-entry point.)
: cyc ( begins the actual pwm code.)
: upd ( is the ide entry point for initial) | cr
( start or output update.)

{block 844}
( demo ide boot) empty compile serial load | br

( customize) -canon 0 fh orgn ! | cr
a-com sport ! a-bps bps ! !nam | br


: seed ( n) $13 r! $12 call upd ; | br


: run talk 0 600 hook 0 64 600 boot | indent
     upd ?ram panel 0 lit $18000 seed ;

{block 845}
( configure ide for demo testing.) | br

[compile] ***no [compile] canonical [compile] opcodes*** | cr
use the ] 'remote' [ ones | br


: seed ( loads pwm 'rate' and re-/runs cycle.)
: run ( selects node) # 600 ( target, loads the pwm) | cr
( into it and starts it with a default value.)

{block 846}
( loader template) host load loader load | , ( using default ide paths) | , ( kill boots) 0 708 hook 0 -hook | , | , ( setup application) | , | ... 600 +node 600 /ram 0 1 /stack $12 /p | , | , ( visit whole chip) 2 ship panel upd ?ram

{block 847}


{block 848}
( framer template) empty | , | , compile streamer load framer load | , ( default) entire course | , | , ( setup application) | , | ... 600 +node 600 /ram 0 1 /stack $12 /p | , | , ( make boot) frame | , | , ( feedback) .stream nores strlen leng ! | , ( erase flash) stream ers | , ( flash) stream 0 swap 18burn

{block 849}


{block 850}


{block 851}


{block 852}


{block 853}


{block 854}


{block 855}


{block 856}


{block 857}


{block 858}


{block 859}


{block 860}


{block 861}


{block 862}


{block 863}


{block 864}


{block 865}


{block 866}


{block 867}


{block 868}


{block 869}


{block 870}


{block 871}


{block 872}


{block 873}


{block 874}


{block 875}


{block 876}


{block 877}


{block 878}


{block 879}


{block 880}


{block 881}


{block 882}


{block 883}


{block 884}


{block 885}


{block 886}


{block 887}


{block 888}


{block 889}


{block 890}
( carry time) 308 node reclaim 0 org ]
: one = $0 -1 -1 0 .. drop + ;
: two = $5 -1 1 0 .. drop + ;
: thr = $a 1 0 .. - + ;
: vier = $e 0 -1 .. dup + ;
: fiv = $12 $15555 dup .. 2* + ;
: six = $15 $15555 dup - .. dup + ;
: sev = $18 -1 $15555 .. dup + ;
: ate = $1c -1 1 0 .. + + ;
: nine = $21 -1 1 0 .. . . ( .) # 0 + = $c26 + ;
: ta = $27 0 -1 1 = $c2b + ;
: tb = $2c 0 -1 . 1 = $30 + ; = $31

{block 891}


{block 892}


{block 893}


{block 894}


{block 895}


{block 896}
( 0xx-108 rx sram logging) | , | , 109 node 0 org reclaim | ,
: wire = $0 @ !b wire ; = $1 | , | , 108 node $39 org 278 load = $40 0 org ]
: run = $0 left b! right a! 1 $8000 $7fff for | , = $8 ( a-a') @ $ffff and over 0 ex! | , | .. over . + dup 2 x! next | , @b run ; = $12 1801 bin reclaim | , | , 110 node 0 org reclaim ]
: run = $0 @ if ( state) !b @ !b run ; ] then dup !b | ,
: bit ( n-n) = $4 @ -if ( drop) !b @ !b !b run ; | , | .. ] then ( drop) !b 1 . + bit ;
: run = $a @ -if drop !b dup or run ; | , | x ] then dup -2 and if drop !b run ; | , | .. ] then drop drop 1 . + run ; | , = $15 reclaim

{block 897}
# 109 ( code is a simple wire from a to b.) | , | , # 108 ( is a simple dma logger.) | , ( receives words thru a and stores into second) | , # 32 ( kword page of sram. stops when full,) | , ( restarts when pf sends it a stimulus.) | , ( addr past last word stored is left in loc) # 2 | , | , # 110 ( passes rx time node events but only counts data bits, passing that count when end packet is seen.)

{block 898}
( gpio rx pin) 217 node 0 org | , | , ( note- this code designed to work in nodes with regular gpio pins. production uses shared pin in an analog node.) | , | ,
: edge ( rise fall) = $0 push @b -if | , | ... | .. pop !b @ . drop drop drop ; | , ] then drop !b @ . pop drop drop ; | , | ,
: run = $5 edge a! @b ! 4 = $8 push a! = $809 | , | ... begin unext run ; | , | , ( -----------------) | , | ,
: init = $a left ( right) up $5555 $5d55 | , left ( right) up $5555 $5d55 | , dup dup drop drop io b! left a! run ; = $19 reclaim

{block 899}
( the ethernet rx pin node acts as a continuous manchester decoder, recovering and passing) | , ( each data bit to an adjacent buffering node) | , ( to eliminate jitter in its timing sequence.) | , ( this code automatically acquires bit sync) | , ( during frame preambles. when a link pulse is) | , ( positive only it decodes as a single '1' in) | , ( which case another node must drive the pin low momentarily to reset the schmitts; this may) | , ( produce a spurious '0'.) | , | ,
: edge ( samples pin and waits for opposite state.)
: run ( waits for the edge at the center of a bit cell, writes the value of io with the data bit in position) # 17 ( to the buffering node, then) | , ( delays long enough that the next) edge ( call) | , ( will be well centered in the first half of the next bit cell, maximizing margins for sampling and waiting. it is paramount that the delay never be too long since that means loss of bit) | , ( sync. duty cycle is always lt) # 100 ( pct.)

{block 900}
( sha-256 scheduler) 101 node 0 org +cy ]
: rdsc ( hln-hl) = $200 push a! push $4000
: dsr = $202 pop begin +* unext | cr
push drop pop a ; = $205
: rdsl ( hln-hl) = $205 push a! push dup dup or dsr ;
: dxor ( dd-d) = $207 push a! pop or push a or pop ;
: sig0 ( dd-d) = $20a dup push over push 6 rdsc | cr
over over 10 rdsc dxor pop pop 2 rdsl dxor
: sum ( dd-d) = $216 push a! pop . + push a . + pop ;
: sig1 ( dd-d) = $219 dup push over push 16 rdsc over over 1 rdsc dxor pop pop 9 rdsl dxor sum ( ;)
: !dst = $226 left a! ;
: slam ( n) = $228 push !dst begin @b ! unext
: g2x ( -hl) = $22a !dst @b dup ! @b dup ! ;
: init = $22d right b! dup or . +
: run = $230 @b @b g2x sig0 | cr
= $233 13 slam sum | cr
= $236 7 slam sig1 | cr
= $239 @b ! @b ! over ! dup ! | cr
( hasher) down a! = $23d over ! ! drop run ( -d--) ; | cr
= $23f reclaim

{block 901}
( first word moved is high order) # 14 ( bits of w0.) | br

( all that can be said for this is that it fits.) the pipelining will ] suck. ( the problem is that each each guy stops to calculate out of phase with his neighbors. so they are blocked in) | cr
( simply transferring and) [ the blockage will just ripple along the ( pipeline with) most nodes idle while a few work. ( the only good thing about it is that the duty cycle will be low so a whole lot more chips can be employed for the same power.) | br

( even if we had ram enough to keep the args and do the arithmetic after moving all but one of the words of message,) we would still have the same problem because ] the next node could not start doing its calculating ( till we completted ours.)

{block 902}
( sha-256 scheduler) 102 node 0 org +cy ]
: rdsc ( hln-hl) = $200 push a! push $4000
: dsr = $202 pop begin +* unext | cr
push drop pop a ; = $205
: rdsl ( hln-hl) = $205 push a! push dup dup or dsr ;
: dxor ( dd-d) = $207 push a! pop or push a or pop ;
: sig0 ( dd-d) = $20a dup push over push 6 rdsc | cr
over over 10 rdsc dxor pop pop 2 rdsl dxor
: sum ( dd-d) = $216 push a! pop . + push a . + pop ;
: sig1 ( dd-d) = $219 dup push over push 16 rdsc over over 1 rdsc dxor pop pop 9 rdsl dxor sum ( ;)
: !dst = $226 ( left) right a! ;
: slam ( n) = $228 push !dst begin @b ! unext
: g2x ( -hl) = $22a !dst @b dup ! @b dup ! ;
: init = $22d ( right) left b! dup or . +
: run = $230 @b @b g2x sig0 | cr
= $233 13 slam sum | cr
= $236 7 slam sig1 | cr
= $239 @b ! @b ! over ! dup ! | cr
( hasher) down a! = $23d over ! ! drop run ( -d--) ; | cr
= $23f reclaim

{block 903}
( first word moved is high order) # 14 ( bits of w0.) | br

( all that can be said for this is that it fits.) the pipelining will ] suck. ( the problem is that each each guy stops to calculate out of phase with his neighbors. so they are blocked in) | cr
( simply transferring and) [ the blockage will just ripple along the ( pipeline with) most nodes idle while a few work. ( the only good thing about it is that the duty cycle will be low so a whole lot more chips can be employed for the same power.) | br

( even if we had ram enough to keep the args and do the arithmetic after moving all but one of the words of message,) we would still have the same problem because ] the next node could not start doing its calculating ( till we completted ours.)

{block 904}
( data source) 100 node 0 org ]
: init = $0 right b! -1 push 0 dup | cr
dup dup dup dup dup dup dup dup | cr
( abc test) $26380 $1858
: hose = $a begin !b ( !b !b) unext hose ; | cr
= $b reclaim

{block 905}


{block 906}
( data sink) 201 node 0 org ]
: init = $0 ( left r-l-) $1f5 b! -1 push
: hose = $4 begin @b ( @b @b) unext hose ; | cr
= $5 reclaim

{block 907}


{block 908}
( data sink) 1 node 0 org ]
: init = $0 down b! -1 push
: hose = $4 begin @b ( @b @b) unext hose ; | cr
= $5 reclaim

{block 909}


{block 910}


{block 911}


{block 912}


{block 913}


{block 914}
( softsim setup) | br

( sha) 0 100 enter 0 1 enter | cr
1 2 code 0 2 enter 1 3 code 0 3 enter | cr
1 4 code 0 4 enter 1 5 code 0 5 enter | cr
1 6 code 0 6 enter 1 7 code 0 7 enter | cr
1 8 code 0 8 enter 1 9 code 0 9 enter | cr
1 10 code 0 10 enter 1 11 code 0 11 enter | cr
1 12 code 0 12 enter 1 13 code 0 13 enter | br

201 # 102 114 code 0 # 102 114 enter | br

$22d 101 enter | cr
102 102 code $22d 102 enter | cr
101 103 code $22d 103 enter | cr
102 104 code $22d 104 enter | cr
101 105 code $22d 105 enter | cr
102 106 code $22d 106 enter | cr
101 107 code $22d 107 enter | cr
102 108 code $22d 108 enter | cr
101 109 code $22d 109 enter | cr
102 110 code $22d 110 enter | cr
101 111 code $22d 111 enter | cr
102 112 code $22d 112 enter | cr
101 113 code $22d 113 enter | cr
0 # $3f $3e 101 # 105 break

{block 915}


{block 916}


{block 917}


{block 918}


{block 919}


{block 920}


{block 921}


{block 922}


{block 923}


{block 924}
( sha-256 scheduler) 101 node 0 org +cy ]
: rdsc ( hln-hl) = $200 push a! push $4000
: dsr = $202 pop begin +* unext | cr
push drop pop a ; = $205
: rdsl ( hln-hl) = $205 push a! push dup dup or dsr ;
: dxor ( dd-d) = $207 push a! pop or push a or pop ;
: sig0 ( dd-d) = $20a dup push over push 6 rdsc | cr
over over 10 rdsc dxor pop pop 2 rdsl dxor
: sum ( dd-d) = $216 push a! pop . + push a . + pop ;
: sig1 ( dd-d) = $219 dup push over push 16 rdsc over over 1 rdsc dxor pop pop 9 rdsl dxor sum ;
: g2x ( -hl) = $226 @b dup !b @b dup !b ;
: init = $228 ( 'r-l-) $1f5 b! dup or . +
: run = $22b @b @b g2x sig0 | cr
= $22e 13 for @b !b unext g2x sum | cr
= $233 7 for @b !b unext g2x sig1 | cr
= $238 @b !b @b !b over !b dup !b | cr
( hasher) down a! = $23c over ! ! drop ( run ;)
: hang hang ; | cr
= $23f reclaim

{block 925}
( all that can be said for this is that it fits.) the pipelining will ] suck. ( the problem is that each each guy stops to calculate out of phase with his neighbors. so they are blocked in) | cr
( simply transferring and) [ the blockage will just ripple along the ( pipeline with) most nodes idle while a few work. ( the only good thing about it is that the duty cycle will be low so a whole lot more chips can be employed for the same power.) | br

( even if we had ram enough to keep the args and do the arithmetic after moving all but one of the words of message,) we would still have the same problem because ] the next node could not start doing its calculating ( till we completted ours.) | br

( so let's see how long this puppy takes to run. looks like) # 660 ( or so) [ but also 2-port r/w addr is ] screwing up.

{block 926}


{block 927}


{block 928}


{block 929}


{block 930}
( ethernet calibration code) | , ( uses) # 117 ( for rx,) # 217 ( for wire,) | , # 317 ( for feedback and) # 417 ( to send link pulses.) | , | , ( xmtr test) 6 fh load | , ( rx pin) # 217 # 8 ( fh load) | , ( rx pin) # 117 10 fh load | , ( rx timing) # 117 # 12 ( fh load) | , ( rx timing) # 20 # 24 ( fh load) | , ( rx tst 300,400,500) # 22 ( fh load)

{block 931}
( compile initial ether tests.)

{block 932}
( ether calib ide boot) host load loader load | , | , ( custom routes) 2 fh load | , ( select) b4eth 'pths 2 + ! | , | , ( xmtr) 417 +node 417 /ram $34 /p | , ( rcv0 test) # 217 ( +node) # 217 ( /ram) # $a ( /p) | , | ... # 317 ( +node) # 317 ( /ram) # 0 ( /p) | , ( rcv1 test) 117 +node 117 /ram io /b left /a | , | ... $5555 $5d55 left up $5555 $5d55 left up | , | ... $5555 $5d55 10 /stack # $a 5 /p | , 217 +node 217 /ram 0 /p | , 317 +node 317 /ram 0 /p | , ( boot) 2 ship | . panel upd ?ram

{block 933}
( customize ide for polyforth development.) | br


: pf ( loads polyforth f18 code, nucleus in sram, and starts it up.) | br

[compile] ***no [compile] canonical [compile] opcodes*** | cr
[ use the ] 'remote' [ ones

{block 934}
( - residual paths) | , | ,
: b4eth align create [ 708 717 to 617 17 to | , 16 616 to 615 15 to 14 614 to 613 13 to | , 12 612 to 611 11 to 10 610 to 609 209 to | , 208 608 to 607 707 to 706 606 to 605 604 to | , 704 700 to 600 300 to 301 601 to 602 603 to | , 503 507 to 407 307 to 306 406 to 405 305 to | , 304 404 to 403 303 to 302 502 to -1 , | , | , exit ]
: afeth align create [ 708 701 to 700 0 to | , 1 6 to 106 101 to 201 208 to 108 109 to | , 209 210 to 110 10 to 11 17 to 117 111 to | , 211 217 to 317 301 to 401 417 to 517 501 to | , 601 617 to 717 709 to -1 ,

{block 935}
( redefine path) # 2 ( to reach whole chip except pf nodes) # 705 ( and corner and) # 207 ( and) # 108 ( and) # 109 | , | ,
: b4eth ( does this.)

{block 936}
# 417 ( send link pulses) 417 node 0 org ]
: bt/2 # 18 8 for unext ;
: five = $3 io b! $30000 | , | ... begin dup !b $10000 or ( bt/2 bt/2) | , . .. . .. . .. . .. | , . .. . .. . .. . .. | , . .. . .. . .. ( . ..) end ;
: ten = $15 io b! $30000 | , | ... begin dup !b $10000 or ( bt/2) | , . .. . .. . .. . .. end ;
: ms = $20 ( n.n) -1 . + for 41664 for unext next ;
: pulse = $27 io b! dup or dup !b $20000 $30000 | , $2 for !b . .. . .. . .. . .. next ;
: idle = $34 pulse 160 ms idle ; | , = $38 reclaim

{block 937}


{block 938}
( 217/317 rx pin) 217 node 0 org ]
: edge ( rise fall) = $0 push @b -if | , | ... | .. pop !b @ . drop drop drop ; | , ] then drop !b @ . pop drop drop ; | , | ,
: run = $5 edge a! @b ! 4 = $8 push a! = $809 | , | ... begin unext run ; | , ( -----------------) | ,
: init = $a left down $5555 $5d55 | , left down $5555 $5d55 | , dup dup drop drop io b! left a! run ; = $19 | , | , 317 node 0 org ]
: run io b! down a!
: show $25555 $35555 @ -if = $8 | , drop !b .. | , | ... . .. . .. ( . ..) !b show ; = $c | , ] then drop !b .. | , | ... ( .) . . !b show ; = $f reclaim

{block 939}
( the ethernet rx pin node acts as a continuous manchester decoder, recovering and passing) | , ( each data bit to an adjacent buffering node) | , ( to eliminate jitter in its timing sequence.) | , ( this code automatically acquires bit sync) | , ( during frame preambles. when a link pulse is) | , ( positive only it decodes as a single '1' in) | , ( which case another node must drive the pin low momentarily to reset the schmitts; this may) | , ( produce a spurious '0'.) | , | ,
: edge ( samples pin and waits for opposite state.)
: run ( waits for the edge at the center of a bit cell, writes the value of io with the data bit in position) # 17 ( to the buffering node, then) | , ( delays long enough that the next) edge ( call) | , ( will be well centered in the first half of the next bit cell, maximizing margins for sampling and waiting. it is paramount that the delay never be too long since that means loss of bit) | , ( sync. duty cycle is always lt) # 100 ( pct.)

{block 940}
( 117/217/317 rx pin) 117 node 0 org ]
: edge ( rise fall) = $0 push @b -if | , | ... | .. pop !b ! . drop . . ; | , ] then over !b ! . pop drop drop ; | , | ,
: run = $5 edge a! @b ! 4 push a! | , | ... begin unext run ; # $a ( org) | , ( -----------------) | ,
: init = $a left ( down) up $5555 $5d55 | , left ( down) up $5555 $5d55 | , dup dup drop drop io b! left a! run ; = $19 | , | , 217 node 0 org | ,
: wire io b! $5555 !b up a! down b! | ,
: pass @ !b pass ; = $9 | , | , 317 node 0 org ]
: run io b! down a!
: show $25555 $35555 @ -if = $8 | , drop !b .. . .. . .. ( . ..) !b show ; = $c | , ] then drop !b .. ( . . .) !b show ; = $e reclaim

{block 941}
( the ethernet rx pin node acts as a continuous manchester decoder, recovering and passing) | , ( each data bit to an adjacent buffering node) | , ( to eliminate jitter in its timing sequence.) | , ( this code automatically acquires bit sync) | , ( during frame preambles. when a link pulse is) | , ( positive only it decodes as a single '1' in) | , ( which case another node must drive the pin low momentarily to reset the schmitts; this may) | , ( produce a spurious '0'.) | , | ,
: edge ( samples pin and waits for opposite state.)
: run ( waits for the edge at the center of a bit cell, writes the value of io with the data bit in position) # 17 ( to the buffering node, then) | , ( delays long enough that the next) edge ( call) | , ( will be well centered in the first half of the next bit cell, maximizing margins for sampling and waiting. it is paramount that the delay never be too long since that means loss of bit) | , ( sync. duty cycle is always lt) # 100 ( pct.)

{block 942}
( 117/217/317 rx timing) 117 node 0 org ]
: edge ( hi lo) = $0 ( push) . ( @b) ! -if | , | ... | .. dup !b ( @) ! . ( drop) . ( drop) . ( drop) . ; | , ] then dup !b ( @) ! . ( pop drop drop) . . . ; | , | ,
: run = $5 edge a! @b ! 4 = $8 push a! = $809 | , | ... begin unext run ; # $a ( org) | , ( -----------------) | ,
: init = $a ( left) up ( down) io $35555 $25555 | , ( left) up ( down) io $35555 $25555 | , dup dup drop drop io b! ( left) up a! run ; = $19 | , | , 217 node 0 org | ,
: wire io b! $35555 !b up a! down b! | ,
: pass @ !b pass ; = $9 | , | , 317 node 0 org ]
: run io b! down a!
: show @ b! show ; = $5 reclaim

{block 943}
( the ethernet rx pin node acts as a continuous manchester decoder, recovering and passing) | , ( each data bit to an adjacent buffering node) | , ( to eliminate jitter in its timing sequence.) | , ( this code automatically acquires bit sync) | , ( during frame preambles. when a link pulse is) | , ( positive only it decodes as a single '1' in) | , ( which case another node must drive the pin low momentarily to reset the schmitts; this may) | , ( produce a spurious '0'.) | , | ,
: edge ( samples pin and waits for opposite state.)
: run ( waits for the edge at the center of a bit cell, writes the value of io with the data bit in position) # 17 ( to the buffering node, then) | , ( delays long enough that the next) edge ( call) | , ( will be well centered in the first half of the next bit cell, maximizing margins for sampling and waiting. it is paramount that the delay never be too long since that means loss of bit) | , ( sync. duty cycle is always lt) # 100 ( pct.)

{block 944}


{block 945}


{block 946}
( - testloop load descriptor) | , | , ( wires) | , | ... 16 +node 516 /ram right /a left /b 0 /p | , | ... 15 +node 516 /ram left /a right /b 0 /p | , | ... 14 +node 516 /ram right /a down /b 0 /p | , | ... 114 +node 516 /ram down /a up /b 0 /p | , | ... 214 +node 516 /ram up /a down /b 0 /p | , | ... 314 +node 516 /ram down /a up /b 0 /p | , | ... 414 +node 516 /ram up /a down /b 0 /p | , | ... 514 +node 516 /ram down /a right /b 0 /p | , | ... 515 +node 516 /ram right /a left /b 0 /p | , | ... 516 +node 516 /ram left /a right /b 0 /p | , | , ( pin) 517 +node 517 /ram 0 ( up) /p

{block 947}
( adds 0/1 pulse generator node) # 517 ( and jumper) | , ( wire from rx to) # 516 ( for rx verification.)

{block 948}
( 015..517 rx display) | , | , 516 node 0 org | ,
: wire = $0 @ !b wire ; = $1 | , | , 517 node 0 org ]
: run = $0 io b! right a!
: show = $4 $25555 $35555 @ ( -if) if = $8 | , drop !b .. . .. . .. ( . ..) !b show ; = $c | , ] then = $c drop .. ( .) | , !b ( ..) . ( . .) = $80e !b show ; = $f reclaim

{block 949}
( the ethernet rx pin node acts as a continuous manchester decoder, recovering and passing) | , ( each data bit to an adjacent buffering node) | , ( to eliminate jitter in its timing sequence.) | , ( this code automatically acquires bit sync) | , ( during frame preambles. when a link pulse is) | , ( positive only it decodes as a single '1' in) | , ( which case another node must drive the pin low momentarily to reset the schmitts; this may) | , ( produce a spurious '0'.) | , | ,
: edge ( samples pin and waits for opposite state.)
: run ( waits for the edge at the center of a bit cell, writes the value of io with the data bit in position) # 17 ( to the buffering node, then) | , ( delays long enough that the next) edge ( call) | , ( will be well centered in the first half of the next bit cell, maximizing margins for sampling and waiting. it is paramount that the delay never be too long since that means loss of bit) | , ( sync. duty cycle is always lt) # 100 ( pct.)

{block 950}
( rx timing) 217 node 0 org ]
: edge ( fall rise) = $0 push @b -if | , | ... | .. pop !b @ . drop drop drop ; | , ] then drop !b @ . pop drop drop ; | ,
: init = $5 left right $5555 $5d55 left right $5555 $5d55 dup dup drop drop io b! left a!
: run = $14 edge | , $5556 @b . -if $1 or then !b | , drop drop run ; = $1c | , $2f org ]
: tedge = $2f io b! | , $25555 $35555 0 # -1 over .. = $35 | , . !b -if | , | ... | .. drop !b !b ; | , ] then drop !b !b ;
: temp = $38 $25555 $35555 999 io b! push !b begin unext !b ; = $3f reclaim

{block 951}
( code used to measure the critical time) | , ( interval in) ] edge ( between sampling of signal) | , ( level and starting to wait for the next edge.) | , | , ( this is important because we must always wait for some amount of time, otherwise we will) | , ( never wait and will creep, thus losing bit) | , ( sync before long. with) # 12000 ( bit packets that can't be permitted.) | , | , ( thus the positioning of this time interval) | , ( wants to be in the center of the half bit-time under nominal conditions so that we avoid) | , ( sampling too soon or waiting too late.)

{block 952}
( test rx in) # 300 400 node 0 org | ,
: wire down b! up a! | ,
: pass @ !b pass ; = $5 | , | , 500 node 0 org ]
: run io b! down a!
: show $25555 $35555 @ -if = $8 | , drop !b .. | , | ... . .. . .. ( . ..) !b show ; = $c | , ] then drop !b .. | , | ... ( .) . . !b show ; = $f

{block 953}


{block 954}
( rx timing) # 2 217 node 0 org ]
: edge ( hi lo) = $0 ( push) dup ( @b) !b -if | , | ... | .. . !b ( @) ! . ( drop drop drop) . . . ; | , ] then . !b ( @) ! . ( pop drop drop) . . . ; | ,
: run = $5 edge | , a! @b ! 4 = $8 push a! = $809 begin unext | , run ; | , | ,
: init = $a ( left) io ( right) up $35555 $25555 | , ( left) io ( right) up $35555 $25555 | , dup dup drop drop io b! io a! run ; = $19 | , | ,
: temp = $19 $25555 $35555 999 io b! push !b begin unext !b ; = $20 reclaim

{block 955}
( this code reproduces the internal timing of) | , ( the manchester decode but depicts it by) | , ( driving an output pin high when edge would be detected and driving it low when state would) | , ( be sampled.) | , | , ( node) # 300 ( on evb s/n 0001 runs near nominal) | , ( speed and on it loop count of) # 4 ( had sample at) # 66 ( ns and wait at 80. margins are 0.90,1.18 or 0.90,1.10 excluding worst outliers from corner wafers. thus sample could be as early as 59.4 and wait as late as 94.4 corner, 88.0 slow typ wafer. deem this as good enough with) # 7 ( ns) | , ( jitter possible in channel.) | , | , ( should be solid at 1.8v and room temp across) | , ( process variation. very large temp excursions may cause data errors in atypical chips.)

{block 956}
# 417 ( orig tx osc) 417 node 0 org ]
: drive = $0 ( 4n) drop !b !b for unext ;
: sig = $3 a up a! @p = $5 ; ] .. = $6 ! a! ;
: pump = $7 ( 4n) !b ( drop) @ drop !b !b drop ( ;) sig ;
: ring = $a ( 4n) !b ( drop) @ drop drop drop ( !b) drop ( ;) sig ; | ,
: go = $d 9 for drive drive next = $12 ; | , | ... ] begin pump pump ring ring end | , | ,
: init = $18 up a! @
: xx = $1a drop | . io b! left a! | , 5 0 $20000 $800 | . 6 $800 $30000 $0 | , dup dup drop drop go ; | , = $2a reclaim

{block 957}
# 10 ( mhz ceramic resonator drive.) | , | , ( each) # 50 ( ns edge sends a return instruction) | , ( thru up port to tx pin node) # 317 ( which waits) | , ( for the edge by simply calling the port.) | , | , ( node) # 317 ( must wait faithfully for every edge) | , ( to keep this oscillator running reliably.) | , | , ( note that after starting the resonator decays in about) # 10 ( us so it is important that node) | , # 317 ( be ready to do this. therefore we let node) # 317 ( start us when it is ready to go by writing to port.)

{block 958}


{block 959}


{block 960}
( uncommitted/user code)

{block 961}
( this index page of) # 120 ( blocks is available for user code.) | br

( any code delivered in this area is provided to facilitate working with examples presented in the user's guide. it may be deleted if you no longer have use for it.) | br

( when deleting examples here, be sure to remove references in load blocks such as 200.)

{block 962}
( timing test for softsim so) 50 load ]
: test ( n) tmclr counter steps timer [ secs ] @ ;

{block 963}


{block 964}


{block 965}


{block 966}


{block 967}


{block 968}


{block 969}


{block 970}


{block 971}


{block 972}


{block 973}


{block 974}


{block 975}


{block 976}


{block 977}


{block 978}


{block 979}


{block 980}


{block 981}


{block 982}


{block 983}


{block 984}


{block 985}


{block 986}


{block 987}


{block 988}


{block 989}


{block 990}


{block 991}


{block 992}


{block 993}


{block 994}


{block 995}


{block 996}


{block 997}


{block 998}


{block 999}


{block 1000}


{block 1001}


{block 1002}


{block 1003}


{block 1004}


{block 1005}


{block 1006}


{block 1007}


{block 1008}


{block 1009}


{block 1010}


{block 1011}


{block 1012}


{block 1013}


{block 1014}


{block 1015}


{block 1016}


{block 1017}


{block 1018}


{block 1019}


{block 1020}


{block 1021}


{block 1022}


{block 1023}


{block 1024}


{block 1025}


{block 1026}


{block 1027}


{block 1028}


{block 1029}


{block 1030}


{block 1031}


{block 1032}


{block 1033}


{block 1034}


{block 1035}


{block 1036}


{block 1037}


{block 1038}


{block 1039}


{block 1040}


{block 1041}


{block 1042}


{block 1043}


{block 1044}


{block 1045}


{block 1046}


{block 1047}


{block 1048}


{block 1049}


{block 1050}


{block 1051}


{block 1052}


{block 1053}


{block 1054}


{block 1055}


{block 1056}


{block 1057}


{block 1058}


{block 1059}


{block 1060}


{block 1061}


{block 1062}


{block 1063}


{block 1064}


{block 1065}


{block 1066}


{block 1067}


{block 1068}


{block 1069}


{block 1070}


{block 1071}


{block 1072}


{block 1073}


{block 1074}


{block 1075}


{block 1076}


{block 1077}


{block 1078}


{block 1079}


{block 1080}
( compile 16-bit eforth virtual machine) | cr
reclaim | , | , ( sram cluster mk1) sram load | , | ... ( user) 108 node $39 org 278 load 1817 bin | cr
( boot flash-sram pipe) 1170 2 loads | , | , ( e4vm16 siobus wires) 1120 load | indent
     ( tx plug) 100 node 1124 load | indent
     ( rx plug) 200 node 1126 2 loads | indent
     ( 1-pin plug) 500 node 1130 load | indent
     ( 1-pin plug) 600 node 1130 load 1813 bin | , | ... ( flash plug) 704 node 1132 load | cr
( e4vm16 stack) 106 node | indent
     ( sram+) $39 org 278 load | indent
     1082 2 loads ( +buds) 1086 4 loads | cr
( e4vm16 bitsy +buds) 1094 8 loads | cr
( e4vm16 starter) 207 node ( sram+) $39 org 278 load ' -d-- ' ---u $8a00 1114 load | cr
( e4vm16 flash-sram pipe) # 1110 ( load) | cr
( erase and burn flash) 288 load | cr
( spi speedup) 290 load

{block 1081}


{block 1082}
( - e4vm16 stack 8xxx-9xxx) | cr
| -cr ( 'x@) $3c org ]
: 'au@ ( a-w) = $3c [ $0 org ]
: '1+ ( w-w) = $0 1 . + | -cr : mask ( w-w) = $2 $ffff and ;
: '2/ ( w-w) = $4 2* 2* 2/ 2/ 2/ mask ;
: popt ( p-pt) = $6 dup '1+ over x@ ;
: 'au! ( pst-p43) = $8 x!
: popst ( p-pst) = $9 popt
: pops ( pt-pst) = $a push popt pop ;
: pop43 ( pst-p43st) = $c push push popst pop pop ;
: '1- ( w-w) = $e -1 . + mask ; here ( 'x!-2) $37 org ]
: psht ( pt-p) = $37 push '1- pop over ( x! ;) = $839 ( *) [ org
: pshs ( pst-pt) = $11 push psht pop ;
: pshw ( pstw-ptw) = $13 push pshs pop ;
: 'sp@ ( pst-ptp) = $15 pshs psht dup pops ;
: 'sp! ( ptp-pst) = $18 pshs popst ; | br


: 'drop ( pst-p3s) = $1a drop pops ;
: 'dup ( pst-ptt) = $1b dup pshw ;
: 'over ( pst-pts) = $1c over pshw ;
: 'swap ( st-ts) = $1d over push push drop pop pop ;
: 'or ( pst-p3w) = $1f over - and
: 'xor ( pst-p3w) = $20 or pops ;
: 'and ( pst-p3w) = $21 and pops ;

{block 1083}
( notes-) | indent
     ( the e4th stack node must abut the memory driver to have fast bidirectional access to) | cr
( external memory.) | indent
     ( the code must not overwrite the sram user code compiled at) $39 | indent
     ] psht ( is placed so it falls into) x! | indent
     ( names beginning with ' are e4vm code words. others are internal words) | indent
     ( e4th's external data stack grows down) | cr
( with pre-dec writes and post-inc reads.) | indent
     ( the stack-node's stack keeps the e4th) | cr
[ stack pointer ( and cached) s ( and) t | indent
     ( 16-bit words are) 00.nnnn.nnnn.nnnn.nnnn

{block 1084}
( --- more stack)
: 'um+ ( uu-uc) = $22 + $10000 over and if or 1 ;
: 'nop = $27 then ;
: 'zlt ( n-f) = $28 2* 2* -if dup or ..
: 'inv ( w-w) = $2a - mask ; = $2b ] then dup or ; | br

= $2c ( must be at or before) $32 org | cr
( bitsy left slot2 call reaches) # $30 ( -) # $37
: c.s* ( code0* prix3) = $32 2* -if | cr
( code01* prix4) = $33 2* -if -d-- ; ] then ---u ; | cr
( code00* prix4) = $36 ] then drop push ; | br

= $37 exit ( started by ide)
: start $ffe0 $0 dup ( sp.s.t) | indent
     ( memory) right b! ( bitsy) --l- ; = $3d

{block 1085}
( notes-) | indent
     ( the initial sp is reset by) cold | indent
     ( code must fit before) ] psht

{block 1086}
( -- stack up bud axxx) 206 node $20 org ]
: start @p b! ahead [ ' ---u , ]
: xqt = $22 @b push ex
: cmd = $23 then @p !b ( ...) xqt ; ( /) ] drop !p .. ( /) | br

= $25

{block 1087}


{block 1088}


{block 1089}


{block 1090}
( -- stack down bud bxxx) 6 node $20 org ]
: start @p b! ahead [ ' -d-- , ]
: xqt = $22 @b push ex
: cmd = $23 then @p !b ( ...) xqt ; ( /) ] drop !p .. ( /) | br


: .ex! ( pst-p54) = $25 @p @p @p ( reversed!) | indent
     ( /) pops ; ( ') ] ex! ( ') pop43 ( /) !b !b !b ;
: .ex@ ( pst-p3w) = $2a @p @p .. ( reversed!) | indent
     ( /) pops ; ( ') ] ex@ ( /) !b !b ;
: .cx? ( pst-p5f) = $2e @p @p @p ( reversed!) | indent
     ( /) pops ; ( ') ] cx? ( ') pop43 ( /) !b !b !b ; | br


: '+ ( pst-p3n) = $33 @p @p .. ( reversed!) | indent
     ( /) pops ; ( ') ] + mask ( /) !b !b ;
: '2* ( w-w) = $37 @p !b ; ( /) ] 2* mask ; ( /) = $39

{block 1091}


{block 1092}


{block 1093}


{block 1094}
( - e4vm16 bitsy cxxx) 105 node $0 org ]
: inc ( a-a) = $0 1 . + ;
: bpshw ( w-) = $2 @p !b !b ; ( /) ] @p pshw ( /)
: 'rp@ ( pri-pri) = $4 push over bpshw pop ;
: 'else | -cr : bx@ ( a-w) = $6 @p !b !b . ( /) @p x@ ( /)
: gett ( -w) @p !b @b ; ( /) ] !p .. ( /)
: 'rfrom ( pri-pri) = $a push bpshw
: popr ( p.i-pri) = $b inc
: getr ( p.i-pri) = $c dup bx@ pop ;
: 'exit ( pri-pri) = $e drop push popr ;
: bpops ( -w) = $f @p !b @b ; ( /) ] !p pops ( /)
: bx! ( wa-) = $11 @p !b !b . ( /) @p push @p . ( /) | indent
     !b @p !b ; ( /) ] pop x! ( /)
: pshr ( aw-a) = $15 over bx!
: dec ( a-a) = $16 -1 . + ;
: 'tor ( pri-pri) = $18 push pshr bpops pop ;
: 'rp! ( pri-pri) = $1b push pshr bpops getr ;
: 'if ( pri-pri) = $1e bpops if drop inc ; | indent
     ] then drop bx@ ;
: 'con ( pri-pri) = $22 bx@
: 'var ( pri-pri) = $23 dup bpshw 'exit ; = $25

{block 1095}
( notes-) | indent
     ( the bitsy node keeps the return-stack) | cr
( pointer, top-of-return-stack) ] r ( and the interpreter pointer on its stack.) | indent
     ( memory access gets done only through the stack node.)

{block 1096}
( --- more bitsy) | cr
= $25 ( must be at or before) $28 org | indent
     ] begin drop ;
: 'exe ( pri-pri) = $29 bpops
: ?exe ( pri?-pri) = $2a until
: xxt ( prix-pri) = $2b dup 2* 2* -if | cr
( code prix2) = $2d 2* -if | cr
( code1* prix3) = $2e 2* -if | cr
( code11* prix4) = $2f 2* -if -d-- ; ] then ---u ; | cr
( code101 prix4) = $32 ] then 2* -if r--- ; | cr
( code100 prix5) = $34 ] then drop push ; | cr
( code0* prix3) = $35 ] then ( slot2 port call!) | indent
     @p !b push . ( /) @p @p c.s* ( /) !b pop !b ; | cr
( list prix2) = $38 ] then drop push push pshr | indent
     pop pop 2* ;
: step ( pri-pri) = $3b dup bx@ push inc pop xxt ;
: bitsy ( pri) = $3e step bitsy ; # $3e ( in block) # 1100 | br

= $40 exit ( started by ide)
: start $fff0 $5 dup ( rp.r.ip) left ( stack) b! | indent
     right ( terminal) a! bitsy ; = $47

{block 1097}
( notes-) | indent
     ( the bit-threaded code technique confines execution to the) ] bitsy ( loop and a small number of code subroutines. it uses one or more bits of the execution token to select the class-) | indent
     [ 00.10**.xxaa.aaaa.aaaa ( code.s-xt's) | indent
     00.11**.xxaa.aaaa.aaaa ( code.b-xt's) | indent
     00.0aaa.aaaa.aaaa.aaaa ( list-xt) | cr
( -and process the token. code tokens are called while list tokens are interpreted by pushing the current) ip ( address onto the return stack and continuing at 2*xt.) | indent
     ( the) ide ( can single-step the bitsy node by calling) ] step ( instead of executing) bitsy.

{block 1098}
( -- bitsy right bud dxxx) 104 node host ]
: 'lu $165 lit ; target $20 org ]
: start @p b! .. [ ' r--- , ] 'lu a! ahead
: xqt = $24 @b push ex
: cmd = $25 then @p !b ( ...) xqt ; ( /) ] drop !p .. ( /) | br


: message ( nw-w) = $27 @p ! - . ( /) @p over @p ; ( /) | cr
] over ! ! @ ( ...) drop @ or drop @ ;
: n@ ( n-w) = $2c $3ffff message $ffff and ;
: n! ( nw-) = $30 message drop ; | br


: br!p ( i-) = $32 @p !b !b ; ( /) ] bpops .. ( /)
: brpops = $34 @p br!p ; ( /) ] !p .. ( /)
: pn!; ( n-) @p br!p ( /) !p ; ( /) ] @b n! ;
: n@p; ( n-) = $39 n@ @p !b !b ; ( /) ] @p bpshw ; ( /)
: .n@ = $3c brpops @b n@p; ;
: .n! = $3e brpops @b pn!; ; | br


: .rx = $40 200 n@p; ; | -cr : .io@ = $42 100 n@p; ;
: .tx = $44 100 pn!; ; | -cr : .io! = $46 200 pn!; ; | cr
= $48 ( must be at or before) # $60

{block 1099}


{block 1100}


{block 1101}


{block 1102}
( -- bitsy up bud exxx) 205 node $20 org ]
: start @p b! ahead [ ' ---u , ]
: xqt = $22 @b push ex
: cmd = $23 then @p !b ( ...) xqt ; ( /) ] drop !p .. ( /) | br

= $25

{block 1103}


{block 1104}


{block 1105}


{block 1106}
( -- bitsy down bud fxxx) 5 node $20 org ]
: start @p b! ahead [ ' -d-- , ]
: xqt = $22 @b push ex
: cmd = $23 then @p !b ( ...) xqt ; ( /) ] drop !p .. ( /) | br


: 'next ( pri-pri) = $25 @p !b @b ( /) push !p .. ( /) | cr
if @p !b !b @p ( /) @p dec ( ') pop bx@ ; ( /) ] !b ; | cr
] then drop @p @p @p ( reversed!) | indent
     ( /) pop inc ; ( ') ] dup bx@ ( ') inc ( /) !b !b !b ;
: '@exe ( pri-pri) = $31 @p @p @p . ( reversed!) | indent
     ( /) ?exe ; ( ') ] bx@ ( ') bpops ( /) !b !b !b ;
: 'r@ ( pri-pri) = $36 @p !b ; ( /) ] over bpshw ; ( /)
: 'lit ( pri-pri) = $38 @p @p @p ( reversed!) | indent
     ( /) inc ; ( ') ] bpshw ( ') dup bx@ ( /) !b !b !b ; = $3d

{block 1107}


{block 1108}


{block 1109}


{block 1110}
( - flash to sram pipe) host ]
: head | -cr : pipe [ 1112 ] load ; target | cr
( -------- --in-- --out- ----) | cr
307 node ' ---u ' -d-- pipe | cr
407 node ' -d-- ' ---u pipe | cr
507 node ' ---u ' -d-- pipe | cr
607 node ' r--- ' ---u pipe | cr
606 node ' --l- ' r--- pipe | cr
605 node ' -d-- ' --l- head | br

705 node ( interface) 1116 load

{block 1111}


{block 1112}
( -- head/pipe nodes take two parameters!) | cr
$20 org ( programmed with abandon)
: start ( init) leap warm ;
: init = $22 then @p b! .. ( out) [ , ] @p a! ; ( in) , ]
: prime ( i-i) = $26 dup !p ; ( install /* */)
: pump = $27 ( /*) begin @ !b unext ; ( */)
: run ( in) = $28 init | indent
     @p !b over . ( /) @p prime ( /) | indent
     !b @p !b dup ( /) @p run ( /) | indent
     !b push pump ; | br

( used in the 'head' node)
: hf2s ( n) = $2f @p prime ( /) begin @ !b unext ; ( /) | cr
] over run ;
: hs2f ( n) = $32 @p prime ( /) begin @b ! unext ; ( /) | cr
] over run ; = $35

{block 1113}
( notes-) | cr
( this is a bi-directional port pump! it assumes control comes from the 'head' and passes the it to the b-reg 'tail' of the pipe. a-reg the registers are set each time it is used, so the pipe may be crossed by other 'courteous' users. at this point only the count is passed--the tail has a fixed address to read to or write from.)

{block 1114}
( -- tail / starter node takes three parameters!) $0 org ( programmed with abandon)
: tf2s = $0 ( e4base) 0 | indent
     begin @ over x! 1 . + next warm ;
: ts2f = $8 ( e4base) 0 | indent
     begin dup x@ ! 1 . + next warm ;
: xm! ( m-) = $f dup dup or dup - mk! ; = $11 | br

$20 org ]
: start = $20 @p @p b! @p ( mask) [ , ( out) , ( in) , | indent
     ] a! xm! warm ;
: prime ( i-i) = $26 ; ( dummy) ] ;
: run ( in) = $28 push @p or ( /*) begin @b ! unext ; ( */) ] if tf2s ; ] then ts2f ; = $2d

{block 1115}
( notes-) | indent
     ] xm! [ mask ( sets which neighbor nodes get access to memory.) # $8000 ( is 106,) # $800 ( is 108,) # $200 ( is 207,) # $8a00 ( is all three.) use carefully!

{block 1116}
( -- eforth flash interface) $0 org ]
: 2cmd ( dw-d) select ( +2r) | -cr : +cmd ( dw-d) 8obits ( +4r)
: cmd ( db-d) select | -cr : !8 ( db-d) 8obits drop ;
: reading ( dh-d) = $5 io b! over . ( read) $c00 cmd ( +5r)
: !24h ( dhd-d) = $9 drop 8obits
: !16 ( dw-d) = $a 8obits !8 ;
: @16 ( d-dw) = $c 15 dup push dup or ( 'ibits) [ $db ] end
: set ( ndo-n) = $f down a! ! drop dup ! ;
: f2s ( dndh-d) = $12 reading ( +6r) @p set ( /) @p hf2s ( /)
: readn ( dn-d) = $15 for @16 ( +4r) ! next ;
: start ( dx-dx) = $19 drop ( n-1) over 512 f2s ( +7r)
: restart ( d-dx) = $1d ( resume) reading dup spi-exec ;
: deselect ( dx-dx) = $20 io b! -++ half warm ; | cr
= $25 exit ]
: +wr ( d-d wren+wrsr) $1804 2cmd ( 0+ebsy) $1c0 +cmd ;
: er32k ( dh-dd) = $29 over +wr ( +6r) | indent
     ( wren+ers32) $1948 2cmd !24h dup select ;
: writing ( dh-d) = $2e over +wr ( +6r) | indent
     ( wren+aaip) $1ab4 2cmd !24h ;
: s2f ( dndh-d) = $32 writing ( +7r) @p set ( /) @p hs2f ( /)
: writn ( dn-d) = $35 push ahead begin [ swap | indent
     ( aaip) ] $2b400 cmd then @ !16 ( +5r) | indent
     ( wait) dup select = $3a begin drop @b -until | cr
= $3b drop next ( wrdi+dbsy) $1200 2cmd ; = $3e

{block 1117}
( notes-) | indent
     ( assumes that during booting the delay value is on the top of the data stack and is preserved during all flash accesses.) | indent
     ( also assumes b contains io.)

{block 1118}


{block 1119}


{block 1120}
( - siobus16 wire nodes) host ]
: wire [ 1122 ] load ; target | cr
( ------- plug -dest- --in-- --out- ----) | cr
204 node 999 ' r--- ' -d-- ' ---u wire | cr
304 node 999 ' r--- ' ---u ' -d-- wire | cr
404 node 999 ' r--- ' -d-- ' ---u wire | cr
504 node 999 ' r--- ' ---u ' -d-- wire | cr
604 node 704 ' -d-- ' --l- ' ---u wire ( *) | cr
603 node 999 ' -d-- ' r--- ' --l- wire | cr
602 node 999 ' -d-- ' --l- ' r--- wire | cr
601 node 600 ' r--- ' ---u ' --l- wire ( *) | cr
501 node 500 ' r--- ' -d-- ' ---u wire ( *) | cr
401 node 999 ' r--- ' ---u ' -d-- wire | cr
301 node 999 ' r--- ' -d-- ' ---u wire | cr
201 node 200 ' r--- ' ---u ' -d-- wire ( *) | cr
101 node 100 ' r--- ' --l- ' ---u wire ( *) | cr
102 node 999 ' r--- ' r--- ' --l- wire | cr
103 node 999 ' r--- ' --l- ' r--- wire

{block 1121}
( notes-) | cr
iobus ( nodes have) # 4 ( values defined when booted-) ] in-port ( and) destination ( are kept on the stack,) dest-port ( is put in a, and) out-port ( into b. an) [ iobus ( node with a) ] destination ( of) [ 999 ( only) | cr
( passes messages from its) ] in-port ( to) out-port. ( its) dest-port ( is unused. otherwise they are) | cr
( the node-number and port of a node with pins.) | cr
[ iobus ( messages consist of three words;) | indent
     ( /) ] @p over @p ; ( /) [compile] destination ( /) [compile] data ( /) | br

[compile] destination ( is the node-number of a node with code to handle) [compile] data | br

[compile] data ( is) 0 ( for reads and the 18-bit inverse of a) 16-bit value ( for writes.) | br

( eforth originates all messages. they travel around the loop until their) [compile] destination ( matches an) iobus ( node's or they return to eforth. at a matching node) [compile] data ( is written and the) | cr
( reply read and returned to eforth.)

{block 1122}
( -- generic siobus wire) $30 org | br


: start ( takes four parameters!) | indent
     @p b! @p .. ( out-port) [ , ( in-port) , | indent
     ] @p a! @p .. ( dest-port) [ , ( dest-node) , ]
: wait ( id) = $36 over push ex ( ... @p over @p ;)
: test ( idndw) = $37 push over or if
: pass ( idnx.w) = $39 | indent
     @p !b drop .. ( /) @p over @p ; ( /) | indent
     ] !b pop !b wait ;
: mine ( idn0.w) = $3d then pop ! @ push pass ; = $3f

{block 1123}


{block 1124}
( -- tx plug node) host ]
: tx0 ( dumb) $25555 ( maxim) # $35555 lit ;
: tx1 ( dumb) $35555 ( maxim) # $25555 lit ;
: 'ru [ $1c5 ] lit ; | -cr : 115k [ 2350 ] lit ; | cr
target $30 org ]
: !bit ( im-i) = $30 over and | indent
     if tx0 !b drop ; ] then tx1 !b drop ;
: putchar ( di-dx) = $35 $ff or 2* .. | cr
( 1-start, 8-data, 1-stop bit) 9 for = $39 | indent
     1 !bit 2/ over for . unext next ; = $3e | br

= $3e $20 org ( programmed with abandon)
: start io b! ( space) tx0 !b 'ru a! ( bit delay) 115k
: wait ( *d) = $26 @ ( ...) if | cr
( dly *d) [ ' wait ] -until | cr
( n!) = $28 ( *di) - putchar ! wait ; | cr
( n@) = $2a ( *d0) ] then drop dup ! wait ; = $2c

{block 1125}
( notes-) | indent
     tx ( is inverted for compatibility with the boot node conventions, i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo.) | br


: putchar ( takes a clean inverted octet and) | cr
( transmits it low bit first via p17.) | br


: wait ( suspends while waiting for an inverted) | cr
( character or a new delay value. the message) | cr
( protocol guarentees that there won't be a port conflict.)

{block 1126}
( -- rx plug node) $0 org ]
: @bit ( cm-c) @b - over - and push and pop or ;
: getchar ( dx-di) = $3 over 2/ for . unext ( 1/2 bit) 8 for ( 1-start, 8-data, 1-stop bits) | indent
     $1ffff @bit 2/ over for . unext | cr
next 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ $ff and - ; | br


: baud ( n-ddd) = $11 if dup dup ; ] then - push | cr
= $814 begin @b . -until ( at start-bit of space) | , = $15 begin @b - -until ( at 1-bit) | cr
= $16 begin @b . zif then . -until ( at 0-bits) | cr
= $18 begin @b - zif then . -until ( stop-bit) | cr
= $1a pop - ( n) dup 2/ . + ( 1.5n) dup dup ; = $1d

{block 1127}
( notes-) | indent
     rx ( is inverted for compatibility with the boot node conventions, i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. received characters may have one stop bit.) | br


: getchar ( called after seeing leading edge of start bit. returns clean inverted character. must be called before start bit begins!) | br


: baud ( space is 1...1'0010.0000'0) | indent
     ( stop bits ------' .hex..20. '--- start) | br


: idle

{block 1128}
( --- more rx) | br

= $1d $20 org ( programmed with 2-stack abandon)
: start ( est 115k delay) 2350 | indent
     ( tri-state pin17) io b! $5555 !b | indent
     ( 2-char empty buffer) 0 dup push
: pwait ( *dl.p*) = $27 push
: wait ( *d.lp*) = $28 ( io-mask) $28000 dup | indent
     begin drop @b over and until -if | cr
( pin *dm-.lp*) drop getchar pwait ; | cr
( msg *dm+.lp*) ] then drop drop right a! @ -if | cr
( n! *d-.lp*) = $32 - baud ! up a! ! wait ; | cr
( n@ *d0.lp*) = $36 ] then pop if | cr
( *d0l.p*) pop if # 2 ( chars in buffer) | indent
     ( *d0lp.*) ! over push push drop wait ; | indent
     ( *d0l0.*) ] then push ( 0/1 char in buffer) | cr
( *d0l.p*) then ! pwait ; = $3d

{block 1129}


{block 1130}
( -- 1-pin plug node) $20 org ]
: start right a! io b! ( p17 hi-imp) $5555 dup !b
: cmd ( m) = $26 @ ( ...) -if | cr
( n!) = $27 ( mw) 1 or 7 for 2* 2* unext | indent
     over over or !b ! cmd ; | cr
( n@) = $2f ( m0) ] then @b -if drop - ! cmd ; | indent
     ] then drop ! cmd ; = $34

{block 1131}
( notes-) | cr
( currently plugged into nodes) # 500 ( and) # 600 ( .) | cr
0 ] n! ( drives the pin lo.) | cr
[ 1 ] n! ( drives the pin hi.) | cr
[ 2 ] n! ( tri-states the pin.) | cr
[ 3 ] n! ( attaches a weak pull-down to the pin.) | cr
n@ ( samples the pin, returning) | indent
     [ -1 ( when hi,) 0 ( when lo.) | br

( high level eforth code toggles at) # 250 ( khz!)

{block 1132}
( -- dummy flash controller plug) $0 org ]
: !x @p drop !p ; | -cr : x 0 ;
: xfers dup !x ; $20 org ]
: start down a!
: cmd = $22 @ ( ...) -if | cr
( n!) = $23 ( w) - xfers ! cmd ; | cr
( n@) = $25 # 0 ] then drop x ! cmd ;

{block 1133}


{block 1134}


{block 1135}


{block 1136}


{block 1137}


{block 1138}


{block 1139}


{block 1140}
( eforth ide) host load | , | ,
: hoot ( pn) dup
: book ( pnb) push hook 0 64 pop boot pause ;
: 'lu [ $165 ] ; | *
: 'cold [ $5 ] ; ( eforth cold-start)
: e4base ( -a) [ $0 # $8000 ] ; ( eforth location in sram)
: 'bitsy [ $3e ] ; | *
: 'rp [ $fff0 ] ; | *
: 'sp [ $ffe0 ] ; | , | , ( tools) 1142 4 loads | , | , ( build chip) 1160 load talk e4

{block 1141}
( customize ide for eforth development.) | br


: hoot ( combines) [ hook ( and) boot ]
: e4 ( loads f18 virtual machine code, puts) | cr
( threaded-code image in sram, and starts it.) | cr
[ note--initial 'space' character needed from | cr
the terminal to determine the baud rate. | br

[compile] ***no [compile] canonical [compile] opcodes*** | cr
use the ] 'remote' [ ones for both | cr
compiled and interpreted scripts.

{block 1142}
( - ide build paths) | br


: route ( p) pop b-a swap
: !path ( ap) dup -hook 'pths + ! panel pause ; | br


: srampath [ 1 ] align route [ 708 , 608 , | indent
     508 , 408 , 308 , 208 , 108 , 107 , | indent
     7 , 8 , 9 , -1 , ( srampath) | br


: e4path [ 0 ] align route [ 708 , 707 , # 706 ( ,) | indent
     # 705 ( ,) # 605 ( ,) # 606 ( ,) 607 , 507 , 407 , | indent
     307 , 207 , 206 , 205 , 105 , 106 , | indent
     6 , 5 , 4 , 104 , 103 , 102 , 101 , | indent
     100 , 200 , 201 , 301 , 401 , 501 , | indent
     500 , 600 , 601 , 602 , 603 , 703 , | indent
     704 , 604 , 504 , 404 , 304 , 204 , | indent
     -1 , ( e4path) | br


: flpath [ 0 ] align route [ 708 , 707 , 706 , | indent
     705 , -1 ,

{block 1143}


{block 1144}
( - read 16-bit eforth.bin file) | cr
:var ft | -cr : e4max ( -h) [ 16384 ] ; :var e4siz [0x133e]
: a-b ( a-b) 2* 2* ; | -cr : b-a ( b-a) [ 3 ] + 2/ 2/ ;
: create ( -a) pop b-a ;
: string pop ; | -cr : h-b 2* ; | -cr : b-h [ 1 ] + 2/ ;
: fbuf ( -b) [ nnc 2 * $8000 + block a-b ] ; | br


: +e4 [ 0 fnam b-a ] r/w fopen if [ ft ] ! ; | cr
] then drop abort ;
: -e4 [ ft ] @ [ 0 ] + if fclose 0 then [ ft ] ! ;
: !e4 +e4 if fbuf [ e4max ] h-b [ ft ] @ frd | indent
     b-h [ e4siz ] ! -e4 then ; | br

named ( ef/eforth.bin) !e4 ]
: n-1 [ e4siz @ -1 + ] ; | br



{block 1145}


{block 1146}
( - ide access sram16 from nodes) # 108 ( and) # 207
: n108 srampath 1 108 hook panel ?ram ;
: n207 e4path 0 207 hook panel ?ram ;
: get ( -w) upd [ stak ] @ rdrop ;
: put2 ( nn-) swap lit' lit' ;
: put4 ( nnnn-) push push put2 pop pop put2 ; | br


: xm! ( m-) lit' ( xm!) [ $37 ] call ;
: x! ( wa-) put2 ( x!) [ $39 ] call ;
: x@ ( a-w) lit' ( x@) [ $3c ] call get ;
: ex! ( wap-) push put2 pop lit' ( ex!) [ $3a ] call ;
: ex@ ( ap-w) put2 ( ex@) [ $3d ] call get ;
: cx? ( wapw-f) put4 ( cx?) [ $3e ] call get ; | br


: dmp ( ap-...) 7 for push dup i ex@ | indent
     swap [ 1 ] + pop -next drop drop ;
: fil ( wapn-) for push over over i ex! | indent
     [ 1 ] u+ [ 1 ] + pop -next drop drop drop ; | br


: !e4th [ fbuf ] e4base [ n-1 ] for | indent
     over 2@ swab over x! [ 2 ] u+ [ 1 ] + | cr
-next drop drop ;

{block 1147}
( notes) | indent
     ( assumes the ide is hooked to one of the sram user nodes.) | indent
    

{block 1148}
( - ide access term16 from) # 104 ( , flash from) # 706
: n104 e4path 0 104 hook panel ?ram ;
: io! ( w) 200
: n! ( wn) lit' lit' ( n!) $30 call upd ;
: tx ( w) 100 n! ;
: io@ ( -w) 100
: n@ ( n-w) lit' ( n@) $2c call get ;
: rx ( -w) 200 n@ ;
: key ( -w) begin rx if $ffff or ; ] then drop end
: emit ( w-) $ffff or tx ; exit | br


: n706 flpath 0 706 hoot panel ?ram ;
: ffo ( foc) [ $20 ] call ; | -cr : blk ( n-) [ $200 ] * lit ;
: len ( len) [ $23 ] call ; | -cr : f2s ( dnl) [ $32 ] call ;
: des ( des) [ $34 ] call ; | -cr : don ( don) [ $3c ] call ;
: e32 ( e32) [ $36 ] call ; | -cr : s2f ( upl) [ $38 ] call ;
: burn ( k) foc blk n108 x@ -1 + | indent
     $0 path lit s2f don ;
: try ( k) foc blk len f2s don ;

{block 1149}


{block 1150}


{block 1151}


{block 1152}


{block 1153}


{block 1154}


{block 1155}


{block 1156}


{block 1157}


{block 1158}


{block 1159}


{block 1160}
( eforth chip builder) | br


: hooked panel pause 2 708 hook pause 2 -hook ;
: clean unfoc 2 -hook 1 -hook 0 -hook ;
: e4sram [ 1162 ] load ;
: e4sio [ 1164 ] load ;
: e4vm [ 1166 ] load ;
: e4boot e4sram e4sio e4vm clean ;
: e4bin e4sram !e4th ;
: e4 e4bin e4sio e4vm clean ;

{block 1161}


{block 1162}
( - build sram16 using) srampath | br

( address-bus) 1 9 hook 0 64 1617 boot $20 call | , ( control-pins) 1 8 hook 0 64 1616 boot $20 call | , ( data-bus) 1 7 hook 0 64 1615 boot $20 call | , ( interface) 1 107 hook 0 64 1614 boot | , | ... down lit rb! | , | ... ( 108+207 mask) $8a00 lit ( re) $17 call | cr
( user) 1 108 hook 0 64 1817 boot

{block 1163}


{block 1164}
( - build siobus wires and plugs using) e4path ]
: wire ( n) dup | *
: wbin ( bn) 0 swap hook push | , | ... $30 16 pop boot pause $30 call ;
: plug ( n) dup | *
: pbin ( bn) 0 swap hook push | , | ... $0 64 pop boot pause $20 call ; | , | , 204 wire 304 wire 404 wire 504 wire 604 wire | , ( flash) 704 plug 603 wire 602 wire 601 wire | , ( 1-pin) 1813 600 pbin ( plug 1-pin) 500 plug | , 501 wire 401 wire 301 wire 201 wire | , ( rx) 200 plug ( tx) 100 plug 101 wire 102 wire | , 103 wire exit ( for eforth) | , | , ( testing serial bus from bitsy right bud) | , | ... 104 plug 'lu lit ra!

{block 1165}


{block 1166}
( - build e4vm16 nodes using) e4path ]
: pipe ( n) dup node push $20 32 pop boot | indent
     $20 call ; | br

( bitsy right bud) foc 104 plug | cr
( bitsy down bud) 5 plug | cr
( stack down bud) 6 plug | br

( stack) 0 106 hoot right lit rb! | indent
     'sp lit ( s) 0 lit ( t) 0 lit | indent
     left call | br

( bitsy) 0 105 hoot left lit rb! | indent
     'rp lit ( r) 0 lit ( ip) 'cold lit | indent
     'bitsy call unfoc | br

( bitsy up bud) 205 plug | cr
( stack up bud) 206 plug | br

( starter/tail node) 207 plug exit | br

( pipeline) 307 pipe 407 pipe 507 pipe | indent
     607 pipe 606 pipe ( head) 605 pipe

{block 1167}


{block 1168}


{block 1169}


{block 1170}
( - sram loader nodes) | , | , ( wires) 605 node 0 org ]
: wire ( b! a!) @ dup !b for @ !b unext warm ; | , = $4 1815 bin | , | , ( sram loader node) # 208 | , 208 node 0 org ] ahead
: !sram = $1 ( an) @p !b !b .. ( /) @p @p .. ( /) | , !b @p !b ; ( /) ] x! ( /)
: start = $5 then down a! up b! | , 0 dup @ dup push !sram begin | , 1 . + dup @ !sram next warm ; | , = $11 1816 bin

{block 1171}
( minimal version of plumbing for sram boot from flash. wires are compiled only once and are) | , ( initialized with source port in a and dest) | , ( port in b.) | , | , ( message consists of word count n-1 followed by n words to be passed along.)

{block 1172}
( - spi flash) # 8 ( bits) 705 node 0 org host ]
: resume nnc 2 * $8000 + block @ $fffff and | indent
     18 8 */ 4 * lit ; target ]
: wait ( dw-dw) = $0 select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) = $4 select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) = $9 io b! ( fast) 5 ;
: fet ( ah al-d) = $c push push set ( read) $c00 cmd pop !8 pop 8obits !8 ;
: 16ibits ( d-db) = $12 dup 15 for | cr
rbit ibit - next $ffff and ;
: start = $19 down a! 0 $20000 fet | cr
16ibits dup ! for 16ibits ! next | indent
     resume fet 18ibits $1e000 . + - -if
: done io b! 20 20 -++ half warm ; ] then | cr
5 resume push spicmd spi-boot ; | cr
= $34 1814 bin

{block 1173}

: start ( 1st word read is count in words)

{block 1174}
( load eforth kernel) | ,
: /nwire ( in out) /b /a 0 4 [ 1815 ] /part 0 /p ; | , | , 705 +node 1814 /ram $19 /p | , 605 +node down left /nwire | , 606 +node left right /nwire | , 607 +node right left /nwire | , 608 +node left up /nwire | , 508 +node up down /nwire | , 408 +node down up /nwire | , 308 +node up down /nwire | , 208 +node 1816 /ram 0 /p | , 108 +node 1817 /ram left /b

{block 1175}


{block 1176}


{block 1177}


{block 1178}


{block 1179}


{block 1180}
( build eforth bootstream) | , | , ( speedup) | , | ... $0 0 3 1608 /root | , | , ( default) entire course | cr
( sram driver) sram 2 + load | , ( flash to sram) 1174 load | , frame adjust ( resume point) | , | , fresh ( residual) sram 4 + load s705 course | , | ... ( siobus and virtual machine) 1182 load | , | ... ( flash-sram pipe) # 1184 ( load) | , | ... ( retain asynch boot) 708 +node $aa /p | , frame

{block 1181}


{block 1182}
( - build siobus and virtual machine bootstream)
: wire ( n) dup +node push $30 16 pop /part $30 /p ;
: plug ( n) dup | *
: pbin ( bn) +node /ram $20 /p ; | br

103 wire 102 wire 101 wire | indent
     ( tx) 100 plug ( rx) 200 plug | cr
201 wire 301 wire 401 wire 501 wire | indent
     ( 1-pin) 500 plug ( 1-pin) 1813 600 pbin ( plug) | cr
601 wire 602 wire 603 wire | indent
     ( flash) 704 plug | cr
604 wire 504 wire 404 wire 304 wire | cr
204 wire | br

( bitsy) 105 +node 105 /ram | indent
     ( rp) $fff0 ( r) 0 ( ip 'cold) $5 3 /stack | indent
     left /b right /a ( 'bitsy) $3e /p | indent
     ( buds) 205 plug 104 plug 5 plug | br

( stack) 106 +node 106 /ram | indent
     ( sp) $ffe0 ( s) 0 ( t) 0 3 /stack | indent
     right /b left /p | indent
     ( buds) 206 plug 6 plug | br

( starter/tail) 207 plug

{block 1183}


{block 1184}
( - build flash-sram pipe bootstream)
: pipe ( n) dup node push $20 32 pop boot $20 /p ; | br

( head) 605 pipe | cr
( pipeline) 606 pipe 607 pipe | indent
     507 pipe 407 pipe 307 pipe | cr


{block 1185}


{block 1186}


{block 1187}


{block 1188}


{block 1189}


{block 1190}
( burn 18-bit eforth bootstream into flash) | , ( 1st pass) empty compile streamer load | , ( framer) framer load ( the stream) 1180 load | , | , ( 2nd pass) empty compile streamer load | , ( framer) framer load ( the stream) 1180 load | , | , .stream ( display stream length) strlen leng ! | , ( write stream into flash) | , | ... ( source cf-word-addr) stream | , | ... ( dest flash-byte-addr) 0 | , | ... ( count 18-bit-words) swap ( flasher) 18burn | , | , ( burn nucleus) 1194 load

{block 1191}


{block 1192}


{block 1193}


{block 1194}
( burn 16-bit eforth.bin file into flash) | , empty compile streamer load | , # 1190 ( loaded !) .nucleus nores | , ( read eforth.bin) 1144 load | , fbuf source ! n-1 len ! | , ( display image length) len @ 8 18 */ leng ! | , | , stream $8000 swap burn

{block 1195}


{block 1196}


{block 1197}


{block 1198}
( eforth index and listing) | br

index load named ( eforth.txt) 1080 1200 run | br

html load named ( eforth.html) 1080 1200 run | br

exit

{block 1199}


{block 1200}


{block 1201}


{block 1202}


{block 1203}


{block 1204}


{block 1205}


{block 1206}


{block 1207}


{block 1208}


{block 1209}


{block 1210}


{block 1211}


{block 1212}


{block 1213}


{block 1214}


{block 1215}


{block 1216}


{block 1217}


{block 1218}


{block 1219}


{block 1220}


{block 1221}


{block 1222}


{block 1223}


{block 1224}


{block 1225}


{block 1226}


{block 1227}


{block 1228}


{block 1229}


{block 1230}
( sync boot testbed) | , :var addr [0x483e001] :var len [0x43] | , :var word [0xdea40000] :var bit [0x1] :var dly [0x32]
: clock [ bit ] @ ( -) [ 1 ] and ?v p17v ! ;
: data [ word ] @ [ $40000 ] and ?v p1v ! ; | , | ,
: 'stream ( -a) [ nnc 2 * $8000 + block 2 + ] ;
: stream ( -an) [ 'stream ] dup [ -2 ] + @ ;
: /sync softbed assign ( len) [ 0 + ] nop [ len ] ! | , | ... ( addr) [ 0 + ] nop [ addr ] ! 50 [ dly ] ! 'bed assign | , | ... [ vdd @ ] p17v ! [ 0 ] p1v ! [ dly ] @ [ -1 ] + if [ dly ] ! ; | , | ... ] then drop
: /word [ addr ] @ dup [ 1 ] + [ addr ] ! @ p-n [ word ] ! | , | ... 18 [ bit ] !
: /bit [ word ] @ 2* [ word ] ! 40 [ dly ] ! 'bed assign | , | ... clock data [ dly ] @ [ -1 ] + if [ dly ] ! ; | , | ... ] then drop [ bit ] @ [ -1 ] + if [ bit ] ! /bit ; | , | ... ] then drop [ len ] @ [ -1 ] + if [ len ] ! /word ; | , | ... ] then drop 'bed assign [ 0 ] p17v ! [ 0 ] p1v ! ; | , | , 300 !node stream /sync

{block 1231}
( sync boot)
: sync ac ( installs testbed) | , | . a ( is buffer base address of boot stream) | , | . c ( is word count of boot stream) | , | , ( testbed holds clock high for) # 25 ( ticks before) | , ( clocking out stream data)

{block 1232}


{block 1233}


{block 1234}


{block 1235}


{block 1236}
( configuration tables) :var com
: tabl pop 2/ 2/ [ com ] @ + ;
: jsr $e8 dst ; ( call has been clobbered already)
: table ( nn) [compile] align jsr tabl for dup , next drop ;
: a-boot [ -1 144 table | *
: c-boot [ -1 144 table ]
: b-boot [ -1 144 table ]
: a-reg [ -1 144 table | *
: b-reg [ io 144 table | , | ,
: /a ( a) a-reg ! ; | *
: /b ( a) b-reg ! ;
: /p ( a) [ com ] @ !inode entry ! ;
: +node ( n) nn-n [ com ] ! ;
: /part ( acb) b-boot ! c-boot ! a-boot ! ;
: /ram ( b) b-boot ! 64 c-boot ! 0 a-boot ! ;
: rammer ( -acb) a-boot @ c-boot @ b-boot @ ; | , | ,
: aaray pop 2/ 2/ [ com ] @ [ 11 ] * + ;
: array ( n) [compile] align jsr aaray [ 11 ] * for 0 , next ;
: 'stack [ 144 array :var stkp [0xa]
: @s+ 'stack [ stkp ] @ + @ 1 [ stkp ] +! ;
: !s- ( n) 'stack [ stkp ] @ + ! -1 [ stkp ] +! ;
: /stack ( stuff count) | , 10 [ stkp ] ! dup !s- for !s- next ;

{block 1237}
( - configuration tables)
: tabl
: jsr ( call from block) # 88 ( has been clobbered) | , ( so replace it with jsr instead)
: table ( build and initialize a table) | , ( tables hold configuration information)
: /a a ( specifies) [ a ( value for current node)
: /b a ( specifies) [ b ( value for current node)
: /p a ( specifies entry point for current node) | , ( using preexisting) entry ( mechanism)
: +node n ( makes n the current node)
: /part acb ( specifies) [ address count ( and) bin | , ( for code to be loaded into current node later)
: /ram b ( specifies just the bin, load all) # 64
: rammer -acb ( returns) [ address count ( and) bin | , ( from table)
: /stack stuff count ( specifies) [ count ( items to be placed on the stack at load time)

{block 1238}
( - initial values)
: ?load c-boot @ [ 0 ] + drop -if ; ] then rammer | , swap push nn-n inode over + swap | , [ comb ] @ + pop move ; | , | ,
: -com [ comb ] @ [ $8000 block negate ] + $200 / [ com ] ! ;
: deliver [ 'boot ] assign -com ?load | , a-reg @ - [ 0 ] + drop -if a-reg @ lit ra! then | , b-reg @ - [ 0 ] + drop -if b-reg @ lit rb! then | , 'stack [ 10 ] + @ dup and if dup | , | ... dup negate [ 10 ] + [ stkp ] ! for @s+ lit next | , then drop ; deliver

{block 1239}


{block 1240}
( interactive)
: node ( n) nn-n dup !inode [ nod ] ! ;
: other ( n) nn-n [ nod2 ] ! ;
: exec ( n) pc @ +r ir ! 1 slot ! 0 cnt ! ;
: fin step listen -track ;
: !b ( .!b;;) [ $2db55 ] exec !b, fin ;
: !a ( .!a;;) [ $2da55 ] exec !a, fin ;
: !+ ( .!+;;) [ $2d855 ] exec !+, fin ;
: @b ( .@b;;) [ $2df55 ] exec @b, fin ;
: @a ( .@a;;) [ $2de55 ] exec @a, fin ;
: @+ ( .@+;;) [ $2dc55 ] exec @+, fin ;
: r@ ( a-n) lit ra! @a -t ;
: r! ( na) lit ra! lit !a ;
: call pc @ lit rpush lit rpush ret fin h ;
: boot ( acn) swap push nn-n inode over + swap | , | ... [ nod ] @ inode + pop move ;
: break ( san) [ comb ] @ push !node 2* 2* or bp ! | , pop [ comb ] ! ;
: -break ( n) [ comb ] @ swap !node [ -1 ] bp ! [ comb ] ! ;

{block 1241}
( memory operators and constants)

{block 1242}
( build boot stream for softsim testbeds) | , ( exit) streamer load framer load | , | , ( smtm frame for spi) # 2 # 0 # 64 # 0 ( /root) | , ( smtm frame for sync) 1 0 64 0 /root | , | ... stream drop drop

{block 1243}
( makes a boot stream from the smtm example) | , ( starting at address) # 2 ( in order to avoid) | , ( running into the edge) | , | , stream ( leaves its address and length on stack)

{block 1244}
( spi testbed) :var clk [0x1] :var btcnt [0x21] | cr
:var cmd [0xffffffff] 0 cmd ! :var spbit [0x5145c4c8]
: 'stream ( -a) [ nnc 2 * $8000 + block 2 + ] ;
: setmem ( b) $ffffff and 8 * ( byte offset in bits) | cr
[ 'stream ] 18 * + [ spbit ] ! ; 0 setmem ]
: 'cmd ( -a) [ cmd ] dup @ p5v @ low? -if | indent
     2* over ! ; ] then - 2* - over ! ;
: ?bit [ btcnt ] @ -1 + 0 max dup [ btcnt ] ! | indent
     dup and drop if 'cmd @ setmem | indent
     pop drop ; ] then ;
: bitn ( n-nn) dup @ swap over 1 + swap ! | indent
     18 /mod @ p-n swap 1 + ;
: bit17 0 [ spbit ] bitn for 2* next | indent
     $40000 and drop if drop [ vdd @ ] then | indent
     p17v ! ;

{block 1245}
( spi testbed) | cr
boot stream is assembled starting at nnc ]
: setmem ( adds an offset and converts to bits)
: ?bit ( reads command or allows data write) | br


: spi ( assigns initial behavior to softbed) | cr
[ first waits for select high , | cr
then waits for select low , then watches | cr
spi clock and accumulates data until select | cr
goes high , at which point it starts over

{block 1246}
( spi testbed)
: threshold ( -v) [ vdd @ 2 / negate ] ;
: clk? ( -n) p1v @ threshold + - 0 max 1 min ;
: hi? ( a) @ threshold + 0 max dup and drop ;
: lo? ( a) @ threshold + - 0 max dup and drop ; | , | ,
: /spi softbed assign
: desel -1 [ cmd ] ! 33 [ btcnt ] ! | cr
'bed assign p3v lo? if ; ] then | cr
'bed assign clk? [ clk ] ! p3v lo? if | cr
'bed assign p3v hi? if desel ; ] then | indent
     [ clk ] @ clk? dup [ clk ] ! or | indent
     drop if [ clk ] @ dup and drop | indent
     if ; ] then ?bit bit17 then then ; | , | , 705 !node /spi

{block 1247}
( spi testbed) | cr
boot stream is assembled starting at nnc ]
: setmem ( adds an offset and converts to bits)
: ?bit ( reads command or allows data write) | br


: /spi ( assigns initial behavior to softbed) | cr
[ first waits for select high , | cr
then waits for select low , then watches spi | , clock and accumulates data until select | cr
goes high , at which point it starts over

{block 1248}
( show directions) :var arrow [0x5c] 92 arrow ! ]
: magenta $ff00ff color ;
: .dir ( o) [ xy ] @ dup push + [ xy ] ! | indent
     [ arrow ] @ emit pop [ xy ] ! ;
: ?dir ( n-n) dup 1 and drop if pop drop then ;
: .ndir 2/ ?dir $160000 .dir ;
: .sdir 2/ ?dir $1600a5 .dir ;
: .wdir 2/ ?dir $fff5004b .dir ;
: .edir 2/ ?dir $37004b .dir ;
: .eswn ( a) magenta .ndir .wdir | indent
     red .sdir .edir drop ;
: .wsen ( a) magenta .ndir .edir | indent
     red .sdir .wdir drop ;
: .enws ( a) magenta .sdir .wdir | indent
     red .ndir .edir drop ;
: .wnes ( a) magenta .sdir .edir | indent
     red .ndir .wdir drop ;
: which 92 dbus @ [ wrq ] and drop | indent
     if -2 + then [ arrow ] ! ;
: .drs abus @ dup - $100 and drop | indent
     if drop ; ] then which $a0 or 8 / | indent
     [ comb ] @ [ $8000 block negate ] + [ $200 ] / | indent
     dup 9 / 2 and swap 1 and or | indent
     jump .enws .wnes .eswn .wsen

{block 1249}

: which dbus @ dup wrq and drop | indent
     if drop 90 [ arrow ] ! ; ] then | indent
     rrq and drop if 92 [ arrow ] ! then ;

{block 1250}
( prelude) :var comb [0x4808000]
: xqt? ( a) @ ( b) dup and if push ; ] then drop ;
: nodes ( i-n) 2* blks ;
: inode ( i-a) nodes [ $8000 block ] + ;
: !node ( n) nn-n | *
: !inode ( i) inode [ comb ] ! ;
: my ( o-a) [ comb ] @ + ; ( node variables)
: memory ( o-a) $bf and my ; | *
: rombit ( -m) $80 ; | , ( 40-7c defined later)
: brk [ $7c ] my ; | *
: bp [ $7d ] my ;
: entry [ $7e ] my ; | *
: pins [ $7f ] my ;
: nnxmod ( -n) [ 100 ] ; | , | ,
: io [ $15d ] ; | *
: data [ $141 ] ; | *
: ldata [ $171 ] ;
: right [ $1d5 ] ; | *
: down [ $115 ] ; | *
: left [ $175 ] ; | *
: up [ $145 ] ;
: enter ( a nn) !node entry ! ;
: /enter [ nns -1 + ] for i dup !inode resets @ | , | ... rstadr entry ! -next ; /enter

{block 1251}
( prelude)
: comb ( base address of node vars for this node)
: xqt? ( execute code starting at adr in preceding variable)

{block 1252}
( softsim node variables) | cr
( cpu -pattern- buses and registers)
: dbus $40 my ;
: uport $41 my ; | -cr : udest $4e my ;
: lport $42 my ; | -cr : ldest $4d my ;
: dport $44 my ; | -cr : ddest $4b my ;
: rport $48 my ; | -cr : rdest $47 my ; | cr
( pins and testbed)
: p17v $50 my ; | -cr : p5v $51 my ;
: p3v $52 my ; | -cr : p1v $53 my ;
: edge $54 my ; | -cr : ios $55 my ;
: softbed $56 my ; | cr
( cpu -number- buses and registers)
: abus $57 my ; | -cr : ioc $58 my ;
: ar $59 my ; | -cr : b $5a my ;
: t $5b my ; | -cr : pc $5c my ; | -cr : ir $5d my ;
: s $5e my ; | -cr : ss ( i) 7 and $60 my + ;
: r $5f my ; | -cr : rs ( i) 7 and $68 my + ;

{block 1253}
( softsim node variables) | br

( some node variables make more sense as hardware patterns, others as numbers)

{block 1254}
( softsim node variables and shared code) | ,
: 'tik $43 my ; | *
: 'tok $45 my ; | *
: sp $46 my ;
: slot $49 my ; | *
: cnt $4a my ; | *
: pre $4c my ;
: cy $4f my ; | *
: 'opcode $70 my ; | *
: rp $71 my ;
: mem $72 my ; | *
: pwv $73 my ; | *
: vis $74 my ;
: ip $75 my ; | *
: 'group $76 my ; | *
: rqs $77 my ;
: iom $78 my ; | *
: 'bed $79 my ; ( 7a-7b available)
: rrq $80000 ; | *
: wrq $40000 ; | *
: brq $c0000 ; | , | , :var 'trk [0x102fb8ec] | *
: -track [ 'trk ] assign nop ;
: track [ 'trk ] assign ip @ 2/ 2/ $b8 and mem ! ; | , macro | *
: 2/s ?lit $f8c1 2, 1, ;
: 2*s ?lit $e0c1 2, 1, ; forth ]
: @10 @ | *
: 10bit $3ff and ; | *
: p-n | *
: n-p $15555 or ;
: 18bit $3ffff and ;
: 8bit $ff and pc @ $200 and or ;
: !18 ( na) push 18bit i @ $fffc0000 and or pop ! ;
: !10 ( na) push 10bit i @ $3fc00 and or pop ! ; | , | , :var vdd [0x708] 1800 vdd ! ]
: ?v ( w-v) if drop [ vdd @ ] then ;

{block 1255}
( softsim node variables and shared code) | cr
( variables)
: 'tik 'tok ( defered execution)
: sp slot ( stack and slot pointers)
: cnt pre ( timers)
: cy 'op ( carry)
: rp mem ( return stack pointer , mem dump pointer)
: pwv vis
: ip bp' ( instruction pointer ,) | indent
     ( alternate breakpoint)
: rqs ( requests from all ports accumulated here)
: rrq wrq brq ( read , write , both requests) | br


: 2/s ( right shift macro)
: 2*s ( left shift macro)
: @10 10bit ( mask and store 10 bit address)
: p-n n-p ( convert pattern to/from numbers)
: 18bit 8bit ( mask address bits)
: !18 ( store masked off 18 bit address)
: !10 ( store masked off 10 bit address) | , | , vdd ( is 1.8v)
: ?v [ must follow an operation that sets ] w | , [ to zero/non-zero

{block 1256}
( softsim all tiks)
: out ( apm) and if drop [ vdd @ ] then swap ! ;
: low? ( v-) [ vdd @ 2 / negate ] + drop ; | , | ,
: ?1p wrq
: pw! ( m) ioc @ p17v @ low? -if - then $800 and | , | .. drop if dup or then edge @ 18bit or edge ! ; | ,
: ?18p p17v [ 8 !node ioc ] @ pwv @ ( phantom) out
: npw! [ brq ] dbus @ over and or pw! ;
: ?sp ( to.do) ;
: ?ap p17v pwv @ @ $20000 ( shared) out npw! ;
: ?wake pins @ jump nul ?1p ?1p ?1p ?18p ?sp ?ap | ,
: @dest ( a-p) $f or @ @ ;
: +ours ( pa-p) dup @ swap @dest +or [ brq ] and | , | ... or 2/ 2/ ;
: @ours ( -p) [ 0 ] uport +ours lport +ours | , | ... dport +ours rport +ours ; | , | ,
: status ?wake @ours 2/ rqs ! ;

{block 1257}
( softsim all tiks)
: out ( output is zero or 1.8v)
: low? ( output negative if voltage is low) | , | ,
: pw! ( pin-wakeup sets request flag in) edge
: npw! ( neighbor-pin-wakeup sets opposite request flag based on local copy of phantom/shared pin in otherwise unused p17v.) | , | ,
: @ours ( accumulate r/w requests into) rqs

{block 1258}
( softsim all toks)
: v-b ( mn-mb) low? -if 0 ; ] then dup ;
: @pin ( mpma-mp) @ v-b v+ ;
: @4p ( mp-mp) $20 p5v @pin $8 p3v @pin
: @2p ( mp-mp) $2 p1v @pin
: @1p ( mp-mp) $20000 p17v @pin ;
: @sp ( mp-mp to.do) ;
: @pins pins @ jump nul @1p @2p @4p @1p @sp @1p
: !ios ios $1fe00 0 @pins push - over @ and | , | ... pop or rqs @ or swap ! ; | , | ,
: !pin ( vm) ioc @ over over and drop if 2* out ; | , | .. ] then ( in) 2* - and drop if ( tri) drop ; | , | .. ] then ( weak0) dup @ dup 2/ 2/ negate + swap ! ;
: !4p p5v $20 !pin p3v $8 !pin
: !2p p1v $2 !pin | *
: !1p p17v $20000 !pin ;
: !18p abus @ $100 or $110 and drop if ; | , | ... ( up/data) ] then dbus @ cnt @ - 2* drop | , | ... -if 18bit then p-n edge ! ;
: !sp ( to.do) ;
: !ap ( to.do) ;
: !pins pins @ jump nul !1p !2p !4p !18p !sp !ap

{block 1259}
( softsim all toks)

{block 1260}
( softsim suspended tiks and toks)
: cnt? cnt @ dup and drop ; | br


: -hand ( mp-mp) 2* 2* over over over and or drop ;
: -shake [ brq ] rqs @ 2* -hand if -hand if | indent
     -hand if -hand then then then drop drop ;
: wait? cnt? if -shake ; ] then ; | br


: +mine ( pa-p) @ [ brq ] and or 2/ 2/ ;
: @mine [ 0 ] uport +mine lport +mine | indent
     dport +mine rport +mine 2/ rqs ! ;
: !port ( mo-mo) over over and | indent
     if drop dbus @ then over dbus + ! 2/ ;
: !ports abus @ $155 or dup 4 2/s $8 | indent
     4 for !port next drop drop | indent
     $14 or drop if -1 cnt ! then @mine ;

{block 1261}
( softsim suspended tiks and toks) | br


: @mine ( accumulate r/w requests into) rqs

{block 1262}
( softsim tik/tok and power) :var op [0x102fcf04] | , :var 'boot [0x102fd06e] :var bail 0 bail ! ( breakpoint)
: update !pins 'bed xqt !ios ;
: ipower !inode 'tok assign | , | ... [ 0 ] p17v [ p17v negate softbed + ] fill | , | ... [ 0 p-n ] abus [ softbed negate 7 rs + ] fill | , | ... 0 mem ! entry @ pc ! softbed @ 'bed ! | , | ... [ 'boot ] xqt 4 slot ! [ $a9 ] ip ! -track update
: newop [ 0 ] cnt ! [ 0 ] dbus ! pc @ abus ! [ 0 ] rqs ! | , | ... [ 0 ] rport ! [ 0 ] dport ! [ 0 ] lport ! [ 0 ] uport ! | , | ... [ op ] @ 'tik ! [ 3 ] pre ! ; | , | ,
: ?bp ip @ slot @ or bp @ or if drop ; | , | ... ] then - [ bail ] ! [ comb ] @ brk ! ; | , | ,
: itik ( i) !inode | *
: tik 'tik xqt ;
: itok ( i) !inode | *
: tok [ 0 ] brk ! 'tok xqt ;
: tiks [ nns -1 + ] for i itik -next ;
: toks [ nns -1 + ] for i itok -next ;
: power [ nns -1 + ] for i ipower -next toks tiks ;

{block 1263}
( opcode ---tick--- ---tock---) | cr
( -alu-- ..update.. .!results.) | cr
( ...... ..........) | cr
( -addr- .upd,bus,? /) | br

( alu ops don't have to change tick;) | cr
( addr ops set abus,dbus in tick, then check for completion; if not done, tock writes dbus to ports and tick checks again, repeated til done. when done, tock clears ports and resumes opcode.)

{block 1264}
( softsim read/write access)
: @port ( mop-mop) push over over and | , | ... if dbus + @dest then pop +or over u+ ;
: @ports dbus @ [ wrq ] ? drop if ; ] then | , | ... abus @ 4 2/s $15 or $1 0 | , | ... 4 for @port next nip nip 18bit dbus ! ; | , | ,
: ir/w abus @ $15d or drop if ; ] then | , | ... dbus @ [ wrq ] ? if 18bit p-n ioc ! ; | , | ... ] then drop ios @ dbus ! ; | , | ,
: romw? dbus @ [ wrq ] ? drop if | , | ... abus @ [ rombit ] ? drop then ;
: mr/w dbus @ [ wrq ] ? if 18bit abus @ memory ! ; | , | ... ] then drop abus @ memory @ dbus ! ;

{block 1265}
( softsim read/write access)

{block 1266}
( softsim port, register, and memory access) | , ( tik0) | *
: por@! status 'tok assign | , ( tok0) !ports update -1 cnt +! 'tik assign | , ( tiki) status wait? if 'tok assign | , ( toki) update -1 cnt +! ; | , ( tike) ] then @ports 'tok assign
: toke 'opcode xqt 'group xqt newop ; | , | ... ] begin 'tik assign | , ( tiki) | *
: reg@! status cnt? while 'tok assign | , ( toki) update -1 cnt +! end | , ( tike) then 'tok assign ( toke) ir/w toke ; | , | ... ] begin 'tik assign | , ( tiki) | *
: mem@! status cnt? while 'tok assign | , ( toki) update -1 cnt +! end | , ( tike) then romw? if 'tok assign [ op ] @ 'tik ! ; | , | ... ] then 'tok assign ( toke) mr/w toke ; | , | ,
: access ( apc) pop 'group ! pop 'opcode ! | , | ... cnt ! dbus ! $3ff and dup abus ! | , | ... $100 ? if $155 or $f0 and drop if | , ( ports) 1 cnt ! por@! ; | , ( regs) ] then 2 cnt ! reg@! ; | , ( mem) ] then ( x) drop mem@! ;

{block 1267}
( notes) | , | , ( opcode ---tick--- ---tock---) | , ( -alu-- ..update.. .!results.) | , ( ...... ..........) | , ( -addr- .upd,bus,? /) | , | , ( alu ops don't have to change tick;) | , ( addr ops set abus,dbus in tick, then check) | , ( for completion; if not done, tock writes dbus to ports and tick checks again, repeated til) | , ( done. when done, tock clears ports and resumes opcode.)

{block 1268}
( softsim ops common code)
: ++@ ( a-n) dup push @ 1 + dup pop ! ;
: @-- ( a-n) dup push @ dup -1 + pop ! ;
: +t ( n) t @ s @ sp ++@ ss ! s ! t ! ;
: -t ( -n) t @ s @ t ! sp @-- ss @ s ! ;
: +r ( n) r @ rp ++@ rs ! r ! ;
: -r ( -n) r @ rp @-- rs @ r ! ;
: bin ( -nn) -t t @ ;
: @19 ( -n) @ dup $20000 and 2* or ;
: 3bit ( a-a) $7 and pc @ $2f8 and or ;
: addr ( a-a) slot @ jump | , | ... 10bit 8bit 3bit nul nul | , | ,
: ++abus ( -n) abus @ $100 ? if ; ] then $27f
: /++/ ( nm-n) over dup 1 + or and or ;
: pc++ ++abus pc ! ;
: ar++ ++abus ar !10 ; | , | ,
: ?+c ( n-n) pc @ - $200 and drop if ; ] then | , cy @ 1 and + dup 18 2/s 1 and cy ! ;
: ?+*c ( n-n) pc @ - $200 and drop if ; ] then | , cy @ 1 and + dup - 18 2/s 1 and cy ! ;
: ?s+ ( n-n) ar @ 1 ? if push s @19 + ?+*c pop then 2/ over 1 and drop if $20000 or then ar ! ;

{block 1269}
( softsim ops common code) | br


: @19 ( fetch then extend sign into bit 18)
: ?+c ( add carry for + when p9 set)
: ?+*c ( add carry for +* when p9 set) | indent
     ( includes sign extend in s)

{block 1270}
( softsim ops control)
: /fet/ ( a) [ rrq ] 3 | *
: /pre/ ( adc) access ( control group) | , | ... abus @ 2* 2* ip ! | , | ... dbus @ p-n ir ! pc++ | *
: slot0 0 slot ! ; | , | , ( tike) | *
: /unext/ status pop 'opcode ! 'tok assign | , ( toke) update 'opcode xqt [ 3 ] pre ! ; | , | ,
: ret r @ /fet/ -r drop ;
: ex r @ /fet/ pc @ r !10 ;
: jmp ir @ addr /fet/ nop ;
: call ir @ addr /fet/ r @ +r pc @ r !10 ; | , | ,
: ur r @ dup and drop if | , | ... ( jump) /unext/ -1 r +! slot0 ; | , | ... ( fall) ] then /unext/ -r drop | *
: slot+ 1 slot +! ;
: jr r @ dup and drop if | , | ... ( jump) ir @ addr /fet/ -1 r +! ; | , | ... ( fall) ] then pc @ /fet/ -r drop ;
: jz $3ffff | *
: jc t @ and drop if | , | ... ( fall) | *
: fetch pc @ /fet/ nop ; | , | ... ( jump) ] then jmp ;
: jp $20000 jc ;

{block 1271}
( notes) | , | ,
: /fet/ ( begins a forced instruction fetch)
: /pre/ ( uses) access ( to set control-group) | , ( behavior) | , | , ( unconditional jumps specify source of next) | , ( instruction followed by) /fet/ ( group behavior) | , ( followed by instruction completion behavior) | , | , ( conditional jumps make their test which) | , ( determines which of two actions to follow)

{block 1272}
( softsim ops read/write and alu.1)
: /w/ ( r) @ t @ n-p [ wrq ] or [ 3 ] access ( write group) | , | ... -t drop slot+ ;
: /r/ ( r) @ [ rrq ] 3 access ( read group) | , | ... dbus @ p-n +t slot+ ; | , | ,
: @a | *
: @a, ar /r/ nop ; | * | .
: !a | *
: !a, ar /w/ nop ;
: @b | *
: @b, b /r/ nop ; | * | ..
: !b | *
: !b, b /w/ nop ;
: @+ | *
: @+, ar /r/ ar++ ; | *
: !+ | *
: !+, ar /w/ ar++ ;
: @p pc /r/ pc++ ; | * | .. | ..
: !p pc /w/ pc++ ; | , | ,
: /alu/ slot @ 3 or drop if ( slot0-2) | , ( tike) status pop 'opcode ! 'tok assign | , ( toke) update 'opcode xqt -1 pre +! slot+ ; | , ] then ( slot3) pc @ [ rrq ] pre @ 0 max /pre/ ; | , | ,
: +* /alu/ | *
: r+* t @19 ?s+ 2/ 18bit t ! ;
: 2*x /alu/ | *
: r2* t @ 2* 18bit t ! ;
: 2/x /alu/ | *
: r2/ t @19 2/ t ! ;
: -x /alu/ | *
: r- t @ $3ffff or t ! ;
: +x /alu/ | *
: r+ bin + ?+c 18bit t ! ;
: andx /alu/ | *
: rand bin and t ! ;
: orx /alu/ | *
: ror bin or t ! ;
: t! /alu/ | *
: rdrop -t drop ;

{block 1273}
( notes) | , | ,
: /alu/ ( alu opcodes in slots 0-2 don't end any) | , ( over-lapping prefetch behavior, while in slot) # 3 ( both actions finish together.) pre ( fakes the simultaneity by keeping track of how many) | , ( contiguous alu opcodes were at the end of the instruction word.)

{block 1274}
( softsim ops alu.2 and jump table)
: t@ /alu/ | *
: rdup t @ | *
: lit ( n) +t ;
: .x /alu/ nop ;
: r@ /alu/ | *
: rpop -r +t ;
: r! /alu/ | *
: rpush -t +r ;
: s@ /alu/ | *
: rover s @ +t ;
: b! /alu/ | *
: rb! -t 10bit b ! ;
: a@ /alu/ | *
: ra@ ar @ +t ;
: a!x /alu/ | *
: ra! -t ar ! ; | , | ,
: s0 ( p-o) 13 2/s $1f and ;
: s1 ( p-o) 8 2/s $1f and ;
: s2 ( p-o) 3 2/s $1f and ;
: s3 ( p-o) 2* 2* $1f and ;
: s4 ( p-o) drop $20 ;
: @op ( ps-o) jump s0 s1 s2 s3 s4 | , | ,
: !op [ op ] assign ?bp ir @ n-p slot @ @op jump | , | ... ret ex jmp call ur jr jz jp | , | ... @p @+ @b @a !p !+ !b !a | , | ... +* 2*x 2/x -x +x andx orx t! | , | ... t@ r@ s@ a@ .x r! b! a!x | , | ... fetch [ !op

{block 1275}


{block 1276}
( softsim display ops) :var ?op [0x102fdad8]
: tab/2 ( xy) push [ 11 ] * [ 3 ] + pop [ 15 ] * [ 3 ] + | indent
     over lm at ;
: cr/2 cr -15 [ xy ] +! ;
: emit/2 ( c) [ 48 ] + emit
: -sp/2 [ -11 $10000 * ] nop [ xy ] +! ; | br


: v- ( xyxy-xy) push negate pop negate v+ ; | br


: 'ops align strings ( ; ex jump call unext next if -if @p @+ @b @ !p !+ !b ! +* 2* 2/ - + and or drop dup pop over a . push b! a! fetch) | br


: .op ( i) 'ops @ [ $fffffff0 ] and | indent
     begin dup and while unpack emit/2 | indent
     end then drop sp/2 ;
: ?more ( o) [ $18 ] ? if drop ( t) ; | indent
     ] then [ $3 ] ? if dup or drop ( f) ; | indent
     ] then [ $4 ] and drop ( t/f) ;
: .ops ( p) 0 4 for [ ?op ] xqt | indent
     over over @op dup .op | indent
     ?more while [ 1 ] + next ; ] then | indent
     pop drop ;

{block 1277}
( softsim display ops)

{block 1278}
( softsim display numbers) :var base [0x10]
: hex 16 [ base ] ! ;
: dec 10 [ base ] ! ;
: digits ( i-n) 1 + 0 max 17 min align tbl | , | ... [ 47 , 24 , 25 , 26 , 27 , | , | ... 28 , 29 , 30 , 31 , | , | ... 32 , 33 , 5 , 19 , | , | ... 10 , 16 , 4 , 14 , 48 , ]
: digit ( i) digits emit/2 ;
: .n ( nc) dup push -1 + | , | ... for [ base ] @ /mod next | , | ... begin digit next ;
: awake cnt? -if -shake | , | ... if silver pop drop ; ] then then ;
: ?blue awake | *
: blue $4040ff color ;
: ?cyan awake | *
: cyan $ffff color ; | *
: ?red awake red ;
: yellow $e0e000 color ; | *
: ?white awake white ;
: ?green awake | *
: green $d000 color ;
: broke [ comb ] @ brk @ or drop if pop drop then ;
: ?brk broke [ xy ] @ $10000 /mod 56 + swap 136 + | , | ... $3f3f color box ;

{block 1279}
( softsim display)
: base ( radix for small character number display)
: hex ( change) [ base ( to hex)
: dec ( change) [ base ( to decimal)
: digits ( table of character values)
: digit ( display digit as small character) | cr
( ? if too low, pacman if too high, for debug)
: .n ( display) c ( digits of) n ( in the current) [ base
: awake ( exits caller if not awake)
: ?white
: ?green
: ?blue
: ?red ( change to named color if only awake)
: broke ( exit caller if breakpoint not reached)
: ?brk ( draw a box around the node which has) | , ( reached a breakpoint)

{block 1280}
( softsim display directions) | cr

: .some ( p- -sp/2) $80 ? if ( r) 1 emit/2 then | indent
     $40 ? if ( d) 16 emit/2 then | indent
     $20 ? if ( l) 12 emit/2 then | indent
     $10 ? if ( u) 22 emit/2 then | indent
     drop pop drop ;
: .rdlu ( p-) $f0 over over or and drop | indent
     if .some ; ] then ( a) 5 emit/2 | indent
     ( l) 12 emit/2 ( l) 12 emit/2 drop pop drop ;
: .iocs ( p- i) 7 emit/2 ( o) 3 emit/2 | indent
     drop pop drop ;
: .adirs ( a-?) $100 over over or and drop if ( -n) ;
: .dirs ( a-?) dup n-p if $15400 or $3fd00 and | indent
     while then drop ( -n) ; | indent
     ] then drop sp/2 sp/2 | indent
     then 8bit $55 or $f0 ? if .rdlu ; | indent
     ] then $8 ? if .iocs ; | indent
     ] then sp/2 ( ?) 47 emit/2 drop pop drop ;
: noadr ( w) drop ; | -cr : .10b ( w) p-n $3ff and 3 .n ;
: .8b ( w) p-n $ff and 2 .n ;
: .3b ( w) 43 emit/2 p-n 7 and digit ;
: .adr ( wi) over over @op -2 + drop | indent
     -if drop drop ; ] then | indent
     jump .10b .8b .3b noadr noadr

{block 1281}
( softsim display directions) | cr


{block 1282}
( softsim display registers)
: adr. abus @10 .adirs 3 .n ;
: db. dbus @ p-n 5 .n ;
: tr. cy @ 1 and drop if -sp/2 $25 emit/2 then | cr
t @ 5 .n ;
: sr. s @ 5 .n ;
: ar. ar @ .dirs 5 .n ;
: br. b @10 .adirs 3 .n ;
: ioc. ioc @ 5 .n ;
: ios. ios @ p-n 5 .n ;
: rqs. rqs @ 9 2/s $ff and $2 .n ;
: ir. ir @ 5 .n ;
: op. ir @ n-p slot @ @op .op ;
: pc. pc @10 .adirs 3 .n ;
: rr. r @ 5 .n ;
: sl. slot @ digit ;
: rp. rport @ 5 .n ;
: dp. dport @ 5 .n ;
: lp. lport @ 5 .n ;
: up. uport @ 5 .n ; | br


: ?+- ( -c) -shake if ( -) 35 ; ] then white ( +) 43 ;
: cnt. cnt @ dup and | indent
     -if drop ?+- emit/2 ; ] then digit ;

{block 1283}
( softsim display registers) | br

( building blocks for the 2d display, com.)

{block 1284}
( softsim display pins)
: i/o ( m) cyan ioc @ and drop if yellow then ;
: .io ( m) dup i/o ios @ and if drop $1 then digit ;
: .1p $20000 .io ; | *
: .2p .1p $2 .io ;
: .4p .1p $20 .io $8 .io $2 .io ;
: .18p $1000 i/o edge @ 5 .n ;
: .sp ( to-do) red [ 0 ] 2 .n ;
: .ap ( to-do) red [ 0 ] 2 .n ;
: .pin pins @ jump nul .1p .2p .4p .18p .sp .ap
: .pins [ comb ] @ [ $8000 block negate ] + [ $200 ] / | , | ... dup -17 + drop -if drop 165 [ xy ] +! .pin ; | , | ... ] then 18 mod -17 + drop -if .pin ; | , | ... ] then $2c0000 [ xy ] +! .pin ;
: mv. ( ab) i/o @ sp/2 4 .n ;
: .mvs p17v $20000 mv. p5v $20 mv. | , | ... p3v $8 mv. p1v $2 mv. ;
: ?pex [ ?op ] assign dup slot @ or drop if white ; | , ] then red | *
: /?op [ ?op ] assign white ; /?op ]
: ?ip ( nf-n) dup and drop if ?green /?op ; ] then ;
: ?pc ( n-nf) dup pc @ or [ $240 - ] and drop | , if dup 2* 2* ip @ or [ $900 - ] and drop | , if [ 1 ] ; ] then red ?pex [ 0 ] ; ] then yellow [ 0 ] ;

{block 1285}
( softsim display pins)

{block 1286}
( softsim display big nodes) :var nod :var nod2 [0x12] | cr
] begin drop red ;
: me? ( i) dup [ nod ] @ or drop until [ nod2 ] @ or drop | , | ... if broke cyan ; ] then yellow ;
: .focus ( i) dup me? n-nn dec 3 .n hex ;
: stack sp @ 8 for dup ss @ 5 .n | , | ... cr/2 -1 + next drop ;
: return rp @ 8 for 1 + dup rs @ 5 .n | , | ... cr/2 next drop ;
: stacks white return ?red rr. cr/2 | , | ... ?green tr. cr/2 sr. cr/2 white stack ;
: /mem. ( i) [ 'trk ] xqt mem @ + dup white ?pc swap | , | ... 2 .n sp/2 ?ip memory @ dup p-n | , | ... 5 .n sp/2 .ops .adr cr/2 ;
: mem. mem @ $b8 and mem ! 15 for i /mem. -next ;
: .pex ip @ dup $400 and drop if | , | ... red -sp/2 2/ 2/ $3ff and 3 .n sp/2 | , | ... ir. sp/2 ir @ p-n ?pex .ops .adr ; | , | ... ] then drop ;
: .big ( hvn) dup push !inode hex | , | ... over 30 + over tab/2 stacks | , | ... tab/2 pop .focus sp/2 white ar. | , | ... cr/2 space space space br. | , | ... cr/2 .pex cr/2 mem. cr/2 | , | ... white ( ios. sp/2 rqs. cr edge @ h. cr) ;

{block 1287}
( softsim display big nodes)

{block 1288}
( softsim display small nodes) | cr
:var xo :var yo :var xs [0x8] 8 xs ! :var ys [0x4] 4 ys ! ]
: com. ( i) hex [ xy ] @ push .drs .pins pop [ xy ] ! cr/2 -sp/2 silver ( i) .focus white adr. cr/2 ?brk | cr
-sp/2 ?white sl. ?green op. cr/2 | indent
     ?white ir. cr/2 | indent
     ?green cnt. sp/2 ?white pc. cr/2 | indent
     ?white ar. cr/2 space ?white br. | cr
cr/2 ?cyan ioc. cr/2 ?red rr. cr/2 | cr
?green tr. cr/2 sr. ;
: ?com ( i) dup !inode vis @ dup and | indent
     if [ $10000 ] /mod tab/2 com. ; | indent
     ] then drop drop ;
: coms. nnx [ xs ] @ negate + [ xo ] @ [ yo ] @ [ nnx ] * + | cr
[ ys ] @ for [ xs ] @ for dup ?com 1 + next | cr
over + next drop drop ;
: out? ( i-xy) [ nnx ] /mod [ xo ] @ [ yo ] @ v- | indent
     over over +or push over over | indent
     [ xs ] @ [ ys ] @ v- and - pop +or drop ;
: loc ( i-l) dup !inode out? -if drop drop 0 ; | cr
] then push ( x) [ 7 ] * [ 1 ] + | indent
     pop ( y) - [ ys ] @ + # 11 [ 12 ] * ( hv) [ 16 ] 2*s + ;
: !vis [ comb ] @ [ nns -1 + | indent
     ] for i loc vis ! -next [ comb ] ! ;

{block 1289}
( softsim display small nodes)

{block 1290}
( softsim display map and screen) | cr
:var gap [0x2] :var wind? [0xffffffff] :var time
: xm ( -n) nnx [ xs ] @ negate + ;
: ym ( -n) nny [ ys ] @ negate + ;
: .vis ( hv) 2/ [ yo ] @ - ym + [ 2 ] + + [ 30 ] * push | indent
     2/ [ xo ] @ + [ 22 ] * pop over over at | indent
     [ xs ] @ [ 22 ] * [ ys ] @ [ 30 ] * v+ blue box ;
: .node ( n) nn-n dup !inode ?green 48 emit | indent
     me? $ffea0000 [ xy ] +! 21 emit ;
: .line ( n) cr 17 for dup .node 1 + -next drop ;
: .map ( hv) over over .vis tab/2 | indent
     7 for i [ nnxmod ] * .line -next ;
: .wind ( hv) [ wind? ] @ dup and drop if .map ; | indent
     ] then 1 1 v+ [ nod2 ] @ .big ;
: bg $1f1f1f color | indent
     25 for 46 for 48 emit next cr next ;
: .so ( bg) [ comb ] @ coms. | indent
     56 0 .wind 57 22 [ nod ] @ .big cr/2 | indent
     white [ time ] @ . cr [ gap ] @ . [ comb ] ! ;
: ok !vis show black screen text .so keyboard ;

{block 1291}
( softsim display map and screen)

{block 1292}
( softsim keyboard handler)
: wtog [ wind? ] @ -1 or [ wind? ] ! ;
: we 1 | -cr : dx ( n) [ xo ] swap over @ + xm
: dw ( ann) min 0 max swap ! !vis ;
: ww -1 dx ;
: wn 1 | -cr : dy ( n) [ yo ] swap over @ + ym dw ;
: ws -1 dy ;
: wy+ [ ys ] @ 1 + 4 min [ ys ] ! 0 dy ;
: wy- [ ys ] @ -1 + 1 max [ ys ] ! 0 dy ;
: wx+ [ xs ] @ 1 + 8 min [ xs ] ! 0 dx ;
: wx- [ xs ] @ -1 + 1 max [ xs ] ! 0 dx ;
: ftog [ nod2 ] @ [ nod ] @ [ nod2 ] ! | indent
     [ nmem ] @ [ n2mem ] @ [ nmem ] ! [ n2mem ] !
: nod! ( n) dup !inode [ nod ] ! mem @ [ nmem ] ! ;
: fw -1 | *
: +nod [ nod ] @ + [ 0 ] max [ nns -1 + ] min nod! ;
: fn [ nnx ] nop | *
: ++nod [ nod ] @ over +nod swap over + | , | ... [ nod ] @ or drop if nod! ; ] then drop ;
: fs [ nnx negate ] ++nod ; | *
: fe 1 +nod ;
: mh [ 8 64 + ] nop | *
: mhl -track [ comb ] @ swap | , | ... [ nod ] @ !inode mem @ + [ $bf ] and | , | ... dup [ nmem ] ! mem ! [ comb ] ! ;
: ml [ -8 ] mhl ;

{block 1293}
( softsim keyboard handler)

{block 1294}
( softsim keyboard handler)
: gtog [ big ] @ 1 or [ gap ] @ or [ gap ] ! ;
: +gap 1 | *
: +g [ big ] @ + 2 max dup [ big ] ! [ gap ] ! ;
: ++gap 100 +g ; | *
: --gap -100 +g ; | *
: -gap -1 +g ;
: brk? [ bail ] @ dup and drop ;
: restart 0 [ time ] ! [ comb ] @ power nm2m [ comb ] ! ;
: step 1 [ time ] +! [ comb ] @ toks tiks [ comb ] ! ;
: quick [ gap ] @ | *
: steps ( n) 0 [ bail ] ! for | , | ... step brk? if pop drop ; ] then next ;
: upto ( n) [ time ] @ negate + 0 max steps ;
: go quick pause brk? if ; ] then key? go ;
: -stp -track quick ;
: +stp step | *
: listen awake begin [ op ] @ 'tik @ or | , | ... drop while pause key? step end then track ; | ,
: h pad ( -n.alt) nul +stp accept nul | , ( ur) ww wn ws we ( mr) fw fn fs fe | , ( lr) ftog mh ml wtog ( ul) nul nul --gap ++gap | , ( ml) restart gtog go -stp ( ll) nul nul -gap +gap | , ( n.alt) [ $2507 , | , ( ur) $110160c , ( mr) $110160c , ( lr) $f0c1403 , | , ( ul) $2b230000 , ( ml) $80d0e12 , ( ll) $2b230000 ,

{block 1295}
( softsim keyboard handler) | br


: h ( keyboard handler) | indent
     | .. [ -+ ( by) # 100 | indent
     pfgs ( power fast go step) | indent
     | .. -+ ( by) # 1 | cr
| indent
     ludr ( left up down right) window | indent
     ludr ( left up down right) focus | indent
     oudw ( other up down window) memory dump | cr
| indent
     i. ( instruction) step complete opcode ( quit) | br

note/ ] pad ( other-keys del-key space-bar alt-key) [ also, 1st chars are ( del-key space-bar alt-key) right-to-left

{block 1296}
( softsim connect node ports)
: !dests ( onn-on) !inode over dbus + push | , | ... dup !inode over dbus + pop | , | ... ( onaa) over over $f or ! swap $f or ! ;
: row ( on-o) [ nnx ] for dup [ nnx ] + !dests 1 + | , | ... next drop ;
: rows ( non) for over row [ nnx 2 * ] u+ | , | ... next drop drop ;
: col ( on-o) [ nny ] for dup 1 + !dests [ nnx ] + | , | ... next drop ;
: cols ( non) for over col 2 u+ next drop drop ; | , | , dbus negate ]
: rights 0 [ dup rport + ] nop [ nnx 2/ ] cols ;
: lefts 1 [ dup lport + ] nop [ nnx 2/ -1 + ] cols ;
: downs 0 [ dup dport + ] nop [ nny 2/ ] rows ;
: ups nnx [ uport + ] nop [ nny 2/ -1 + ] rows ;
: edges [ nns -1 + ] for i !inode | , | ... [ 0 ] pins ! [ $201ff ] iom ! [ ' nul ] softbed ! | , | ... edge dup ldest ! udest ! -next ;
: connect edges rights lefts ups downs ; | , connect

{block 1297}
( softsim connect node ports) | br

edge ( is the dummy destination for unassigned) | cr
( left and up ports)
: !dests ( using a port index /1,2,4,8/ and two) | cr
( nodes, node numbers, stores both port) | cr
( addresses in the other's *dest variable)
: row | -cr : rows | -cr : col | -cr : cols ( calc neighbors and assign *dest)
: rights | -cr : downs | -cr : lefts | -cr : ups
: edges
: connect

{block 1298}
( softsim assign node pins and wake-up)
: c0, ( n) $1e00 | *
: iom! ( nm) swap !node iom @ or iom ! ;
: l0, ( n) $1800 iom! ; | *
: u0, ( n) $600 iom! ;
: l1, ( n) $21800 1 | *
: !p ( nmi) push iom! pop pins ! ;
: l2, ( n) $21803 2 !p ; | *
: u1, ( n) $20600 1 !p ;
: u2, ( n) $20603 2 !p ; | *
: u4, ( n) $2063f 3 !p ;
: u18, ( nw) swap $20600 4 !p pwv ! ;
: us, ( n) $20600 5 !p ( dummy) ;
: !ap ( nwm) swap !node ios push 6 !p pop pwv ! ;
: la, ( nw) $21800 !ap ; | *
: ua, ( nw) $20600 !ap ; | , | , ( single) 100 l1, 217 l1, 317 l1, 417 l1, 500 l1, 517 l1, 600 l1, 715 u1, ( serdes) 1 us, 701 us, | , ( spi) 705 u4, ( async) 708 u2, ( 1wire) 200 l1, ( sync) | , 300 l2, ( parallel) 7 $200 u18, 8 u4, 9 $80 u18, | , ( analog) 117 217 la, 617 517 la, 709 715 ua, | , 713 715 ua, 717 715 ua, ( no pins) 0 c0, 2 u0, | , 3 u0, 4 u0, 5 u0, 6 u0, 10 u0, 11 u0, 12 u0, | , 13 u0, 14 u0, 15 u0, 16 u0, 17 c0, | , 400 l0, 700 c0, 702 u0, 703 u0, | , 704 u0, 706 u0, 707 u0, 710 u0, | , 711 u0, 712 u0, 714 u0, 716 u0,

{block 1299}
( softsim assign node pins and wake-up)

{block 1300}
] unused [ see 150 ( test code for chip) reclaim | br

( ide parts) 1372 5 loads reclaim | br

( custom code) 1302 load ( exit) | br

( polyforth) 730 load | cr
( smtm test) 0 node 1342 load exit | br

( */ exerciser) 402 node 1354 load | indent
     401 node 1356 load 400 node 1358 load | cr
( serdes) 1 node 1360 load 701 node 1362 load | cr
( spi flash write) 702 node 1364 load | cr
( ana) 715 node 1366 load 717 node 1368 load | cr


{block 1301}
( this block is loaded to compile test code for any desired nodes. write *nnn node* either here before loading a node's source, or in the source itself. the *node* phrase compiles the appropriate rom for the given node so that test code may reference the rom.) | br

( things like ide and common tests are loaded here, and this base code is presently assigned up at the top of this area just below 1380. to simplify base maintenance, please use) # 1302 ( for your own testing and load it from here. when we begin using personal space above) # 1440 ( your own tests can go there.)

{block 1302}
] unused ( custom test code exit) | br

( read/write) # 18 ( bit flash) | indent
     [ 705 node 1364 load 1609 bin | indent
     706 node 1216 load 1610 bin | cr
( read/write) # 8 ( bit flash) | indent
     705 node 1370 load 1611 bin | cr
( read image from flash to sram) | cr
host ]
: sram ( -n) 4095 lit ;
: resume ( -n adjusted) [ 656 18 8 */ 4 * ] lit ; | cr
target | indent
     705 node 292 load 1612 bin | cr
( spi speedup) | indent
     705 node 284 load 1608 bin

{block 1303}
( this load block, and the following) # 25 ( source/shadow pairs, are yours to do with as you please!)

{block 1304}
( eforth rom code) | br

( sdram addr) 9 node 1320 load | indent
     ( ctrl) 8 node 1322 load ( ram) | indent
     ( data) 7 node 1324 load | indent
     ( idle) 108 node 1326 load | indent
     ( user) 107 node 1328 load | br

( eforth stack) 106 node 1310 2 loads | indent
     ( bitsy) 105 node 1306 2 loads | br



{block 1305}
( load block for rom resident sdram and eforth in the ga144. loaded by) # 940 ( even for tapeout.)

{block 1306}
( e4 bitsy 1of2) | cr
$aa org ]
: rp-- ( a-a') = $aa -1 . + ;
: bs@ | -cr : 'else ( a-w) = $ac | indent
     @p+ !b !b . ( ') @p+ x@ ( ') | indent
     @p+ !b @b ; ( ') ] . . . !p+ ( ')
: rp@ ( ri-ri) = $b0 over rp--
: pshbs ( w-) = $b1 @p+ !b !b ; ( ') ] @p+ pshw ( ')
: 'r@ ( ri-ri) = $b3 over rp--
: @w ( a-) = $b4 bs@ pshbs ;
: rfrom ( ri-r'i) = $b6 over rp-- over over @w ;
: popbs ( -w) = $b9 @p+ !b @b ; ( ') ] !p+ pops ( ')
: pshr ( aw-a) = $bb | indent
     @p+ !b !b dup ( ') @p+ . . @p+ ( ') | indent
     !b @p+ !b . ( ') x! ( ')
: rp++ | -cr : ip++ ( a-a') = $bf 1 . + ;
: tor ( ri-r'i) = $c1 push popbs pshr pop ;
: rp! ( i-ri) = $c4 push popbs rp++ pop ; | br


: 'con ( ra-r'i) = $c7 bs@
: 'var ( ra-r'i) = $c8 dup pshbs
: 'exit ( rx-r'i) = $c9 drop rp-- dup bs@ ;

{block 1307}
( e4 bitsy shadow 1of2)
: rp-- ( internal)
: x@ ( internal) | -cr : 'else ( eforth microcode)
: rp@ ( eforth microcode)
: pshw ( internal)
: 'r@ ( eforth microcode)
: @w ( internal)
: rfrom ( eforth microcode)
: popw ( internal)
: pshr ( internal)
: rp++ ( internal) | -cr : ip++ ( internal)
: tor ( eforth microcode)
: rp! ( internal)
: 'con ( eforth microcode)
: 'var ( eforth microcode)
: 'exit ( eforth microcode)

{block 1308}
( e4 bitsy 2of2) | br

= $cb ] begin dup 2* -if | indent
     ( code.s-xt) drop !b ahead [ swap ] then | indent
     ( code.r-xt) drop push ;' | cr

: bitsy = $ce then dup bs@ push ip++
: xxt = $d0 pop -until | indent
     ( list-xt) push pshr pop bitsy ; | br

( execute)
: 'ex = $d3 ( xt--) popbs push xxt ;
: 'lit = $d5 ( --w) dup bs@ push ip++ pop pshbs ;
: 'if = $d8 ( f--) popbs if | indent
     drop ip++ ; ] then drop 'else ; | br

= $dc exit ( start is run in ide)
: start right a! ( terminal) left b! ( stack) | indent
     -32 0 ( rp.ip) bitsy ;

{block 1309}
( e4 bitsy 2of2 shadow)
: 'con ( runtime constant)
: 'var ( runtime variable)
: 'exit ( runtime end call) | br


: btc ( label e4 interpreter) | cr
( bitsy main interpreter entry)
: xxt ( internal) | br


: 'ex ( runtime execute)
: 'lit ( runtime literal)
: 'if ( runtime conditional branch) | cr

: @io ( return the serial bit delay)
: !io ( init serial 0-autobps n-fixedbps)
: t!io ( internal)
: tx! ( transmit one character)
: ttx! ( internal)
: trx? ( internal)
: rx? ( test recieved char - 0 if no char else 18bit inverted char)

{block 1310}
( e4 stack 1of2) | cr
$3c org ]
: xa@ ( a-) = $3c @p+ !b !b ; ( ') ] @p+ sd@ ( ')
: xa! ( a-) = $3e @p+ !b !b ; ( ') ] @p+ sd! ( ') | cr
= $40 [ $aa org ]
: 'c@ | -cr : '@ | -cr : x@ ( a-w) = $aa xa@ @b ;
: sp++ | -cr : char+ | -cr : cell+
: 1+ ( w-w') = $ac 1 . + ;
: popt ( p-xp't) = $ae dup sp++ over x@ ;
: sp-- | -cr : char- | -cr : cell-
: 1- ( w-w') = $b0 -1 . + ;
: psht ( pt-p') = $b2 push sp-- pop over
: x! ( wa-) = $b4 xa! !b ;
: 'c! | -cr : '! ( pwa-p'st) = $b6 x!
: popts ( p-p'st) = $b7 popt
: pops ( pt-p'st) = $b8 push popt pop ;
: pshs ( pst-p't) = $ba push psht pop ;
: page@ ( pst-p'tw) = $bc @p+ !b @b . ( ') dup !p+ ; ( ')
: pshw ( pstw-p'tw) = $be push pshs pop ;
: page! ( ptw-p'st) = $c0 @p+ !b !b . ( ') drop @p+ ; ( ') ] pops ;
: sp@ = $c3 ( -a) pshs psht dup pops ;
: sp! = $c6 ( a-) pshs popts ;

{block 1311}
( e4 stack 1of2 shadow)
: 'c@ ( runtime c@)
: '@ ( runtime @)
: x@ ( inline external ram)
: sp++ ( increment data stack pointer)
: char+ ( increment address by char size)
: cell+ ( increment address by cell size)
: 1+ ( increment by one)
: popt ( internal)
: sp-- ( decrement data stack pointer)
: char- ( decrement address by char size)
: cell- ( decrement address by cell size)
: 1- ( decrement by one)
: psht ( internal)
: x!
: 'c! ( runtime c!)
: '! ( runtime !)
: popts ( internal)
: pops ( internal)
: pshs ( internal)
: page@ ( inline external ram)
: pshw ( inline external ram)
: page! ( inline external ram)

{block 1312}
( e4 stack 2of2)
: 'drop = $c8 ( w-) drop pops ;
: 'over = $c9 ( ww-www) over pshw ;
: 'dup = $ca ( w-ww) dup pshw ;
: 'swap = $cb ( ab-ba) over push push drop pop pop ;
: '2/ = $cd ( w-w) 2/ ; | -cr : '2* = $ce ( w-w) 2* ;
: um+ = $cf ( uu-uc) over or -if | indent
     = $d0 over or . + -if
: 'nc = $d2 ( -0) dup dup or ;
: 'cy = $d3 ( -1) then 1 ; | indent
     = $d5 ] then over or -if + 'cy ; ] then + 'nc ;
: zless = $d8 ( n-f) -if dup or - ; ] then dup or ;
: 'or = $db ( ww-w) over - and
: 'xor = $dc ( ww-w) or pops ;
: 'and = $dd ( ww-w) and pops ;
: negate = $de ( w-w) 1-
: invert ( w-w') = $df begin ( .) - ;
: zeq ( w-f) = $e0 until dup or ;
: '+ ( pww-p'sw') = $e2 + pops ; = $e3 ( exit)
: swap- = $e3 ( ww-w) - . + - pops ; = $e5 | br

= $e5 exit ( start is run in ide)
: start right b! ( sdram) | cr
0 dup dup ( sp.s.t) --l- ; ( bitsy)

{block 1313}
( e4 stack 2of2 shadow)
: pshw ( internal)
: sp@ ( get data stack pointer)
: sp! ( set data stack pointer)
: 'drop ( runtime drop)
: 'over ( runtime over)
: 'dup ( runtime dup)
: 'swap ( runtime swap)
: zless ( runtime zero less)
: um+ ( add with carry)
: 'nc ( no carry is 0)
: 'cy ( carry set is 1)
: 'xor ( runtime exclusive or)
: 'and ( runtime and)
: 'or ( runtime inclusive or)
: negate ( runtime negate)
: invert ( runtime invert)
: zeq ( runtime zero equals)
: '+ ( runtime +)
: '2/ ( runtime 2/)
: '2* ( runtime 2*)

{block 1314}
( e4th bitsy) | br


: @io = $31 ( --u) @p+ ! @ . ( ') push t'@io ( ') pshw ; | cr
( init io device 0-autobps n-fixedbps)
: !io = $34 ( u--) popw
: t!io = $35 ( u-) @p+ ! ! ; ( ') ] @p+ t'!io ; ( ')
: tx! = $37 ( c--) popw
: ttx! = $38 ( c-) @p+ ! ! ; ( ') ] @p+ - ; ( ')
: trx? = $3a ( -c'0) @p+ ! @ ; ( ') ] !p+ t'rx? ; ( ')
: rx? = $3c ( --c'0) trx? pshw ;

{block 1315}


{block 1316}
( e4 terminal 1of2 - serial i/o) | br


: getchar = $0 ( delay in'0 f - delay -char f) push over 2/ for . unext .. ( middle of start-bit) | cr
7 for ( 8-data bits) | indent
     over for . unext .. | indent
     $1ffff @b ( middle +/-) | indent
     over - and push and pop or | cr
2/ next | cr
2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ .. $ff and - dup | cr
begin drop @b -until drop pop ; | br


: putchar = $13 ( delay in'0 c - delay in'0) | cr
push over pop | cr
2* $3fe00 dup push - and pop or | cr
10 for ( 1-start, 8-data, 2-stop bits) | indent
     2 over over 2/ and or !b | indent
     over for . unext .. | cr
2/ next drop drop ; = $21

{block 1317}
( note. both tx and rx are completely in stock rs232 polarity, i.e. mark lo space hi, data low start low. ultimately we need to invert the whole thing for compatibility with s40 boot node conventions but for testing purposes we will leave it as is and invert the rs232 board.) | br


: getchar ( called after seeing leading edge of start bit. returns clean inverted character.) | br


: putchar ( takes a dirty octet of data and transmits it as startbit, eight data bits no parity one stop bit.)

{block 1318}
( e4 terminal 2of2 - bitsy commands) | br


: baud = $21 ( 0-d) - push ( space is 0'0000.0100'1) | cr
= $22 begin @b - -until ( at start-bit) | cr
= $23 begin @b -until ( at 1-bit) | cr
= $24 begin @b zif then - . -until ( at 0-bits) | cr
= $26 begin @b zif then . -until ( at stop-bit) | cr
pop - ( n) dup 2/ . + ( 1.5n) ; | br


: @io = $2a ( delay - delay in'0 0) | indent
     pop a! push dup or baud ! | indent
     pop pop dup dup or ; | indent
     ] begin baud
: !io = $2f ( delay in'0 u - delay 0 0) | indent
     until ( abandon old values)
: rx? = $30 ( delay - delay 0 0) 0 dup ; | br


: terminal = $32 ( delay in'0 x) | cr
begin drop @b - -if getchar then | indent
     - 2* 2* -if drop .. r--- ( bitsy) then | cr
-until ( delay in'0 -c) - putchar dup terminal ; = $3c

{block 1319}

: @io ( return the serial bit delay) | br


: !io ( sets nonzero baud rate delay over garbage. if zero, waits for a space character to autobaud with.) | br


: rx? ( test for received char) | br


: tx! ( send one character) | br


: terminal ( polling loop for character receive or send)

{block 1320}
( sdram address-bus) | cr
( copy command to address bus) | br

$aa org ]
: cmd ( c-) = $aa $3d555 ( nop.xxx) !b .. | indent
     @ ( sleeps) !b cmd ; | br

= $ad exit ( start is run in ide)
: start right a! data b! cmd ;

{block 1321}


{block 1322}
( sdram control-pins) | cr
( each word runs the requested rise..fall cycle 12+11 ticks per cycle is a 42ns period) | cr
$0 org ]
: nooop ( rfr-rfr) = $0 ( 'nooop') . .. !b | indent
     .. over over .. . . !b ;
: rcol1 ( rf-rfrf) = $4 . . !b | indent
     .. $2b .. !b ( transfer) | indent
     . $22e .. . . !b ; | cr
= $a $10 org ( 8-word page accessible to down port)
: cmmd ( rfr-rfr) = $10 ( '@p+ ! cmmd') !b | indent
     .. over over .. . . !b ;
: rcol ( rfr-rfr) = $13 ( '@p+ ! rcol') !b | indent
     over over .. rcol1 ;
: wcol ( rfr-rfr) = $15 ( '@p+ ! wcol') !b | indent
     $2003e $2002e .. !b | indent
     .. $3022b .. !b ( transfer) | indent
     $3023b !b .. . . !b | indent
     $2002e .. !b $2b !b ( recover) | indent
     .. over over .. . . !b ; | br

= $23 exit ( start is run in ide)
: start right a! io b! $2e ( cmd-fall) -d-- ;

{block 1323}


{block 1324}
( sdram data-bus) | br

( db@ isn't used with 7j chip!) | cr
$aa org ( called with 'db@' '...!p+')
: db@ ( -w) = $aa @ ; ( wakeup when data ready) | br

( db! called with '@p+ db!')
: db! ( w-) = $ab $15555 !b ( .. set output state) | indent
     ! ( wakeup when data taken)
: inpt = $ad $14555 !b ; ( restore input state) | br

= $af exit ( start is run in ide)
: start up a! io b! down push inpt ;

{block 1325}


{block 1326}
( sdram idle-loop) | cr
$aa org ]
: noop ( -) = $aa @p+ ! ; ( ') ] nooop ( ')
: cmd ( c-) = $ac $5a48 ! ! ; ( '@p+ ! cmmd') | cr

: idle ( m-m) = $ae @p+ ! .. ( ') nooop ( ') $8003 cmd noop 120 for ( 7.8us 42ns/ 5- is 181) | indent
     @p+ ! .. ( ') nooop ( ') | indent
     begin = $b7 @b and if | indent
     ( ...) @ .. @ ! ! ( user to ctrl) | indent
     ( ...) *next idle ; = $bc | indent
     ] then drop | cr
next @p+ ! .. ( ') nooop ( ') idle ; | cr

: init ( m-m) = $c0 ( run only at power-up/reset) | indent
     4761 for ( 200us 42ns/ 1-) noop next | indent
     noop $10400 ( pre.all) cmd noop | indent
     $8001 ( rfr.123) cmd noop noop | indent
     $8002 ( rfr.123) cmd noop noop | indent
     $21 ( std.mode) cmd noop noop | indent
     $4000 ( ext.mode) cmd noop idle ; | br

= $d8 exit ( start is run in ide)
: start $135 ( '-dl-) a! io b! | cr
$800 ( n13w?) dup dup dup dup dup dup | cr
dup dup dup init ;

{block 1327}


{block 1328}
( sdram user interface) | cr
$aa org ( user cmds+data from/to up or right)
: a2rc ( pa-pbc) = $aa dup ( 2* 16mw) push 2/ ( 32mw) | cr
2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ -if
: row! ( pr-pbc) = $af $7fff ( row.mask) and dup .. | cr
$18000 ( activate) or .. ! $5a48 ! .. ( '@p+ ! cmmd') $6000 ( bank.mask) and pop .. $3ff ( col.mask) and ; ] then over + row! ;
: sd@ ( pa-p) = $bb a2rc $28400 ( read+pre) or or | cr
! $5a4b ! .. ( '@p+ ! rcol') down b! .. | cr
@p+ !b @b ( ') @ !p+ .. ( ') pop b! !b ;
: sd! ( pa-p) = $c5 a2rc $20400 ( write+pre) or or | cr
! $5a4d ! .. ( '@p+ ! wcol') pop b! @b .. | cr
down b! .. @p+ !b !b ; ( ') ] @p+ db! ( ')
: poll ( ru-ru) = $cf io b! @b | cr
2* 2* -if push over .. r--- over pop then | cr
$800 and . if push .. ---u pop then | cr
drop poll ; | br

= $dc exit ( start is run in ide)
: start left ! 0 0 ( r.u) poll ;

{block 1329}
( configure for sdram wiring as follows) | cr
] 2* ( 16mw) push ( 2/ 32mw) [ for 16 mw wiring | cr
( 2* 16mw push) ] 2/ ( 32mw) [ for 32.

{block 1330}
( async ats interface) 0 org ]
: obit ( dwn-dw) = $0 !b over push delay ;
: word ( dw-d) = $2 leap drop leap drop leap drop drop ;
: obyt ( dw-dwx) = $6 then then then 3 obit drop 7 for dup 1 and 3 or obit drop 2/ next 2 obit ;
: -out = $11 ser-exec ( rdl-) ; = $12 | br


: ok = $12 $31416 word -out ;
: fet = $15 0
: pump ( n) for @+ word next -out ;
: stat = $1b 9 pump ;
: bstk = $1d @ push .. @ word pop dup push word .. ( @p+.push) $49ba ! 7 .. dup push ! .. @p+ ! .. ( /+) begin !p+ . . unext .. begin @ word .. next .. @p+ ! pop .. ( /+) pop @p+ ; ] .. ! -out ; = $2c

{block 1331}
( this code is loaded on top of ide boot node.)
: obit ( sends one bit 0-3/hi 1-2/low)
: word ( sends a word as) # 3 ( octets.)
: obyt ( sends and discards) # 8 ( lsb of w, lsb first, with one start bit hi and one stop bit low.)

{block 1332}


{block 1333}


{block 1334}


{block 1335}


{block 1336}


{block 1337}


{block 1338}


{block 1339}


{block 1340}


{block 1341}


{block 1342}
( smtm test) $32 org ]
: go a! $1557f !b $1556a !b . pop @p+ | indent
     ( ') @p+ dup 2/ . ( ') a ! ! $43 for | indent
     $3f !+ . unext | indent
     ( ') 2* a! push . ( ' ') begin @p+ !+ . unext ( ') | indent
     ( ') @p+ push ; ( ') ] ! warm ; | cr
# $12 $2a org ]
: r @p+ go ; ] r---
: d @p+ go ; ] -d--
: l @p+ go ; ] --l-
: u @p+ go ; ] ---u | cr
[ 0 org ( avoid node1) ] d r l
: path r l r l d l r l r d path ;

{block 1343}
( smtm test) | br

( steven's crawling memory tester)

{block 1344}
# 14 ( word ga144 creeper test frame 3/25/11) | cr
( see db007 for detailed discussion.) | br

$36 org ]
: focus = $36 ( jport) dup dup a! dup ! @p ! dup | cr
( ') @p b! . ! or !b ;
: creep = $3a # 67 dup !b push | cr
begin @p ! unext . = $3c | cr
( ') $3f push dup ( ') or a! | cr
( ') begin @b !+ unext = $c40 | cr

: wire begin @b ! @b ! @
: rip = $42 dup !b -until = $43 warm ; | cr
= $44 4 org ]
: test = $4 ( n1)

{block 1345}
( creeper input side data flow iio) | cr
( @p call to focus, creep, wire, rip, or) | cr
( anywhere in the test package from) # $4 ( to) # $35 | cr
( with any n1 on the stack) | br


: focus ( prepares to use neighbor thru) [ jport ( sets a forward and neighbor pc and b back. result is zero.)
: creep [ 67 ( returned as early sync. crawl to focused node, make it active, we become wire. copies) # 68 ( words to neighbor) | cr
( fallthrough after copy to wire must be at) = $40
: wire ( passes iio messages until result negative at which time this node and all before it return to warm.)
: rip ( argument and result must be negative to restore all nodes to warm state.)
: test ( can call any address from) # $4 ( to) # $35 ( and can do what it wants with) [ n1. ( result must be positive,) # 0 ( normally means ok.)

{block 1346}
( fill neighbor's memory fake test) | cr
( creeper) 1344 load ]
: ping = $45 @p ! ! . ( ' @p) @b 2/ ( !p) !b . | cr
@ !b ; = $48 exit ]
: why -1 . + down a! ! ; exit ]
: nulltest = $45 1 . + !b ; = $48 exit ]
: test = -10485760 ( n1) 63 @p ! . ( ') dup or a! @p | cr
! @p ! @p ( ') push ( ') begin a !+ unext . | cr
! dup dup or !b drop ; = -26214400

{block 1347}


{block 1348}
( extensive neighbor's memory test 005-035) | cr
$29 org | -cr : err [ $5 org ]
: test ( n1) @p ! @p dup ( ') $3f push dup dup | cr
! @p ! ( ') or dup a! . | cr
@p ! ( ') begin dup !+ unext . ( erased) | cr
for | cr
| cr
$19999 @p ! dup ( ') @p ! @ . | cr
! @p ! . ( ') !b @p ! | cr
@ or if = $13 pop err ; ] then = $14 ( test1) | cr
$cccc dup ! @p ( ') @ !b dup dup | cr
! @ or if = $19 pop err ; ] then = $1a ( 0 test2) | cr
@p ! . ( ') or ! . ( erased) | cr
| cr
drop @p ! @p ( ') dup ( 0 0) - # $3ffff ! $3e | cr
! @p ! ( ') @+ !b push # $0 | cr
@ - if = $22 pop err ; ] then = $23 ( test3) | cr
drop @p ! ( ') begin @+ !b unext . # $0 | cr
$3e for @ if pop pop
: err = $29 1 + !b ; ] then ( test4) | cr
drop next | cr
@p ! . . ( ') dup !+ . next ( erased) | cr
dup dup or !b ; = $31 ( 3/5/11) | cr


{block 1349}
( test tests neighbor's memory) | cr
( 19999 cccc test shorts to bits two bits away) | cr
( 3ffff) # $0 ( test shorts to bits one bit away) | cr
( tests for shorts between two addresses) | cr
( by reading) # 64 ( words after each) # $3ffff ( !) | cr


{block 1350}
# 1604 ( all nodes template) 15 node 0 org ]
: poll io b! @b ( mask) $aa00 = $3 and if ( drop) warm ; ] then drop ; = $6
: incr poll if 1 . + ; ] then drop 1 . + 1 ;
: run = $e -1 0 # 9999 99999 for # 9999 44999 for incr next next $3e a! !+ !+ $600d warm ;
: run = $1d 0 1 begin begin while poll 1 . + end then drop 1 . + 1 end ; | cr
= $2a 1604 bin

{block 1351}


{block 1352}
( erase flash) 0 org ]
: wait ( dw-dw) = $0 select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) = $4 select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) = $9 io b! ( fast) 5 ;
: fet ( ah al-d) = $c push push set ( read) $c00 cmd pop !8 pop 8obits !8 ;
: +wr ( -d) = $12 set ( wren+wrsr) $1804 2cmd | indent
     ( hi8 zero) dup !8 ( ebsy) $1c000 cmd ;
: ers32k = $18 +wr ( wren+ers32) $1948 2cmd | cr
0 !8 0 8obits !8 dup select ;
: ersall = $21 +wr ( wren+eras) $1980 2cmd | cr
dup select ;
: 16ibits ( d-db) = $25 dup 15 for | cr
rbit ibit - next $ffff and ;
: stash ( d-d) = $2c a push $3f a! 16ibits ! pop a! ; = $30

{block 1353}


{block 1354}
( hardware multiply test) 0 org +cy ]
: clc = $200 dup dup or dup . + drop ;
: d2* ( hl-hl) = $202 dup . + push dup . + pop ;
: um+ ( hln-hl) = $205 . + push dup dup or . + pop ; = $208 -cy ]
: h* ( nu-hl) = $8 dup a! dup or 17 for +* unext a ;
: abs ( n-n) = $c -if
: neg ( n-n) = $d - 1 . + then ; = $10 +cy ]
: u/mod ( hld-rq) = $210 clc neg
: -u/mod = $212 a! 17 push begin begin dup . + push dup . + dup a . + -if drop pop *next dup . + ; ] then over or or pop next dup . + ; = $21e -cy ]
: try = $21e right b! ( ba) @b @b h* ( r) @b um+ ( a) @b u/mod ( b) !b ( r) !b try ; = $226

{block 1355}

: h* ( is simplest multiply; first arg is a signed number and second, the multiplier, is a full) # 18 ( bit unsigned number.)
: try ( slaves this node to another by the port given. it expects to receive numbers b a r and calculates b*a+r then receives a and returns b and r. the multiply is done using the h* here which is why b is signed and a is unsigned.)

{block 1356}
( soft multiply test) 0 org +cy ]
: clc = $200 dup dup or dup . + drop ;
: d2* ( hl-hl) = $202 dup . + push dup . + pop ;
: um+ ( hln-hl) = $205 . + push dup dup or . + pop ;
: u* ( nn-hl) = $208 a! clc dup push dup or dup pop 17 for begin push d2* a -if 2* a! pop dup push . + push 0 . + pop pop *next drop ; ] then 2* a! pop next drop ; = $219 -cy ]
: abs ( n-n) = $19 -if
: neg ( n-n) = $1a - 1 . + then ;
: *. ( ff-f) = $1d over over or push abs swap abs u* d2* d2* drop pop -if drop neg ; ] then drop ; = $26 +cy ]
: u/mod ( hld-rq) = $226 clc neg
: -u/mod = $228 a! 17 push begin begin dup . + push dup . + dup a . + -if drop pop *next dup . + ; ] then over or or pop next dup . + ; = $233 ( -cy)
: try = $233 right b! @b @b u* @b um+ @b u/mod !b !b try ; = $23a

{block 1357}


{block 1358}
( multiply exerciser) $0 org ]
: dec ( n-n) -1 . + ;
: +or ( nn-n) over - and or ;
: try ( abr-ab bad) = $4 right a! ( 12033 !) push dup ! over ! pop dup ! push over ! dup @ or @ pop or +or ;
: test ( abr-abr) dup push try if pop ; ] then drop pop
: poll @b $200 and if up b! @b push ;' io b! then drop
: run ( abr-abr) = $1a if dec test ; ] then drop if dec over dec test ; ] then drop dec if ( -1) $1ffff over dec test ; ] then drop $600d ; = $29
: go = $29 io b! ( 20000) $1ffff ( -1) $1ffff over dec run ; | br


: -u/mod ( old) = $2f a! 17 push dup . begin begin | cr
+ push dup . + dup a . + -if drop pop dup *next + ; ] then over or or pop dup next + ; = $3c

{block 1359}

: try ( exercises slave node given a test vector. for the hardware version a is unsigned and b is signed. but the divide is unsigned so b is limited to the largest positive number.)

{block 1360}
( serdes test) $aa org ] data a! $3fffe dup ! up a! begin @ drop unext ( rdlu) [ 0 org ]
: try io b! $20000 !b $147 a! 0 10000 for 1 + dup a! next ;
: start @ io b!
: test $2aaaa @b or ! test . . . . down a! . . start

{block 1361}


{block 1362}
( serdes test) # 2 $aa org ] data a! $33333 dup ! up a! $20000 !b begin dup . . . . . . . . . . . . . . . . . . . . . ! unext . . . . . . .

{block 1363}


{block 1364}
( spi flash writer michael + greg 2.1) 0 org ]
: 2o ( dw-dw') = $0 obit 2* obit ;
: wait ( dw-dw) = $2 select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) = $6 select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) = $b io b! ( fast) 5 # 20 ;
: fet ( ah al-d) = $e push push set ( read) $c00 cmd pop !8 pop 8obits !8 ;
: +wr ( -d) = $14 set ( wren+wrsr) $1804 2cmd | indent
     ( hi8 zero) dup !8 ( ebsy) $1c000 cmd ;
: aaip ( d-d) = $1a $2b400 wait !8 ;
: x8p ( hln-d asrc) = $1d +wr ( wren+aaip) $1ab4 2cmd | cr
drop push push push set pop !8 pop 8obits | cr
!8 ahead begin aaip [ swap ] then 7 for | indent
     pop dup push push @+ | indent
     begin 2o 2* next push aaip pop | indent
     7 pop dup push or push | indent
     begin 2o 2* next drop next next | cr
( wrdi+dbsy) $1200 wait 2cmd -++ !b rdl- ; = $3b
: ers32 = $3b ( h-dd +wr wren+ers32) # $1948 ( 2cmd) | cr
( over 8obits 8obits !8 dup select ;) = $3b

{block 1365}
( run by an adjacent node through a port.) | cr
] $ 24 bit addresses ( are represented in two) # 18 ( bit words. for continuous bit sync, all operations must start on) # 0 ( mod) # 18 ( byte boundaries.) | cr
[ high ( word contains the most significant) # 8 ( bits of the address shifted left) # 10 ( bits.) | cr
low ( word contains the least significant) # 16 ( bits shifted left two bits.) | br


: x8p ( writes) [ n ( words into flash starting at address whose) high ( and) low ( parts are given. the data are read from wherever) a ( points; to feed a stream through a port,) a ( must be focused to the port before starting.) | br


: fet ( starts a read operation)
: 18ibits ( reads one word; take care with) [ 'd'

{block 1366}
( take adc data) 0 org ]
: sam+ ( -n) = $0 # $155 $2155 # $6155
: s+- ( k-n) io b! !b up b! !b @b ;
: sam- ( -n) = $6 # $955 $2955 # $6955 s+- ; | br


: sam = $8 $20 a! sam+ sam- 11 2* for | cr
push sam+ dup - pop . + ( !+) push | cr
push sam- dup - pop . + pop + !+ next ; = $16 | br

exit ] sam+ drop

{block 1367}
( this block supports taking of data manually for a/d transfer function. to use it, put a/d in the desired mode by editing the constants in sam+ and - then set desired voltage and execute sam. you will find a sequence of samples stored in ram at) # 32 | br

( original version sampled each half cycle of the incoming clock.)

{block 1368}
( generate dac waves) 0 org ]
: dly = $0 100 for unext ;
: sano ( n-n) $3ffdf and ; ] $10 or ;
: tri ( n) = $7 push $155 0 begin | cr
510 for over or dup sano !b | indent
     dly over or 1 . + next | cr
510 for over or dup sano !b | indent
     dly over or -1 . + next next drop drop ;
: try = $1c io b!
: sing = $1e 1000 tri
: poll = $20 @b $2000 and if down b! @b push ;' io b! then drop sing ;
: haul = $29 io b! -1 dup push dup push dup push dup push dup push dup push dup push dup push push $155 $aa over over over over over over ( /) dup dup
: spin = $36 begin !b ( . .) unext ( !b !b !b !b !b !b !b !b) spin ; = $37 exit | cr
] $155 $1d5 $55 $d5 $aa $d5 $55 $1d5 ( /)

{block 1369}


{block 1370}
( spi flash) # 8 ( bits) 0 org ]
: 2o ( dw-dw') = $0 obit 2* obit ;
: wait ( dw-dw) = $2 select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) = $6 select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) = $b io b! ( fast) 5 ;
: fet ( ah al-d) = $e push push set ( read) $c00 cmd pop !8 pop 8obits !8 ;
: 16ibits ( d-db) = $14 dup 15 for | cr
rbit ibit - next $ffff and ;
: +wr ( -d) = $1b set ( wren+wrsr) $1804 2cmd | cr
( hi8 zero) dup !8 ( ebsy) $1c000 cmd ;
: aaip ( d-d) = $21 $2b400 wait !8 ;
: ers = $24 +wr ( wren+eras) $1980 2cmd dup select ;
: wp ( hln-d asrc) = $28 +wr ( wren+aaip) $1ab4 2cmd | cr
drop push push push set pop !8 pop 8obits | cr
!8 ahead begin aaip [ swap ] then @+ 8obits !8 | cr
next ( wrdi+dbsy) $1200 wait 2cmd -++ !b rdl- ;
: stash ( d-d) = $3b a push $3f a! 16ibits ! pop a! ; = $3f

{block 1371}
( run by an adjacent node through a port.) | cr
] $ 24 bit addresses ( are represented in two) # 18 ( bit words. for continuous bit sync, all operations must start on) # 0 ( mod) # 18 ( byte boundaries.) | cr
[ high ( word contains the most significant) # 8 ( bits of the address shifted left) # 10 ( bits.) | cr
low ( word contains the least significant) # 16 ( bits shifted left two bits.) | br


: wp ( writes) [ n ( words into flash starting at address whose) high ( and) low ( parts are given. the data are read from wherever) a ( points; to feed a stream through a port,) a ( must be focused to the port before starting.) | br


: fet ( starts a read operation)
: 16ibits ( reads one word; take care with) [ 'd'

{block 1372}
# 1600 ( ide via async boot) 708 node 0 org ]
: obit ( dwn-dw) = $0 !b over push delay ;
: word ( dw-d) = $2 leap drop leap drop leap drop drop ;
: obyt ( dw-dwx) = $6 then then then 3 obit drop 7 for dup 1 and 3 or obit drop 2/ next 2 obit ;
: -out = $11 ser-exec ( rdl-) ; = $12 | br


: ok = $12 $31416 word -out ;
: fet = $15 0
: pump ( n) for @+ word next -out ;
: stat = $1b 9 pump ;
: bstk = $1d @ push .. @ word pop dup push word .. ( @p+.push) $49ba ! 7 .. dup push ! .. @p+ ! .. ( /+) begin !p+ . . unext .. begin @ word .. next .. @p+ ! pop .. ( /+) pop @p+ ; ] .. ! -out ; | cr
= $2c 1600 bin

{block 1373}


{block 1374}
# 1601 ( ide via sync boot) 300 node 0 org ]
: 1bit ( wx-w'x) drop -if 3 ahead [ swap ] then 2 | cr
then !b 2* dup ;
: word ( w) = $6 8 dup for begin drop @b -until 1bit begin drop @b - -until 1bit next drop drop ;
: +out ( x) = $f begin drop @b - -until drop 3 !b ;
: -out ( x) = $13 begin drop @b -until | cr
drop 2 !b 1 !b ser-exec ; | br


: ok = $18 dup +out $31416 word dup -out ;
: fet = $1c 0
: pump ( n) dup +out for @+ word next dup -out ;
: stat = $23 9 pump ;
: bstk = $25 +out @ dup push . @ word word ( / @p+.push) $49ba ! 7 . ( /) dup push ! . ( /) @p+ ! . . ( /+) begin !p+ . . unext ( /) begin @ word ( /) next ( /) @p+ ! pop . ( /+) pop @p+ ; ( /) ] ! -out ; | cr
= $34 1601 bin

{block 1375}


{block 1376}
# 1602 ( ide wire node) 17 node 0 org ]
: fet = $0 @p+ !b @ . fet !b @b ! ; = $3 5 org ]
: sto = $5 @p+ !b @ . sto !b @ !b ; = $8 $a org ]
: ins = $a @p+ !b @ . ins !b ; = $d $d org ]
: psh = $d @p+ !b @ . psh !b ; = $10 $10 org ]
: stk = $10 @p+ !b . . stk 9 for @b ! unext ; | cr
= $15 1602 bin

{block 1377}


{block 1378}
# 1603 ( ide last guy) 16 node $1e org ]
: focus ( i0) = $1e @p+ !b !b ; ( /) ] focus ; 0 org ]
: fet = $0 @p+ focus ( /+) @p+ a! @ !p+ ( /) @ !b @b @p+ ( /+) ; ( /) ] !b ! ;
: sto = $5 @p+ focus ( /+) @p+ a! . @p+ ( /) @ !b @ . ( /) !b @p+ !b ; ( /+) ] ! ;
: ins = $a @ focus ; ( /) ] ins ins
: psh = $d @p+ focus ( /+) @p+ ; ( /) ] @ !b ;
: stk = $10 @p+ focus ( /+) !p+ dup push !p+ ( /) @b @b ! dup ( /) ! ( @p+.push) $49ba !b 7 ( /) dup push !b . ( /) @p+ !b ( /+) begin !p+ . . unext ( /) begin @b ! unext . ( /) @p+ !b !b ; ( /+) ] pop @p+ ; | cr
( if past size-2 not ok-) = $1c 1603 bin

{block 1379}


{block 1380}
( common) | , $155 org | * ( bomb) | ... $145 org | *
: ---u | , [ $175 org | *
: --l- | ... [ $165 org | *
: --lu | , [ $115 org | *
: -d-- | ... [ $105 org | *
: -d-u | , [ $135 org | *
: -dl- | ... [ $125 org | *
: -dlu | , [ $1d5 org | *
: r--- | ... [ $1c5 org | *
: r--u | , [ $1f5 org | *
: r-l- | ... [ $1e5 org | *
: r-lu | , [ $195 org | *
: rd-- | ... [ $185 org | *
: rd-u | , [ $1b5 org | *
: rdl- | ... [ $1a5 org | *
: rdlu | ,

{block 1381}


{block 1382}
( polynomial approximation)
: poly ( xn-xy) pop a! push @+ a begin | indent
     push *. pop a! @+ + a next push ;

{block 1383}

: poly ( xn-xy) | cr
( evaluation of chebyshev polynomials using) | cr
( the horner scheme.) | br

( x is the input value. n is the length of) | cr
( the coefficient table minus 2. coefficient) | cr
( table follows inline, and execution) | cr
( continues after the final table entry. x is) | cr
( left on the stack under the result, y.) | br

( for example...)
: cos ( f-f') | cr
( hart 3300) | cr
( -0.0043 0.0794 -0.6459 0.5708) | indent
     2* 2* . triangle dup *. 2 poly | indent
     [ -281 , 5203 , -42329 , 37407 , | indent
     ] push drop pop *. + ;

{block 1384}
( interpolate)
: interp ( ims-v) dup push push over | indent
     begin 2/ unext a! | indent
     and push @+ dup @+ - . + - | indent
     pop a! dup dup or | indent
     begin +* unext push drop pop . + ;

{block 1385}

: interp ( ims-v) | cr
( to determine values for m and s ...) | cr
( let l be number of meaningful input bits.) | cr
( let n be power of 2 where 2**n + 1 is the) | cr
( number of table entries.) | br

( s equals l-n-1) | cr
( m equals 2** l-n - 1) | br

( so for example if you have an 8 bit adc,) | cr
( l equals 8. let n equal 2 for a 5 entry table. the table is expected to be at address 0,) | cr
( so to represent 0 to 1800 millivolts...) | br

[ $ 0 org $ 0 , $ 450 , $ 900 , $ 1350 , $ 1800 , | cr

: mv ( i-n) $3f $ 5 interp ; | br

0 mv ( gives) 0 | cr
128 mv ( gives) 900 | cr
256 mv ( gives) 1800 | cr
( and intermediate values are interpolated.)

{block 1386}
( fir or iir filter)
: taps ( yxc-y'x') pop a! push begin | indent
     @+ @ push a push *.17 pop a! | indent
     push !+ pop . + pop next @ a! ;

{block 1387}

: taps ( yxc-y'x') | cr
( for example...) | br


: fir ( yx-y'x') 15 taps [ -53 , 0 , 2276 , 0 , 382 , 0 , -1706 , 0 , -1158 , 0 , 2014 , 0 , 2406 , 0 , -1977 , 0 , -4206 , 0 , 1289 , 0 , 6801 , 0 , 678 , 0 , -11109 , 0 , -6250 , 0 , 23531 , 0 , 54145 , 0 , | br

( 16 taps, 16 coefficients with intermediate) | cr
( storage interleaved.)

{block 1388}
( routing; called with 'a relay')
: relay ( a) pop a! @+ push @+ zif | indent
     drop ahead ( done) [ swap ] then | indent
     pop over push @p+ ( ') a relay ( ') | indent
     !b !b !b begin @+ !b unext
: done then a push a! ;

{block 1389}
( relay moves a port executable packet down) | cr
( a sequence of nodes linked by their b) | cr
( registers. the packet consists of a 1-cell) | cr
( index, a 1-cell count) less one ( of body) | cr
( size, and the body cells.) | br

( a packet) may ( be started from memory within) | cr
( a node, or it may simply be fed to a port.) | br

( relay assumes that b points to the next) | cr
( node in the chain. uses one return stack) | cr
( location and four data stack locations.) | cr
( it must be at the same location in every) | cr
( node.)

{block 1390}
( multiply)
: *.17 ( a b - a a*b) a! 16 push dup dup or | indent
     begin +* unext - +* a -if | indent
     drop - 2* ; ] then drop 2* - ;

{block 1391}

: *.17 ( multiplies a fraction by a fraction,) | cr
( giving a fraction, or an integer by a) | cr
( fraction, giving an integer. note that f1) | cr
( is left in s to be ignored, dropped, or) | cr
( reused. note that the definition of) *. | cr
( contains a call to this word.) | br

( 17 bit fractions --- s.i ffff ffff ffff ffff)

{block 1392}
( lshift rshift)
: lsh push begin 2* unext ;
: rsh push begin 2/ unext ;

{block 1393}


{block 1394}
( triangle)
: triangle ( x-y call with; 2* 2* triangle) | indent
     $10000 over -if drop . + ; ] then | indent
     drop - . + - ;

{block 1395}

: triangle ( assuming an angle expressed as a) | cr
( 16 bit fraction of a revolution,) | cr
[ 2* 2* triangle ( produces a triangle wave) | cr
( approximation to the cosine of that angle.)

{block 1396}
( fractional multiply)
: *. = $b7 ( f1 f2 - f1 f1*f2) *.17 | indent
     a 2* -if drop - 2* - ; ] then | indent
     drop 2* ;

{block 1397}

: *. ( multiplies a fraction by a fraction,) | cr
( giving a fraction, or an integer by a) | cr
( fraction, giving an integer. note that f1) | cr
( is left in s to be ignored, dropped, or) | cr
( reused.) | br

( 16 bit fractions --- si. ffff ffff ffff ffff)

{block 1398}
( divide) | cr
+cy = $2d3 ( enter ea mode)
: clc dup dup or dup . + drop ;
: --u/mod = $2d5 clc
: -u/mod ( hld-rq) = $2d6 a! 17 push begin begin | indent
     dup . + . push dup . + | indent
     dup a . + -if | indent
     drop pop *next dup . + ; ] then | indent
     over or or . pop next dup . + ; | cr
-cy = $e1 ( exit ea mode)

{block 1399}

: clc ( clears the carry bit for addition in) | cr
( ea mode.) | br

( the following defines u/mod in ram ...) | cr

: u/mod ( hld-rq) - 1 . + --u/mod ; | br

( if the divisor is a constant, just negate) | cr
( it at edit or compile time.)

{block 1400}
( f18 compiler) :var h [0x16] :var ip [0x15] :var slot [0x4] :var call? [0x6000] :var cal [0x102f9669] :var com [0x6c] macro ]
: !7 $bd0489 3, $fffffffc , [compile] drop ;
: 2*s ?lit $e0c1 2, 1, ;
: call ( nn) [compile] ?dup $b8 1, , $e9 1, [ cal ] @ here 3 + - + , ; forth ]
: swap swap ;
: eras ( nn) push $61fc ( call a9) swap block pop ( blks) fill ;
: node's ( -n) [ com ] @ 2* $8000 + ;
: memory ( n-a) [ $240 - ] and node's block + ; | cr
$8000 nnc 2 * blks eras ]
: -org ( n) dup [ h ] ! [ ip ] ! 0 [ call? ] ! | *
: break 4 [ slot ] ! ;
: p, ( n) [ h ] @ memory ! [ h ] @ 1 over + over or $7f and or [ h ] ! ;
: s4 [ h ] @ [ ip ] ! 13 2*s dup [ call? ] ! p, 1 [ slot ] ! ;
: s0 13 2*s
: sn dup [ call? ] ! [ ip ] @ memory +! 1 [ slot ] +! ;
: s1 8 2*s sn ;
: s2 3 2*s sn ;
: s3 dup 3 and drop if 7 sn s4 ; ] then 4 / sn ;
: i, [ slot ] @ jump s0 s1 s2 s3 s4

{block 1401}
( f18 target compiler) includes support for f18a addressing see 1404 ]
: h ( address of next available word in target memory here)
: ip ( address of current instruction word)
: slot ( next available instruction slot)
: call? ( was last instruction a call ?)
: call a ( compile a call)
: eras ( fills f18 memory with call 155 number)
: 2*s n ( shift left n bits)
: node's ( target node's starting memory block no.)
: memory n-a ( host address for target memory)
: -org n ( set current target memory location, see) | ... ( next block for true directive.)
: break ( break in emulator only)
: p, n ( compile pattern into target memory)
: s0-s4 ( assemble opcode into slot 0-3)
: i, ( assemble opcode into next slot *note** simple code jump table using) [ jump

{block 1402}
( target)
: cnt 2/ -1 + ;
: defer ( -b) pop ;
: execute ( b) push ;
: f! ( bn) [ sp ] + ! ;
: f@ ( n-b) [ sp ] + @ ;
: class ( b) [ last 1 + ] ! ;
: empty empt
: host 0 class [ 6 f@ ] nop [ 4 f@ ] nop [ 13 f@ ] nop
: functions ( bbb) 13 f! 4 f! 6 f! ;
: . $1c i, ; ( nop)
: hhere here ;
: .. [ slot ] @ 4 or drop if . .. ; ] then 0 [ call? ] ! ;
: here .. [ h ] @ $3ff and ; hhere ]
: report ( here) [ h ] @ [ slot ] @ 3 and 1024 * or | , 32 * [ 13 16 + ] + !7 ;
: org ( n) .. -org ;
: f18 ( b) 1 f@ [ 0 + ] functions ;
: +cy here $200 over - and or org ;
: -cy here [ $200 - ] and org ;
: await [ com ] @ idle [ cal ] @ execute ;

{block 1403}

: defer -a ( byte address of the compiled code that follows -- used for forward referencing)
: execute a ( code at this address)
: f! an ( store address of code executed when a word with this function is interpreted)
: f@ n-a ( fetch address of function code)
: class a ( store address of code to be executed for each word subsequently defined)
: empty ( redefine empty to restore altered functions)
: host ( change context back to colorforth)
: functions aa ( store functions in kernel specific way)
: c18 ( save green word and number functions. set green short-number to n, compile to call. target words are executed to assemble instructions)
: . ( nop used to fill instruction words)
: .. ( fills rest of word with nops)
: here -a ( starts new instruction word. leaves target address as number)
: org ( sets compilation address safely.)
: await ( generates call to node's idle ports.)

{block 1404}
( f18 jump instructions)
: 9same ( axa-ax) push over pop - or [ $200 ] and drop ;
: j3 .
: j0 i, [ ip ] @ memory +! break ;
: j1 [ h ] @ 9same if over $100 and drop if swap $ff and swap j0 ; ] then then . . j3 ;
: j2 over $155 or [ h ] @ or $3f8 and drop if . j3 ; ] then swap 7 and swap j0 ;
: -adr ( an) swap $155 or swap [ slot ] @ jump j0 j1 j2 j3 j0
: adr ( n-n) [ slot ] @ 3 or drop if i, [ ip ] @ 8 * [ h ] @ [ ip ] @ negate + + 8 * [ slot ] @ + break ; ] then . adr ;
: @h ( n-a) 8 /mod + ;
: -rng -range abort ;
: f3 ( an) over $155 or over @h or $2f8 and drop if | , -rng ; ] then swap 7 and swap 8 / memory +! ;
: f2 dup @h 9same if over $100 and drop if swap $ff and swap
: f1 8 / memory +! ; ] then then -rng ;
: then ( n) here $155 or swap 8 /mod swap jump f1 f1 f2 f3

{block 1405}
the f18a uses adr bit 9 for mode; 8 for i/o; 7 for rom. incrementer maintains bits 0-6, rest are left alone except for return and slot 0 jumps. | br


: 9same ( is true if the two addresses match in bit 9 - the extended arithmetic mode bit.)
: -adr an ( assembles jump to known address)
: adr n-a ( assembles forward jump in slot 0,1,2. value left on stack is instr addr * 64 + here-ip + slot.)
: @h ( given that vlue value / 8 returns p at time the jump executes.)
: then a ( insert address for forward jump)

{block 1406}
( complex instructions)
: def defer here [compile] call ;
: call defer ( a) 3 -adr ; call cal ! ]
: ; [ call? ] @ dup $6000 or drop if dup $300 or drop if dup $18 or drop if 0 and i, break ; ] then then then dup 2/ and negate [ ip ] @ memory +! ;
: -if ( -a) 7 adr ;
: if ( -a) 6 adr ;
: -until ( a) 7 -adr ;
: until ( a) 6 -adr ;
: -while ( a-aa) 7 adr swap ;
: while ( a-aa) 6 adr swap ;
: zif ( -a) 5 adr ;
: *next ( aa-a) swap
: next ( a) 5 -adr ;
: unext ( a) 4 i, drop ;
: n defer 8 f@ execute
: lit 8 i, $3ffff and ( ok in slot 3)
: , ( n) $15555 or p, ;
: for $1d i,
: begin here ;
: ahead ( -a) 2 adr ;
: end ( a) 2 -adr ;
: leap ( -a) 3 adr ;

{block 1407}

: def -a ( deferred to class. executed for every target definition to compile host code that compiles target call)
: call a ( compile target call)
: ; ( will be executed as a target word. the pentium macro has precedence while compiling)
: if/-if ( leaves address of jump on stack)
: -until a ( jump if positive to) begin
: zif ( forward) next ( decrements r and jumps if r! else pops and falls thru)
: next/for
: n ( executed for green short-numbers. all 18-bit target numbers are short. executes white short-number to put interpreted number on stack. then assembles literal instruction with number in next location. inverted for rom)
: , n ( compile number into target memory)
: ?lit -n ( retrieve previously compiled number)
: begin -a ( starts new instruction word. leaves properly formatted target address)
: ahead ( compiles fwd ref jump resolve w/then)
: leap ( like ahead but compiles a call)

{block 1408}
( instructions)
: target n f18 def class ;
: ex | -cr : ;' 1 i, break ;
: rx
: @p | -cr : @p+ 8 i, ;
: @+ 9 i, ;
: @b $a i, ;
: @ $b i, ;
: !p | -cr : !p+ $c i, ;
: !+ $d i, ;
: !b $e i, ;
: ! $f i, ;

{block 1409}
( words being redefined for the target computer. these host words can no longer be executed. although pentium macros take precedence during compilation, they will no longer be used.)
: f18 ( instructions)
: 0 ( ;) ....8 ( @p) .10 ( +*) ..18 ( dup)
: 1 ( ex) ...9 ( @+) .11 ( 2*) ..19 ( pop)
: 2 ( j) ....a ( @b) .12 ( 2/) ..1a ( over)
: 3 ( call) .b ( @) ..13 ( -) ...1b ( a)
: 4 ( unext) c ( !p) .14 ( +) ...1c ( .)
: 5 ( next) .d ( !+) .15 ( and) .1d ( push)
: 6 ( if) ...e ( !b) .16 ( or) ..1e ( b!)
: 7 ( -if) ..f ( !) ..17 ( drop) 1f ( a!)

{block 1410}
( port literals and constants)
: right ( .) [ $1d5 ] lit ; ( 0101111111 register bits)
: down ( ..) [ $115 ] lit ; ( 0110111111)
: left ( ..) [ $175 ] lit ; ( 0111011111)
: up ( ....) [ $145 ] lit ; ( 0111101111)
: io ( ....) $15d lit ; ( 0111110111)
: ldata ( .) $171 lit ; ( 0111011011)
: data ( ..) $141 lit ; ( 0111101011 port calls)
: warp ( ..) [ $157 ] lit ; ( 0111111101)
: center $1a5 lit ;
: top $1b5 lit ;
: side $185 lit ;
: corner $195 lit ;
: /mod /mod ;
: spispeed 497 ( 0) lit ; $0 ( 24-bit adrs) 4 * 262144 /mod ( al ah) $3 ( read cmd) 256 * + 4 * ]
: spicmd ( c.ah) [ 0 + ] lit ;
: spiadr ( al) [ 0 + ] lit ;

{block 1411}


{block 1412}
( more instructions)
: +* $10 i, ; ( slot 3 ok)
: 2* $11 i, ;
: 2/ $12 i, ;
: - $13 i, ;
: + $14 i, ; ( slot 3 ok)
: and $15 i, ;
: or $16 i, ; ( exclusive-or)
: drop $17 i, ;
: dup $18 i, ; ( slot 3 ok)
: pop $19 i, ;
: over $1a i, ;
: a $1b i, ;
: push $1d i, ;
: b! $1e i, ;
: a! $1f i, ;

{block 1413}

: o ( replaces top-of-stack with 0. f18 instructions can't be used in macros - forth macros take precedence)

{block 1414}


{block 1415}


{block 1416}


{block 1417}


{block 1418}
( math rom anywhere) 0 kind | br

$a1 org | cr
= $a1 1388 load ( relay) | cr
= $a9 | -cr : warm await ; | br

$b0 org | cr
= $b0 1390 load ( multiply) | cr
= $b7 1396 load ( fractional multiply) | cr
= $bc 1386 load ( taps) | cr
= $c4 1384 load ( interpolate) | cr
= $ce 1394 load ( triangle) | cr
= $d3 1398 load ( -u/mod) | br

$aa org | cr
= $aa 1382 load ( polynomial approximation) | cr
= $b0

{block 1419}


{block 1420}
( serdes boot top/bot) 6 kind $aa reset | br

$a1 org | cr
= $a1 1388 load ( relay) | cr
= $a9 | -cr : warm await ; | cr

: cold = $aa $3141 a! $3fffe dup ! rdlu cold ; | br

= $b0 1390 load ( multiply) | cr
= $b7 1396 load ( fractional multiply) | cr
= $bc 1386 load ( taps) | cr
= $c4 1384 load ( interpolate) | cr
= $ce 1394 load ( triangle) | cr
= $d3 1398 load ( -u/mod) | cr
= $e1

{block 1421}


{block 1422}
( sync serial boot side) 2 kind $aa reset | cr
# $bf $be org | -cr : sget | cr
[ $a1 org | cr
= $a1 1388 load ( relay) | cr
= $a9 | -cr : warm await ; | cr

: cold = $aa $31a5 a! @ @b . . -if ( 0pin) | cr
$3fd85 ( 'rd-u 3fc00 +) dup push dup begin | cr
drop @b . -if ( /pin) *next [ swap ] then | cr
$185 ( 'rd-u) push drop push ; ] then
: ser-exec = $b6 ( x-x) sget push sget a! sget
: ser-copy = $b9 push zif ; ] then | cr
begin sget ( push sget pop !+) !+ next ;
: sget = $be ( -4/3-w) dup leap leap
: 6in = $c0 then then leap leap
: 2in = $c2 then then 2* 2* dup begin | cr
. drop @b . - -until - 2 and dup begin | cr
. drop @b . . -until 2 and 2/ or or ; | br

= $cc 1390 load ( multiply) | cr
= $d3 1386 load ( taps) | cr
= $db 1394 load ( triangle) | cr
= $e0

{block 1423}
( sync serial boot side) | br


: ser-exec ( reads and processes a boot frame.)
: ser-copy ( receives) [ n ( words at a, nop if n zero.) | cr

: sget ( receives) # 18 ( bits, first bit on falling clock edge, second bit on rising, and so on. ends with clock line high. data line must be stable by the time clock edge is seen. spins the whole time, no suspension.)

{block 1424}
( async serial boot top/bot) 1 kind $aa reset | cr
# $cf $cb org | -cr : 18ibits | cr
[ $a1 org | cr
= $a1 1388 load ( relay) | cr
= $a9 | -cr : warm await ;
: cold = $aa $31a5 ( 'rdlu) a! @ @b .. -if
: ser-exec = $ae ( x-d) 18ibits drop push . | cr
18ibits drop a! . 18ibits
: ser-copy = $b3 ( xnx-d) drop push zif ; | cr
] then begin 18ibits drop !+ next ; | cr
] then drop $1b5 ( 'rdl-) push push ;
: wait = $bb ( x-1/1) begin . drop @b -until . drop ;
: sync = $be ( x-3/2-d) dup dup wait or - push | cr
begin @b . -if . drop *next await ; | cr
] then . drop pop - 2/ ;
: start = $c5 ( dw-4/2-dw,io) | cr
dup wait over dup 2/ . + push
: delay = $c8 ( -1/1-io) | cr
begin @b . -if then . drop next @b ; | br

= $cb 1426 load ( 18ibits) | cr
= $d9 1392 load ( lsh rsh) | cr
= $dd

{block 1425}
( async serial boot.) | cr

: cold ( reads) # 4 ( ports, falls thru if pin high. else assumes a focusing call received, simulates its execution as though from warm.) | br


: ser-exec ( reads and processes a boot frame.)
: ser-copy ( receives) [ n ( words at a, nop if n zero.) | cr

: delay ( waits one bit time and samples io. enter via jump with) [ d ( in r.)
: wait ( waits for input pin to be high.)
: start ( waits for rising edge of a normally start bit, delays 1.5 bit times and samples io.) | br


: sync ( waits for rising edge then measures high time, designed to be) # 2 ( bit-time start, followed by falling edge. returns) [ d ( for) # 1 ( bit time. times out after approx) # 3 ( ms, going warm.)

{block 1426}
( more async serial)
: 18ibits = $cb ( x-4/6-dwx) | indent
     sync sync dup start leap ( 2bits) leap
: byte = $d0 then drop start leap
: 4bits = $d2 then leap
: 2bits = $d3 then then leap
: 1bit = $d4 ( nw,io-nw,io) then | indent
     push 2/ pop over or | indent
     $20000 and or over push delay ; | cr
= $d9

{block 1427}


{block 1428}
( spi boot top/bot) 4 kind $aa reset host ]
: --- [ $2a ] lit ; ( do, ce-, clk)
: --+ [ $2b ] lit ;
: +-- [ $3a ] lit ;
: +-+ [ $3b ] lit ;
: -++ [ $2f ] lit ; target | cr
$a1 org 1388 load ( relay) | br

$c2 org ]
: 8obits ( dw-dw') 7 for leap ( obit) 2* *next ;
: ibit = $c7 ( dw-dw') | indent
     @b . -if drop - 2* ; ] then drop 2* - ;
: half = $ca ( dwc-dw) !b over for . . unext ;
: select = $cc ( dw-dw) -++ half --+ half ;
: obit = $d0 ( dw-dw) then | indent
     -if +-- half +-+ half ; ] then
: rbit = $d5 ( dw-dw) --- half --+ half ;
: 18ibits = $d9 ( d-dw) dup 17 ( for) push
: ibits begin rbit ibit - next ; | cr

: u2/ 2/ $1ffff and ; = $e1 | cr
$a9 org | cr
= $a9 | -cr : warm await ; | cr
= $aa 1430 load ( the rest) | cr
= $c1

{block 1429}
( clock management is mode 3, high when idle.) | , | ,
: ibits ( is entered by jump with count already on return stack. no rom effect to adding this.)

{block 1430}
( more spi)
: cold = $aa @b - .. [ $1b5 ( 'rdl-) ] -until | indent
     spispeed spiadr push spicmd
: spi-boot = $b0 ( dly adrh . adrl - dly x) | indent
     select 8obits 8obits | indent
     drop pop . 8obits 8obits
: spi-exec = $b6 ( dx-dx) drop 18ibits | indent
     $1e000 . + [ $1b5 ( 'rdl-) ] -until | indent
     push 18ibits a! 18ibits
: spi-copy = $bc ( dn-dx) push zif ; ] then begin | indent
     18ibits ( push 18ibits pop !+) !+ next dup ; = $c1 ( was) # $c2

{block 1431}
( more spi) | br

( spi-copy reads one word per loop and the loop counter is the actual number of words being) | cr
( sent ie a count of zero means no words sent)

{block 1432}
( analog) 0 kind | br

$a1 org | cr
= $a1 1388 load ( relay) | cr
= $a9 | -cr : warm await ; | br

$b0 org | cr
= $b0 1390 load ( multiply) | cr
= $b7 1396 load ( fractional multiply) | cr
= $bc 1434 load ( -dac) | cr
= $c4 1384 load ( interpolate) | cr
= $ce 1394 load ( triangle) | cr
= $d3 1398 load ( -u/mod) | br

$aa org | cr
= $aa 1382 load ( polynomial approximation) | cr
= $b0

{block 1433}


{block 1434}
( dac)
: -dac ( legacy entry name below)
: dac27 = $bc ( mcpaw-mcp) dup push push | indent
     over pop - . + push push $155 | indent
     pop over or a | indent
     begin unext !b . | indent
     begin unext !b !b ;

{block 1435}


{block 1436}
( 1-wire) 3 kind $aa org | br

$9e org ]
: rcv ( s-sn) = $9e a push dup dup a! 17 for begin
: bit = $a1 @ drop @b -if | indent
     drop - 2* - *next pop a! ; ] then | indent
     drop 2* next pop a! ; = $a8 | br

$a9 org ]
: warm = $a9 await ;
: cold = $aa left center a! . io b! | indent
     dup dup $b7 ( rest) dup push push 16 push | indent
     @ drop @b [ $185 ( side) ] -until | indent
     drop a! . bit ; = $b7 ( rest) | indent
     ] push rcv a! rcv push zif ; ] then | indent
     begin rcv !+ next ; = $be | br

= $be 1394 load ( triangle) # 5 | cr
= $c3 1390 load ( multiply *.17) # 7 | cr
= $ca 1396 load ( fractional multiply *.) # 5 | cr
= $cf # 1384 ( load interpolate interp) # 10 | cr
= $cf 1398 load ( -u/mod) # 14 | cr
= $de ( equals) # $9e

{block 1437}


{block 1438}
( null rom anywhere) 0 kind | br

$a9 org | cr

: warm = $a9 await ;

{block 1439}
( default code for null rom, or for special rom to be loaded out of sequence.) | br


: warm ( is assumed by crawlers, and is also the destination of the call instruction that rom is initialized with.) [ avoid clobbering this word since steven's test code will not work in its absence.

